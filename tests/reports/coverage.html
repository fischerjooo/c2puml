<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Code Coverage Report</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #f9f9f9;
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            line-height: 1.6;
            color: #333;
        }
        pre {
            background-color: #fff;
            color: #111;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
            margin: 1rem 0;
            border: 1px solid #eee;
        }
        code {
            white-space: pre;
        }
        .line-number {
            color: #858585;
            margin-right: 1rem;
            user-select: none;
        }
        .covered {
            color: #111;
        }
        .uncovered {
            background-color: #ffeaea;
            color: #111;
        }
        .context {
            background-color: #ffeaea;
        }
        .legend {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0.5rem 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 0.5rem;
            border-radius: 3px;
        }
        .footer {
            text-align: center;
            margin-top: 2rem;
            padding: 1rem;
            color: #7f8c8d;
            border-top: 1px solid #ecf0f1;
        }
    </style>
</head>
<body>
    <h1>Code Coverage Report</h1>
    <p>Generated on 2025-07-25 15:32:08</p>
<h1>ðŸ“Š Detailed Coverage Report</h1>
<p>This report shows all uncovered code lines with context, highlighting which lines are covered and which are not.</p>
<div class="stats">

    <div class="stat">
        <div class="stat-number">84.27%</div>
        <div class="stat-label">Total Coverage</div>
    </div>

    <div class="stat">
        <div class="stat-number">2,962</div>
        <div class="stat-label">Total Statements</div>
    </div>

    <div class="stat">
        <div class="stat-number">466</div>
        <div class="stat-label">Missing Statements</div>
    </div>

    <div class="stat">
        <div class="stat-number">10</div>
        <div class="stat-label">Files with Issues</div>
    </div>
</div>
<div class="legend">
<h3>Legend</h3>
<div class="legend-item">
<div class="legend-color" style="background-color: #4caf50;"></div>
<span>Covered lines: Code that was executed during testing</span>
</div>
<div class="legend-item">
<div class="legend-color" style="background-color: #f44336;"></div>
<span>Uncovered lines: Code that was not executed during testing</span>
</div>
<div class="legend-item">
<div class="legend-color" style="background-color: #858585;"></div>
<span>Context lines: Code before and after uncovered lines</span>
</div>
</div>
<div class="file-section">
<div class="file-header">
/home/runner/work/generator_project/generator_project/c_to_plantuml/parser_tokenizer.py - 88.44% coverage (574/649 lines)
</div>
<h4>Function: __init__ (lines 121-1270)</h4>
<pre>
<span class="line-number">121</span>    def __init__(self):
<span class="line-number">122</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">123</span>
<span class="line-number">124</span>        # Compiled regex patterns for efficiency
<span class="line-number">125</span>        self.patterns = {
<span class="line-number">126</span>            &quot;identifier&quot;: re.compile(r&quot;[a-zA-Z_][a-zA-Z0-9_]*&quot;),
<span class="line-number">127</span>            &quot;number&quot;: re.compile(
<span class="line-number">128</span>                r&quot;0[xX][0-9a-fA-F]+[uUlL]*|0[bB][01]+[uUlL]*|0[0-7]+[uUlL]*|&quot;
<span class="line-number">129</span>                r&quot;\d+\.\d*([eE][+-]?\d+)?[fFlL]*|\d+([eE][+-]?\d+)?[fFlL]*|\d+[uUlL]*&quot;
<span class="line-number">130</span>            ),
<span class="line-number">131</span>            &quot;string&quot;: re.compile(r&#x27;&quot;([^&quot;\\]|\\.)*&quot;&#x27;),
<span class="line-number">132</span>            &quot;char&quot;: re.compile(r&quot;&#x27;([^&#x27;\\]|\\.)&#x27;&quot;),
<span class="line-number">133</span>            &quot;comment_single&quot;: re.compile(r&quot;//.*&quot;),
<span class="line-number">134</span>            &quot;comment_multi&quot;: re.compile(r&quot;/\*.*?\*/&quot;, re.DOTALL),
<span class="line-number">135</span>            &quot;preprocessor&quot;: re.compile(
<span class="line-number">136</span>                r&quot;#(include|define|ifdef|ifndef|if|endif|elif|else|pragma|error|warning)\b.*&quot;
<span class="line-number">137</span>            ),
<span class="line-number">138</span>            &quot;whitespace&quot;: re.compile(r&quot;[ \t]+&quot;),
<span class="line-number">139</span>            &quot;newline&quot;: re.compile(r&quot;\n&quot;),
<span class="line-number">140</span>        }
<span class="line-number">141</span>
<span class="line-number">142</span>    def tokenize(self, content: str) -&gt; List[Token]:
<span class="line-number">143</span>        &quot;&quot;&quot;Tokenize C/C++ source code content&quot;&quot;&quot;
<span class="line-number">144</span>        tokens = []
<span class="line-number">145</span>        lines = content.splitlines()
<span class="line-number">146</span>        total_lines = len(lines)
<span class="line-number">147</span>        line_num = 1
<span class="line-number">148</span>        in_multiline_string = False
<span class="line-number">149</span>        multiline_string_value = &quot;&quot;
<span class="line-number">150</span>        multiline_string_start_line = 0
<span class="line-number">151</span>        multiline_string_start_col = 0
<span class="line-number">152</span>        in_multiline_comment = False
<span class="line-number">153</span>        multiline_comment_value = &quot;&quot;
<span class="line-number">154</span>        multiline_comment_start_line = 0
<span class="line-number">155</span>        multiline_comment_start_col = 0
<span class="line-number">156</span>
<span class="line-number">157</span>        for idx, line in enumerate(lines):
<span class="line-number">158</span>            if in_multiline_string:
<span class="line-number">159</span>                multiline_string_value += &quot;\n&quot; + line
<span class="line-number">160</span>                if &#x27;&quot;&#x27; in line:
<span class="line-number">161</span>                    # End of multiline string
<span class="line-number">162</span>                    in_multiline_string = False
<span class="line-number">163</span>                    tokens.append(
<span class="line-number">164</span>                        Token(
<span class="line-number">165</span>                            TokenType.STRING,
<span class="line-number">166</span>                            multiline_string_value,
<span class="line-number">167</span>                            multiline_string_start_line,
<span class="line-number">168</span>                            multiline_string_start_col,
<span class="line-number">169</span>                        )
<span class="line-number">170</span>                    )
<span class="line-number">171</span>            elif in_multiline_comment:
<span class="line-number">172</span>                # Continue multi-line comment
<span class="line-number">173</span>                multiline_comment_value += &quot;\n&quot; + line
<span class="line-number">174</span>                comment_end = line.find(&quot;*/&quot;)
<span class="line-number">175</span>                if comment_end != -1:
<span class="line-number">176</span>                    # End of multi-line comment
<span class="line-number">177</span>                    in_multiline_comment = False
<span class="line-number">178</span>                    multiline_comment_value = multiline_comment_value[
<span class="line-number">179</span>                        : multiline_comment_value.rfind(&quot;*/&quot;) + 2
<span class="line-number">180</span>                    ]
<span class="line-number">181</span>                    tokens.append(
<span class="line-number">182</span>                        Token(
<span class="line-number">183</span>                            TokenType.COMMENT,
<span class="line-number">184</span>                            multiline_comment_value,
<span class="line-number">185</span>                            multiline_comment_start_line,
<span class="line-number">186</span>                            multiline_comment_start_col,
<span class="line-number">187</span>                        )
<span class="line-number">188</span>                    )
<span class="line-number">189</span>            else:
<span class="line-number">190</span>                line_tokens = self._tokenize_line(line, line_num)
<span class="line-number">191</span>                # Check if a string starts but does not end on this line
<span class="line-number">192</span>                if (
<span class="line-number">193</span>                    line_tokens
<span class="line-number">194</span>                    and line_tokens[-1].type == TokenType.STRING
<span class="line-number">195</span>                    and not line_tokens[-1].value.endswith(&#x27;&quot;&#x27;)
<span class="line-number">196</span>                ):
<span class="line-number">197</span>                    in_multiline_string = True
<span class="line-number">198</span>                    multiline_string_value = line_tokens[-1].value
<span class="line-number">199</span>                    multiline_string_start_line = line_tokens[-1].line
<span class="line-number">200</span>                    multiline_string_start_col = line_tokens[-1].column
<span class="line-number">201</span>                    tokens.extend(line_tokens[:-1])
<span class="line-number">202</span>                # Check if a multi-line comment starts but does not end on this line
<span class="line-number">203</span>                elif (
<span class="line-number">204</span>                    line_tokens
<span class="line-number">205</span>                    and line_tokens[-1].type == TokenType.COMMENT
<span class="line-number">206</span>                    and line_tokens[-1].value.startswith(&quot;/*&quot;)
<span class="line-number">207</span>                    and not line_tokens[-1].value.endswith(&quot;*/&quot;)
<span class="line-number">208</span>                ):
<span class="line-number">209</span>                    in_multiline_comment = True
<span class="line-number">210</span>                    multiline_comment_value = line_tokens[-1].value
<span class="line-number">211</span>                    multiline_comment_start_line = line_tokens[-1].line
<span class="line-number">212</span>                    multiline_comment_start_col = line_tokens[-1].column
<span class="line-number">213</span>                    tokens.extend(line_tokens[:-1])
<span class="line-number">214</span>                else:
<span class="line-number">215</span>                    tokens.extend(line_tokens)
<span class="line-number">216</span>
<span class="line-number">217</span>            if line_num &lt; total_lines:
<span class="line-number">218</span>                tokens.append(Token(TokenType.NEWLINE, &quot;\n&quot;, line_num, len(line)))
<span class="line-number">219</span>            line_num += 1
<span class="line-number">220</span>
<span class="line-number">221</span>        if in_multiline_string:
<span class="line-number">222</span><span class="uncovered">            tokens.append(</span>
<span class="line-number">223</span>                Token(
<span class="line-number">224</span>                    TokenType.STRING,
<span class="line-number">225</span>                    multiline_string_value,
<span class="line-number">226</span>                    multiline_string_start_line,
<span class="line-number">227</span>                    multiline_string_start_col,
<span class="line-number">228</span>                )
<span class="line-number">229</span>            )
<span class="line-number">230</span>        if in_multiline_comment:
<span class="line-number">231</span><span class="uncovered">            tokens.append(</span>
<span class="line-number">232</span>                Token(
<span class="line-number">233</span>                    TokenType.COMMENT,
<span class="line-number">234</span>                    multiline_comment_value,
<span class="line-number">235</span>                    multiline_comment_start_line,
<span class="line-number">236</span>                    multiline_comment_start_col,
<span class="line-number">237</span>                )
<span class="line-number">238</span>            )
<span class="line-number">239</span>
<span class="line-number">240</span>        # Post-process tokens to merge multi-line macros
<span class="line-number">241</span>        tokens = self._merge_multiline_macros(tokens, lines)
<span class="line-number">242</span>
<span class="line-number">243</span>        tokens.append(
<span class="line-number">244</span>            Token(TokenType.EOF, &quot;&quot;, total_lines, len(lines[-1]) if lines else 0)
<span class="line-number">245</span>        )
<span class="line-number">246</span>
<span class="line-number">247</span>        return tokens
<span class="line-number">248</span>
<span class="line-number">249</span>    def _tokenize_line(self, line: str, line_num: int) -&gt; List[Token]:
<span class="line-number">250</span>        &quot;&quot;&quot;Tokenize a single line of code&quot;&quot;&quot;
<span class="line-number">251</span>        tokens = []
<span class="line-number">252</span>        pos = 0
<span class="line-number">253</span>
<span class="line-number">254</span>        while pos &lt; len(line):
<span class="line-number">255</span>            # Skip whitespace but track it
<span class="line-number">256</span>            if match := self.patterns[&quot;whitespace&quot;].match(line, pos):
<span class="line-number">257</span>                tokens.append(Token(TokenType.WHITESPACE, match.group(), line_num, pos))
<span class="line-number">258</span>                pos = match.end()
<span class="line-number">259</span>                continue
<span class="line-number">260</span>
<span class="line-number">261</span>            # Comments
<span class="line-number">262</span>            if match := self.patterns[&quot;comment_single&quot;].match(line, pos):
<span class="line-number">263</span>                tokens.append(Token(TokenType.COMMENT, match.group(), line_num, pos))
<span class="line-number">264</span>                pos = len(line)  # Rest of line is comment
<span class="line-number">265</span>                continue
<span class="line-number">266</span>
<span class="line-number">267</span>            # Multi-line comments - check for /* at start of line or after whitespace
<span class="line-number">268</span>            if line[pos:].startswith(&quot;/*&quot;):
<span class="line-number">269</span>                # Find the end of the comment
<span class="line-number">270</span>                comment_end = line.find(&quot;*/&quot;, pos)
<span class="line-number">271</span>                if comment_end != -1:
<span class="line-number">272</span>                    # Comment ends on this line
<span class="line-number">273</span>                    comment_text = line[pos : comment_end + 2]
<span class="line-number">274</span>                    tokens.append(Token(TokenType.COMMENT, comment_text, line_num, pos))
<span class="line-number">275</span>                    pos = comment_end + 2
<span class="line-number">276</span>                    continue
<span class="line-number">277</span>                else:
<span class="line-number">278</span>                    # Comment continues to next line - create a partial comment token
<span class="line-number">279</span>                    comment_text = line[pos:]
<span class="line-number">280</span>                    tokens.append(Token(TokenType.COMMENT, comment_text, line_num, pos))
<span class="line-number">281</span>                    pos = len(line)
<span class="line-number">282</span>                    continue
<span class="line-number">283</span>
<span class="line-number">284</span>            # Preprocessor directives
<span class="line-number">285</span>            if match := self.patterns[&quot;preprocessor&quot;].match(line, pos):
<span class="line-number">286</span>                value = match.group()
<span class="line-number">287</span>                if value.startswith(&quot;#include&quot;):
<span class="line-number">288</span>                    tokens.append(Token(TokenType.INCLUDE, value, line_num, pos))
<span class="line-number">289</span>                elif value.startswith(&quot;#define&quot;):
<span class="line-number">290</span>                    tokens.append(Token(TokenType.DEFINE, value, line_num, pos))
<span class="line-number">291</span>                else:
<span class="line-number">292</span>                    tokens.append(Token(TokenType.PREPROCESSOR, value, line_num, pos))
<span class="line-number">293</span>                pos = len(line)  # Rest of line is preprocessor
<span class="line-number">294</span>                continue
<span class="line-number">295</span>
<span class="line-number">296</span>            # String literals
<span class="line-number">297</span>            if (
<span class="line-number">298</span>                line[pos] == &#x27;&quot;&#x27;
<span class="line-number">299</span>                or (
<span class="line-number">300</span>                    pos &gt; 0
<span class="line-number">301</span>                    and line[pos - 1] in [&quot;L&quot;, &quot;u&quot;, &quot;U&quot;, &quot;R&quot;]
<span class="line-number">302</span>                    and line[pos] == &#x27;&quot;&#x27;
<span class="line-number">303</span>                )
<span class="line-number">304</span>                or (pos &gt; 1 and line[pos - 2 : pos] == &quot;u8&quot; and line[pos] == &#x27;&quot;&#x27;)
<span class="line-number">305</span>            ):
<span class="line-number">306</span>                # Handle string literals with possible prefixes
<span class="line-number">307</span>                string_start = pos
<span class="line-number">308</span>                if line[pos - 2 : pos] == &quot;u8&quot;:
<span class="line-number">309</span><span class="uncovered">                    string_start -= 2</span>
<span class="line-number">310</span>                elif line[pos - 1] in [&quot;L&quot;, &quot;u&quot;, &quot;U&quot;, &quot;R&quot;]:
<span class="line-number">311</span><span class="uncovered">                    string_start -= 1</span>
<span class="line-number">312</span>                pos += 1  # Skip opening quote
<span class="line-number">313</span>                while pos &lt; len(line):
<span class="line-number">314</span>                    if line[pos] == &#x27;&quot;&#x27;:
<span class="line-number">315</span>                        # Found closing quote
<span class="line-number">316</span>                        string_text = line[string_start : pos + 1]
<span class="line-number">317</span>                        tokens.append(
<span class="line-number">318</span>                            Token(TokenType.STRING, string_text, line_num, string_start)
<span class="line-number">319</span>                        )
<span class="line-number">320</span>                        pos += 1
<span class="line-number">321</span>                        break
<span class="line-number">322</span>                    elif line[pos] == &quot;\\&quot;:
<span class="line-number">323</span>                        pos += 2
<span class="line-number">324</span>                    else:
<span class="line-number">325</span>                        pos += 1
<span class="line-number">326</span>                else:
<span class="line-number">327</span>                    string_text = line[string_start:]
<span class="line-number">328</span>                    tokens.append(
<span class="line-number">329</span>                        Token(TokenType.STRING, string_text, line_num, string_start)
<span class="line-number">330</span>                    )
<span class="line-number">331</span>                    pos = len(line)
<span class="line-number">332</span>                continue
<span class="line-number">333</span>
<span class="line-number">334</span>            # Character literals
<span class="line-number">335</span>            if match := self.patterns[&quot;char&quot;].match(line, pos):
<span class="line-number">336</span>                tokens.append(
<span class="line-number">337</span>                    Token(TokenType.CHAR_LITERAL, match.group(), line_num, pos)
<span class="line-number">338</span>                )
<span class="line-number">339</span>                pos = match.end()
<span class="line-number">340</span>                continue
<span class="line-number">341</span>
<span class="line-number">342</span>            # Numbers
<span class="line-number">343</span>            if match := self.patterns[&quot;number&quot;].match(line, pos):
<span class="line-number">344</span>                tokens.append(Token(TokenType.NUMBER, match.group(), line_num, pos))
<span class="line-number">345</span>                pos = match.end()
<span class="line-number">346</span>                continue
<span class="line-number">347</span>
<span class="line-number">348</span>            # Single character tokens
<span class="line-number">349</span>            if line[pos] in self.SINGLE_CHAR_TOKENS:
<span class="line-number">350</span>                token_type = self.SINGLE_CHAR_TOKENS[line[pos]]
<span class="line-number">351</span>                tokens.append(Token(token_type, line[pos], line_num, pos))
<span class="line-number">352</span>                pos += 1
<span class="line-number">353</span>                continue
<span class="line-number">354</span>
<span class="line-number">355</span>            # Multi-character operators (&lt;&lt;, &gt;&gt;)
<span class="line-number">356</span>            if line[pos : pos + 2] in [&quot;&lt;&lt;&quot;, &quot;&gt;&gt;&quot;]:
<span class="line-number">357</span>                op = line[pos : pos + 2]
<span class="line-number">358</span>                tokens.append(
<span class="line-number">359</span>                    Token(
<span class="line-number">360</span>                        (
<span class="line-number">361</span>                            TokenType.OPERATOR
<span class="line-number">362</span>                            if hasattr(TokenType, &quot;OPERATOR&quot;)
<span class="line-number">363</span>                            else TokenType.UNKNOWN
<span class="line-number">364</span>                        ),
<span class="line-number">365</span>                        op,
<span class="line-number">366</span>                        line_num,
<span class="line-number">367</span>                        pos,
<span class="line-number">368</span>                    )
<span class="line-number">369</span>                )
<span class="line-number">370</span>                pos += 2
<span class="line-number">371</span>                continue
<span class="line-number">372</span>
<span class="line-number">373</span>            # Identifiers and keywords
<span class="line-number">374</span>            if match := self.patterns[&quot;identifier&quot;].match(line, pos):
<span class="line-number">375</span>                value = match.group()
<span class="line-number">376</span>                token_type = self.KEYWORDS.get(value.lower(), TokenType.IDENTIFIER)
<span class="line-number">377</span>                tokens.append(Token(token_type, value, line_num, pos))
<span class="line-number">378</span>                pos = match.end()
<span class="line-number">379</span>                continue
<span class="line-number">380</span>
<span class="line-number">381</span>            # Unknown character (always one at a time)
<span class="line-number">382</span>            tokens.append(Token(TokenType.UNKNOWN, line[pos], line_num, pos))
<span class="line-number">383</span>            pos += 1
<span class="line-number">384</span>
<span class="line-number">385</span>        return tokens
<span class="line-number">386</span>
<span class="line-number">387</span>    def filter_tokens(
<span class="line-number">388</span>        self, tokens: List[Token], exclude_types: Optional[List[TokenType]] = None
<span class="line-number">389</span>    ) -&gt; List[Token]:
<span class="line-number">390</span>        &quot;&quot;&quot;Filter tokens by type&quot;&quot;&quot;
<span class="line-number">391</span>        if exclude_types is None:
<span class="line-number">392</span>            exclude_types = [
<span class="line-number">393</span>                TokenType.WHITESPACE,
<span class="line-number">394</span>                TokenType.COMMENT,
<span class="line-number">395</span>                TokenType.NEWLINE,
<span class="line-number">396</span>                TokenType.EOF,
<span class="line-number">397</span>            ]
<span class="line-number">398</span>
<span class="line-number">399</span>        return [token for token in tokens if token.type not in exclude_types]
<span class="line-number">400</span>
<span class="line-number">401</span>    def _merge_multiline_macros(
<span class="line-number">402</span>        self, tokens: List[Token], lines: List[str]
<span class="line-number">403</span>    ) -&gt; List[Token]:
<span class="line-number">404</span>        &quot;&quot;&quot;Merge multi-line macro tokens that span multiple lines with backslashes&quot;&quot;&quot;
<span class="line-number">405</span>        merged_tokens = []
<span class="line-number">406</span>        i = 0
<span class="line-number">407</span>
<span class="line-number">408</span>        while i &lt; len(tokens):
<span class="line-number">409</span>            token = tokens[i]
<span class="line-number">410</span>
<span class="line-number">411</span>            if token.type == TokenType.DEFINE and token.value.rstrip().endswith(&quot;\\&quot;):
<span class="line-number">412</span>                # Found a multi-line macro, merge with subsequent lines
<span class="line-number">413</span><span class="uncovered">                macro_content = token.value</span>
<span class="line-number">414</span><span class="uncovered">                current_line = token.line</span>
<span class="line-number">415</span>
<span class="line-number">416</span>                # Continue merging lines until we find one that doesn&#x27;t end with backslash
<span class="line-number">417</span><span class="uncovered">                while macro_content.rstrip().endswith(&quot;\\&quot;):</span>
<span class="line-number">418</span>                    # Remove the backslash and add a newline
<span class="line-number">419</span><span class="uncovered">                    macro_content = macro_content.rstrip()[:-1] + &quot;\n&quot;</span>
<span class="line-number">420</span><span class="uncovered">                    current_line += 1</span>
<span class="line-number">421</span>
<span class="line-number">422</span>                    # Find the next line content
<span class="line-number">423</span><span class="uncovered">                    if current_line &lt;= len(lines):</span>
<span class="line-number">424</span><span class="uncovered">                        next_line = lines[current_line - 1]</span>
<span class="line-number">425</span><span class="uncovered">                        macro_content += next_line</span>
<span class="line-number">426</span>                    else:
<span class="line-number">427</span><span class="uncovered">                        break</span>
<span class="line-number">428</span>
<span class="line-number">429</span>                # Create a new token with the merged content
<span class="line-number">430</span><span class="uncovered">                merged_tokens.append(</span>
<span class="line-number">431</span>                    Token(TokenType.DEFINE, macro_content, token.line, token.column)
<span class="line-number">432</span>                )
<span class="line-number">433</span>            else:
<span class="line-number">434</span>                merged_tokens.append(token)
<span class="line-number">435</span>
<span class="line-number">436</span>            i += 1
<span class="line-number">437</span>
<span class="line-number">438</span>        return merged_tokens
<span class="line-number">439</span>
<span class="line-number">440</span>
<span class="line-number">441</span>class StructureFinder:
<span class="line-number">442</span>    &quot;&quot;&quot;Helper class to find C/C++ structures in token streams&quot;&quot;&quot;
<span class="line-number">443</span>
<span class="line-number">444</span>    def __init__(self, tokens: List[Token]):
<span class="line-number">445</span>        self.tokens = tokens
<span class="line-number">446</span>        self.pos = 0
<span class="line-number">447</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">448</span>
<span class="line-number">449</span>    def find_structs(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">450</span>        &quot;&quot;&quot;Find struct definitions in token stream
<span class="line-number">451</span>
<span class="line-number">452</span>        Returns:
<span class="line-number">453</span>            List of tuples (start_pos, end_pos, struct_name)
<span class="line-number">454</span>        &quot;&quot;&quot;
<span class="line-number">455</span>        structs = []
<span class="line-number">456</span>        self.pos = 0
<span class="line-number">457</span>
<span class="line-number">458</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">459</span>            if self._current_token_is(TokenType.STRUCT):
<span class="line-number">460</span>                struct_info = self._parse_struct()
<span class="line-number">461</span>                if struct_info:
<span class="line-number">462</span>                    structs.append(struct_info)
<span class="line-number">463</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">464</span>                typedef_struct = self._parse_typedef_struct()
<span class="line-number">465</span>                if typedef_struct:
<span class="line-number">466</span>                    structs.append(typedef_struct)
<span class="line-number">467</span>            else:
<span class="line-number">468</span>                self.pos += 1
<span class="line-number">469</span>
<span class="line-number">470</span>        return structs
<span class="line-number">471</span>
<span class="line-number">472</span>    def find_enums(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">473</span>        &quot;&quot;&quot;Find enum definitions in token stream&quot;&quot;&quot;
<span class="line-number">474</span>        enums = []
<span class="line-number">475</span>        self.pos = 0
<span class="line-number">476</span>
<span class="line-number">477</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">478</span>            if self._current_token_is(TokenType.ENUM):
<span class="line-number">479</span>                enum_info = self._parse_enum()
<span class="line-number">480</span>                if enum_info:
<span class="line-number">481</span>                    enums.append(enum_info)
<span class="line-number">482</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">483</span>                typedef_enum = self._parse_typedef_enum()
<span class="line-number">484</span>                if typedef_enum:
<span class="line-number">485</span>                    enums.append(typedef_enum)
<span class="line-number">486</span>            else:
<span class="line-number">487</span>                self.pos += 1
<span class="line-number">488</span>
<span class="line-number">489</span>        return enums
<span class="line-number">490</span>
<span class="line-number">491</span>    def find_functions(self) -&gt; List[Tuple[int, int, str, str, bool]]:
<span class="line-number">492</span>        &quot;&quot;&quot;Find all function declarations and definitions in the token stream
<span class="line-number">493</span>
<span class="line-number">494</span>        Returns:
<span class="line-number">495</span>            List of tuples (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">496</span>        &quot;&quot;&quot;
<span class="line-number">497</span>        functions = []
<span class="line-number">498</span>        self.pos = 0
<span class="line-number">499</span>
<span class="line-number">500</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">501</span>            result = self._parse_function()
<span class="line-number">502</span>            if result:
<span class="line-number">503</span>                functions.append(result)
<span class="line-number">504</span>
<span class="line-number">505</span>        return functions
<span class="line-number">506</span>
<span class="line-number">507</span>    def find_unions(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">508</span>        &quot;&quot;&quot;Find union definitions in token stream&quot;&quot;&quot;
<span class="line-number">509</span>        unions = []
<span class="line-number">510</span>        self.pos = 0
<span class="line-number">511</span>
<span class="line-number">512</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">513</span>            if self._current_token_is(TokenType.UNION):
<span class="line-number">514</span>                union_info = self._parse_union()
<span class="line-number">515</span>                if union_info:
<span class="line-number">516</span>                    unions.append(union_info)
<span class="line-number">517</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">518</span>                typedef_union = self._parse_typedef_union()
<span class="line-number">519</span>                if typedef_union:
<span class="line-number">520</span>                    unions.append(typedef_union)
<span class="line-number">521</span>            else:
<span class="line-number">522</span>                self.pos += 1
<span class="line-number">523</span>
<span class="line-number">524</span>        return unions
<span class="line-number">525</span>
<span class="line-number">526</span>    def _current_token_is(self, token_type: TokenType) -&gt; bool:
<span class="line-number">527</span>        &quot;&quot;&quot;Check if current token is of specified type&quot;&quot;&quot;
<span class="line-number">528</span>        return self.pos &lt; len(self.tokens) and self.tokens[self.pos].type == token_type
<span class="line-number">529</span>
<span class="line-number">530</span>    def _peek_token(self, offset: int = 1) -&gt; Optional[Token]:
<span class="line-number">531</span>        &quot;&quot;&quot;Peek at token at current position + offset&quot;&quot;&quot;
<span class="line-number">532</span><span class="uncovered">        peek_pos = self.pos + offset</span>
<span class="line-number">533</span><span class="uncovered">        return self.tokens[peek_pos] if peek_pos &lt; len(self.tokens) else None</span>
<span class="line-number">534</span>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: tokenize (lines 142-441)</h4>
<pre>
<span class="line-number">142</span>    def tokenize(self, content: str) -&gt; List[Token]:
<span class="line-number">143</span>        &quot;&quot;&quot;Tokenize C/C++ source code content&quot;&quot;&quot;
<span class="line-number">144</span>        tokens = []
<span class="line-number">145</span>        lines = content.splitlines()
<span class="line-number">146</span>        total_lines = len(lines)
<span class="line-number">147</span>        line_num = 1
<span class="line-number">148</span>        in_multiline_string = False
<span class="line-number">149</span>        multiline_string_value = &quot;&quot;
<span class="line-number">150</span>        multiline_string_start_line = 0
<span class="line-number">151</span>        multiline_string_start_col = 0
<span class="line-number">152</span>        in_multiline_comment = False
<span class="line-number">153</span>        multiline_comment_value = &quot;&quot;
<span class="line-number">154</span>        multiline_comment_start_line = 0
<span class="line-number">155</span>        multiline_comment_start_col = 0
<span class="line-number">156</span>
<span class="line-number">157</span>        for idx, line in enumerate(lines):
<span class="line-number">158</span>            if in_multiline_string:
<span class="line-number">159</span>                multiline_string_value += &quot;\n&quot; + line
<span class="line-number">160</span>                if &#x27;&quot;&#x27; in line:
<span class="line-number">161</span>                    # End of multiline string
<span class="line-number">162</span>                    in_multiline_string = False
<span class="line-number">163</span>                    tokens.append(
<span class="line-number">164</span>                        Token(
<span class="line-number">165</span>                            TokenType.STRING,
<span class="line-number">166</span>                            multiline_string_value,
<span class="line-number">167</span>                            multiline_string_start_line,
<span class="line-number">168</span>                            multiline_string_start_col,
<span class="line-number">169</span>                        )
<span class="line-number">170</span>                    )
<span class="line-number">171</span>            elif in_multiline_comment:
<span class="line-number">172</span>                # Continue multi-line comment
<span class="line-number">173</span>                multiline_comment_value += &quot;\n&quot; + line
<span class="line-number">174</span>                comment_end = line.find(&quot;*/&quot;)
<span class="line-number">175</span>                if comment_end != -1:
<span class="line-number">176</span>                    # End of multi-line comment
<span class="line-number">177</span>                    in_multiline_comment = False
<span class="line-number">178</span>                    multiline_comment_value = multiline_comment_value[
<span class="line-number">179</span>                        : multiline_comment_value.rfind(&quot;*/&quot;) + 2
<span class="line-number">180</span>                    ]
<span class="line-number">181</span>                    tokens.append(
<span class="line-number">182</span>                        Token(
<span class="line-number">183</span>                            TokenType.COMMENT,
<span class="line-number">184</span>                            multiline_comment_value,
<span class="line-number">185</span>                            multiline_comment_start_line,
<span class="line-number">186</span>                            multiline_comment_start_col,
<span class="line-number">187</span>                        )
<span class="line-number">188</span>                    )
<span class="line-number">189</span>            else:
<span class="line-number">190</span>                line_tokens = self._tokenize_line(line, line_num)
<span class="line-number">191</span>                # Check if a string starts but does not end on this line
<span class="line-number">192</span>                if (
<span class="line-number">193</span>                    line_tokens
<span class="line-number">194</span>                    and line_tokens[-1].type == TokenType.STRING
<span class="line-number">195</span>                    and not line_tokens[-1].value.endswith(&#x27;&quot;&#x27;)
<span class="line-number">196</span>                ):
<span class="line-number">197</span>                    in_multiline_string = True
<span class="line-number">198</span>                    multiline_string_value = line_tokens[-1].value
<span class="line-number">199</span>                    multiline_string_start_line = line_tokens[-1].line
<span class="line-number">200</span>                    multiline_string_start_col = line_tokens[-1].column
<span class="line-number">201</span>                    tokens.extend(line_tokens[:-1])
<span class="line-number">202</span>                # Check if a multi-line comment starts but does not end on this line
<span class="line-number">203</span>                elif (
<span class="line-number">204</span>                    line_tokens
<span class="line-number">205</span>                    and line_tokens[-1].type == TokenType.COMMENT
<span class="line-number">206</span>                    and line_tokens[-1].value.startswith(&quot;/*&quot;)
<span class="line-number">207</span>                    and not line_tokens[-1].value.endswith(&quot;*/&quot;)
<span class="line-number">208</span>                ):
<span class="line-number">209</span>                    in_multiline_comment = True
<span class="line-number">210</span>                    multiline_comment_value = line_tokens[-1].value
<span class="line-number">211</span>                    multiline_comment_start_line = line_tokens[-1].line
<span class="line-number">212</span>                    multiline_comment_start_col = line_tokens[-1].column
<span class="line-number">213</span>                    tokens.extend(line_tokens[:-1])
<span class="line-number">214</span>                else:
<span class="line-number">215</span>                    tokens.extend(line_tokens)
<span class="line-number">216</span>
<span class="line-number">217</span>            if line_num &lt; total_lines:
<span class="line-number">218</span>                tokens.append(Token(TokenType.NEWLINE, &quot;\n&quot;, line_num, len(line)))
<span class="line-number">219</span>            line_num += 1
<span class="line-number">220</span>
<span class="line-number">221</span>        if in_multiline_string:
<span class="line-number">222</span><span class="uncovered">            tokens.append(</span>
<span class="line-number">223</span>                Token(
<span class="line-number">224</span>                    TokenType.STRING,
<span class="line-number">225</span>                    multiline_string_value,
<span class="line-number">226</span>                    multiline_string_start_line,
<span class="line-number">227</span>                    multiline_string_start_col,
<span class="line-number">228</span>                )
<span class="line-number">229</span>            )
<span class="line-number">230</span>        if in_multiline_comment:
<span class="line-number">231</span><span class="uncovered">            tokens.append(</span>
<span class="line-number">232</span>                Token(
<span class="line-number">233</span>                    TokenType.COMMENT,
<span class="line-number">234</span>                    multiline_comment_value,
<span class="line-number">235</span>                    multiline_comment_start_line,
<span class="line-number">236</span>                    multiline_comment_start_col,
<span class="line-number">237</span>                )
<span class="line-number">238</span>            )
<span class="line-number">239</span>
<span class="line-number">240</span>        # Post-process tokens to merge multi-line macros
<span class="line-number">241</span>        tokens = self._merge_multiline_macros(tokens, lines)
<span class="line-number">242</span>
<span class="line-number">243</span>        tokens.append(
<span class="line-number">244</span>            Token(TokenType.EOF, &quot;&quot;, total_lines, len(lines[-1]) if lines else 0)
<span class="line-number">245</span>        )
<span class="line-number">246</span>
<span class="line-number">247</span>        return tokens
<span class="line-number">248</span>
<span class="line-number">249</span>    def _tokenize_line(self, line: str, line_num: int) -&gt; List[Token]:
<span class="line-number">250</span>        &quot;&quot;&quot;Tokenize a single line of code&quot;&quot;&quot;
<span class="line-number">251</span>        tokens = []
<span class="line-number">252</span>        pos = 0
<span class="line-number">253</span>
<span class="line-number">254</span>        while pos &lt; len(line):
<span class="line-number">255</span>            # Skip whitespace but track it
<span class="line-number">256</span>            if match := self.patterns[&quot;whitespace&quot;].match(line, pos):
<span class="line-number">257</span>                tokens.append(Token(TokenType.WHITESPACE, match.group(), line_num, pos))
<span class="line-number">258</span>                pos = match.end()
<span class="line-number">259</span>                continue
<span class="line-number">260</span>
<span class="line-number">261</span>            # Comments
<span class="line-number">262</span>            if match := self.patterns[&quot;comment_single&quot;].match(line, pos):
<span class="line-number">263</span>                tokens.append(Token(TokenType.COMMENT, match.group(), line_num, pos))
<span class="line-number">264</span>                pos = len(line)  # Rest of line is comment
<span class="line-number">265</span>                continue
<span class="line-number">266</span>
<span class="line-number">267</span>            # Multi-line comments - check for /* at start of line or after whitespace
<span class="line-number">268</span>            if line[pos:].startswith(&quot;/*&quot;):
<span class="line-number">269</span>                # Find the end of the comment
<span class="line-number">270</span>                comment_end = line.find(&quot;*/&quot;, pos)
<span class="line-number">271</span>                if comment_end != -1:
<span class="line-number">272</span>                    # Comment ends on this line
<span class="line-number">273</span>                    comment_text = line[pos : comment_end + 2]
<span class="line-number">274</span>                    tokens.append(Token(TokenType.COMMENT, comment_text, line_num, pos))
<span class="line-number">275</span>                    pos = comment_end + 2
<span class="line-number">276</span>                    continue
<span class="line-number">277</span>                else:
<span class="line-number">278</span>                    # Comment continues to next line - create a partial comment token
<span class="line-number">279</span>                    comment_text = line[pos:]
<span class="line-number">280</span>                    tokens.append(Token(TokenType.COMMENT, comment_text, line_num, pos))
<span class="line-number">281</span>                    pos = len(line)
<span class="line-number">282</span>                    continue
<span class="line-number">283</span>
<span class="line-number">284</span>            # Preprocessor directives
<span class="line-number">285</span>            if match := self.patterns[&quot;preprocessor&quot;].match(line, pos):
<span class="line-number">286</span>                value = match.group()
<span class="line-number">287</span>                if value.startswith(&quot;#include&quot;):
<span class="line-number">288</span>                    tokens.append(Token(TokenType.INCLUDE, value, line_num, pos))
<span class="line-number">289</span>                elif value.startswith(&quot;#define&quot;):
<span class="line-number">290</span>                    tokens.append(Token(TokenType.DEFINE, value, line_num, pos))
<span class="line-number">291</span>                else:
<span class="line-number">292</span>                    tokens.append(Token(TokenType.PREPROCESSOR, value, line_num, pos))
<span class="line-number">293</span>                pos = len(line)  # Rest of line is preprocessor
<span class="line-number">294</span>                continue
<span class="line-number">295</span>
<span class="line-number">296</span>            # String literals
<span class="line-number">297</span>            if (
<span class="line-number">298</span>                line[pos] == &#x27;&quot;&#x27;
<span class="line-number">299</span>                or (
<span class="line-number">300</span>                    pos &gt; 0
<span class="line-number">301</span>                    and line[pos - 1] in [&quot;L&quot;, &quot;u&quot;, &quot;U&quot;, &quot;R&quot;]
<span class="line-number">302</span>                    and line[pos] == &#x27;&quot;&#x27;
<span class="line-number">303</span>                )
<span class="line-number">304</span>                or (pos &gt; 1 and line[pos - 2 : pos] == &quot;u8&quot; and line[pos] == &#x27;&quot;&#x27;)
<span class="line-number">305</span>            ):
<span class="line-number">306</span>                # Handle string literals with possible prefixes
<span class="line-number">307</span>                string_start = pos
<span class="line-number">308</span>                if line[pos - 2 : pos] == &quot;u8&quot;:
<span class="line-number">309</span><span class="uncovered">                    string_start -= 2</span>
<span class="line-number">310</span>                elif line[pos - 1] in [&quot;L&quot;, &quot;u&quot;, &quot;U&quot;, &quot;R&quot;]:
<span class="line-number">311</span><span class="uncovered">                    string_start -= 1</span>
<span class="line-number">312</span>                pos += 1  # Skip opening quote
<span class="line-number">313</span>                while pos &lt; len(line):
<span class="line-number">314</span>                    if line[pos] == &#x27;&quot;&#x27;:
<span class="line-number">315</span>                        # Found closing quote
<span class="line-number">316</span>                        string_text = line[string_start : pos + 1]
<span class="line-number">317</span>                        tokens.append(
<span class="line-number">318</span>                            Token(TokenType.STRING, string_text, line_num, string_start)
<span class="line-number">319</span>                        )
<span class="line-number">320</span>                        pos += 1
<span class="line-number">321</span>                        break
<span class="line-number">322</span>                    elif line[pos] == &quot;\\&quot;:
<span class="line-number">323</span>                        pos += 2
<span class="line-number">324</span>                    else:
<span class="line-number">325</span>                        pos += 1
<span class="line-number">326</span>                else:
<span class="line-number">327</span>                    string_text = line[string_start:]
<span class="line-number">328</span>                    tokens.append(
<span class="line-number">329</span>                        Token(TokenType.STRING, string_text, line_num, string_start)
<span class="line-number">330</span>                    )
<span class="line-number">331</span>                    pos = len(line)
<span class="line-number">332</span>                continue
<span class="line-number">333</span>
<span class="line-number">334</span>            # Character literals
<span class="line-number">335</span>            if match := self.patterns[&quot;char&quot;].match(line, pos):
<span class="line-number">336</span>                tokens.append(
<span class="line-number">337</span>                    Token(TokenType.CHAR_LITERAL, match.group(), line_num, pos)
<span class="line-number">338</span>                )
<span class="line-number">339</span>                pos = match.end()
<span class="line-number">340</span>                continue
<span class="line-number">341</span>
<span class="line-number">342</span>            # Numbers
<span class="line-number">343</span>            if match := self.patterns[&quot;number&quot;].match(line, pos):
<span class="line-number">344</span>                tokens.append(Token(TokenType.NUMBER, match.group(), line_num, pos))
<span class="line-number">345</span>                pos = match.end()
<span class="line-number">346</span>                continue
<span class="line-number">347</span>
<span class="line-number">348</span>            # Single character tokens
<span class="line-number">349</span>            if line[pos] in self.SINGLE_CHAR_TOKENS:
<span class="line-number">350</span>                token_type = self.SINGLE_CHAR_TOKENS[line[pos]]
<span class="line-number">351</span>                tokens.append(Token(token_type, line[pos], line_num, pos))
<span class="line-number">352</span>                pos += 1
<span class="line-number">353</span>                continue
<span class="line-number">354</span>
<span class="line-number">355</span>            # Multi-character operators (&lt;&lt;, &gt;&gt;)
<span class="line-number">356</span>            if line[pos : pos + 2] in [&quot;&lt;&lt;&quot;, &quot;&gt;&gt;&quot;]:
<span class="line-number">357</span>                op = line[pos : pos + 2]
<span class="line-number">358</span>                tokens.append(
<span class="line-number">359</span>                    Token(
<span class="line-number">360</span>                        (
<span class="line-number">361</span>                            TokenType.OPERATOR
<span class="line-number">362</span>                            if hasattr(TokenType, &quot;OPERATOR&quot;)
<span class="line-number">363</span>                            else TokenType.UNKNOWN
<span class="line-number">364</span>                        ),
<span class="line-number">365</span>                        op,
<span class="line-number">366</span>                        line_num,
<span class="line-number">367</span>                        pos,
<span class="line-number">368</span>                    )
<span class="line-number">369</span>                )
<span class="line-number">370</span>                pos += 2
<span class="line-number">371</span>                continue
<span class="line-number">372</span>
<span class="line-number">373</span>            # Identifiers and keywords
<span class="line-number">374</span>            if match := self.patterns[&quot;identifier&quot;].match(line, pos):
<span class="line-number">375</span>                value = match.group()
<span class="line-number">376</span>                token_type = self.KEYWORDS.get(value.lower(), TokenType.IDENTIFIER)
<span class="line-number">377</span>                tokens.append(Token(token_type, value, line_num, pos))
<span class="line-number">378</span>                pos = match.end()
<span class="line-number">379</span>                continue
<span class="line-number">380</span>
<span class="line-number">381</span>            # Unknown character (always one at a time)
<span class="line-number">382</span>            tokens.append(Token(TokenType.UNKNOWN, line[pos], line_num, pos))
<span class="line-number">383</span>            pos += 1
<span class="line-number">384</span>
<span class="line-number">385</span>        return tokens
<span class="line-number">386</span>
<span class="line-number">387</span>    def filter_tokens(
<span class="line-number">388</span>        self, tokens: List[Token], exclude_types: Optional[List[TokenType]] = None
<span class="line-number">389</span>    ) -&gt; List[Token]:
<span class="line-number">390</span>        &quot;&quot;&quot;Filter tokens by type&quot;&quot;&quot;
<span class="line-number">391</span>        if exclude_types is None:
<span class="line-number">392</span>            exclude_types = [
<span class="line-number">393</span>                TokenType.WHITESPACE,
<span class="line-number">394</span>                TokenType.COMMENT,
<span class="line-number">395</span>                TokenType.NEWLINE,
<span class="line-number">396</span>                TokenType.EOF,
<span class="line-number">397</span>            ]
<span class="line-number">398</span>
<span class="line-number">399</span>        return [token for token in tokens if token.type not in exclude_types]
<span class="line-number">400</span>
<span class="line-number">401</span>    def _merge_multiline_macros(
<span class="line-number">402</span>        self, tokens: List[Token], lines: List[str]
<span class="line-number">403</span>    ) -&gt; List[Token]:
<span class="line-number">404</span>        &quot;&quot;&quot;Merge multi-line macro tokens that span multiple lines with backslashes&quot;&quot;&quot;
<span class="line-number">405</span>        merged_tokens = []
<span class="line-number">406</span>        i = 0
<span class="line-number">407</span>
<span class="line-number">408</span>        while i &lt; len(tokens):
<span class="line-number">409</span>            token = tokens[i]
<span class="line-number">410</span>
<span class="line-number">411</span>            if token.type == TokenType.DEFINE and token.value.rstrip().endswith(&quot;\\&quot;):
<span class="line-number">412</span>                # Found a multi-line macro, merge with subsequent lines
<span class="line-number">413</span><span class="uncovered">                macro_content = token.value</span>
<span class="line-number">414</span><span class="uncovered">                current_line = token.line</span>
<span class="line-number">415</span>
<span class="line-number">416</span>                # Continue merging lines until we find one that doesn&#x27;t end with backslash
<span class="line-number">417</span><span class="uncovered">                while macro_content.rstrip().endswith(&quot;\\&quot;):</span>
<span class="line-number">418</span>                    # Remove the backslash and add a newline
<span class="line-number">419</span><span class="uncovered">                    macro_content = macro_content.rstrip()[:-1] + &quot;\n&quot;</span>
<span class="line-number">420</span><span class="uncovered">                    current_line += 1</span>
<span class="line-number">421</span>
<span class="line-number">422</span>                    # Find the next line content
<span class="line-number">423</span><span class="uncovered">                    if current_line &lt;= len(lines):</span>
<span class="line-number">424</span><span class="uncovered">                        next_line = lines[current_line - 1]</span>
<span class="line-number">425</span><span class="uncovered">                        macro_content += next_line</span>
<span class="line-number">426</span>                    else:
<span class="line-number">427</span><span class="uncovered">                        break</span>
<span class="line-number">428</span>
<span class="line-number">429</span>                # Create a new token with the merged content
<span class="line-number">430</span><span class="uncovered">                merged_tokens.append(</span>
<span class="line-number">431</span>                    Token(TokenType.DEFINE, macro_content, token.line, token.column)
<span class="line-number">432</span>                )
<span class="line-number">433</span>            else:
<span class="line-number">434</span>                merged_tokens.append(token)
<span class="line-number">435</span>
<span class="line-number">436</span>            i += 1
<span class="line-number">437</span>
<span class="line-number">438</span>        return merged_tokens
<span class="line-number">439</span>
<span class="line-number">440</span>
<span class="line-number">441</span>class StructureFinder:
</pre>
<h4>Function: _tokenize_line (lines 249-440)</h4>
<pre>
<span class="line-number">249</span>    def _tokenize_line(self, line: str, line_num: int) -&gt; List[Token]:
<span class="line-number">250</span>        &quot;&quot;&quot;Tokenize a single line of code&quot;&quot;&quot;
<span class="line-number">251</span>        tokens = []
<span class="line-number">252</span>        pos = 0
<span class="line-number">253</span>
<span class="line-number">254</span>        while pos &lt; len(line):
<span class="line-number">255</span>            # Skip whitespace but track it
<span class="line-number">256</span>            if match := self.patterns[&quot;whitespace&quot;].match(line, pos):
<span class="line-number">257</span>                tokens.append(Token(TokenType.WHITESPACE, match.group(), line_num, pos))
<span class="line-number">258</span>                pos = match.end()
<span class="line-number">259</span>                continue
<span class="line-number">260</span>
<span class="line-number">261</span>            # Comments
<span class="line-number">262</span>            if match := self.patterns[&quot;comment_single&quot;].match(line, pos):
<span class="line-number">263</span>                tokens.append(Token(TokenType.COMMENT, match.group(), line_num, pos))
<span class="line-number">264</span>                pos = len(line)  # Rest of line is comment
<span class="line-number">265</span>                continue
<span class="line-number">266</span>
<span class="line-number">267</span>            # Multi-line comments - check for /* at start of line or after whitespace
<span class="line-number">268</span>            if line[pos:].startswith(&quot;/*&quot;):
<span class="line-number">269</span>                # Find the end of the comment
<span class="line-number">270</span>                comment_end = line.find(&quot;*/&quot;, pos)
<span class="line-number">271</span>                if comment_end != -1:
<span class="line-number">272</span>                    # Comment ends on this line
<span class="line-number">273</span>                    comment_text = line[pos : comment_end + 2]
<span class="line-number">274</span>                    tokens.append(Token(TokenType.COMMENT, comment_text, line_num, pos))
<span class="line-number">275</span>                    pos = comment_end + 2
<span class="line-number">276</span>                    continue
<span class="line-number">277</span>                else:
<span class="line-number">278</span>                    # Comment continues to next line - create a partial comment token
<span class="line-number">279</span>                    comment_text = line[pos:]
<span class="line-number">280</span>                    tokens.append(Token(TokenType.COMMENT, comment_text, line_num, pos))
<span class="line-number">281</span>                    pos = len(line)
<span class="line-number">282</span>                    continue
<span class="line-number">283</span>
<span class="line-number">284</span>            # Preprocessor directives
<span class="line-number">285</span>            if match := self.patterns[&quot;preprocessor&quot;].match(line, pos):
<span class="line-number">286</span>                value = match.group()
<span class="line-number">287</span>                if value.startswith(&quot;#include&quot;):
<span class="line-number">288</span>                    tokens.append(Token(TokenType.INCLUDE, value, line_num, pos))
<span class="line-number">289</span>                elif value.startswith(&quot;#define&quot;):
<span class="line-number">290</span>                    tokens.append(Token(TokenType.DEFINE, value, line_num, pos))
<span class="line-number">291</span>                else:
<span class="line-number">292</span>                    tokens.append(Token(TokenType.PREPROCESSOR, value, line_num, pos))
<span class="line-number">293</span>                pos = len(line)  # Rest of line is preprocessor
<span class="line-number">294</span>                continue
<span class="line-number">295</span>
<span class="line-number">296</span>            # String literals
<span class="line-number">297</span>            if (
<span class="line-number">298</span>                line[pos] == &#x27;&quot;&#x27;
<span class="line-number">299</span>                or (
<span class="line-number">300</span>                    pos &gt; 0
<span class="line-number">301</span>                    and line[pos - 1] in [&quot;L&quot;, &quot;u&quot;, &quot;U&quot;, &quot;R&quot;]
<span class="line-number">302</span>                    and line[pos] == &#x27;&quot;&#x27;
<span class="line-number">303</span>                )
<span class="line-number">304</span>                or (pos &gt; 1 and line[pos - 2 : pos] == &quot;u8&quot; and line[pos] == &#x27;&quot;&#x27;)
<span class="line-number">305</span>            ):
<span class="line-number">306</span>                # Handle string literals with possible prefixes
<span class="line-number">307</span>                string_start = pos
<span class="line-number">308</span>                if line[pos - 2 : pos] == &quot;u8&quot;:
<span class="line-number">309</span><span class="uncovered">                    string_start -= 2</span>
<span class="line-number">310</span>                elif line[pos - 1] in [&quot;L&quot;, &quot;u&quot;, &quot;U&quot;, &quot;R&quot;]:
<span class="line-number">311</span><span class="uncovered">                    string_start -= 1</span>
<span class="line-number">312</span>                pos += 1  # Skip opening quote
<span class="line-number">313</span>                while pos &lt; len(line):
<span class="line-number">314</span>                    if line[pos] == &#x27;&quot;&#x27;:
<span class="line-number">315</span>                        # Found closing quote
<span class="line-number">316</span>                        string_text = line[string_start : pos + 1]
<span class="line-number">317</span>                        tokens.append(
<span class="line-number">318</span>                            Token(TokenType.STRING, string_text, line_num, string_start)
<span class="line-number">319</span>                        )
<span class="line-number">320</span>                        pos += 1
<span class="line-number">321</span>                        break
<span class="line-number">322</span>                    elif line[pos] == &quot;\\&quot;:
<span class="line-number">323</span>                        pos += 2
<span class="line-number">324</span>                    else:
<span class="line-number">325</span>                        pos += 1
<span class="line-number">326</span>                else:
<span class="line-number">327</span>                    string_text = line[string_start:]
<span class="line-number">328</span>                    tokens.append(
<span class="line-number">329</span>                        Token(TokenType.STRING, string_text, line_num, string_start)
<span class="line-number">330</span>                    )
<span class="line-number">331</span>                    pos = len(line)
<span class="line-number">332</span>                continue
<span class="line-number">333</span>
<span class="line-number">334</span>            # Character literals
<span class="line-number">335</span>            if match := self.patterns[&quot;char&quot;].match(line, pos):
<span class="line-number">336</span>                tokens.append(
<span class="line-number">337</span>                    Token(TokenType.CHAR_LITERAL, match.group(), line_num, pos)
<span class="line-number">338</span>                )
<span class="line-number">339</span>                pos = match.end()
<span class="line-number">340</span>                continue
<span class="line-number">341</span>
<span class="line-number">342</span>            # Numbers
<span class="line-number">343</span>            if match := self.patterns[&quot;number&quot;].match(line, pos):
<span class="line-number">344</span>                tokens.append(Token(TokenType.NUMBER, match.group(), line_num, pos))
<span class="line-number">345</span>                pos = match.end()
<span class="line-number">346</span>                continue
<span class="line-number">347</span>
<span class="line-number">348</span>            # Single character tokens
<span class="line-number">349</span>            if line[pos] in self.SINGLE_CHAR_TOKENS:
<span class="line-number">350</span>                token_type = self.SINGLE_CHAR_TOKENS[line[pos]]
<span class="line-number">351</span>                tokens.append(Token(token_type, line[pos], line_num, pos))
<span class="line-number">352</span>                pos += 1
<span class="line-number">353</span>                continue
<span class="line-number">354</span>
<span class="line-number">355</span>            # Multi-character operators (&lt;&lt;, &gt;&gt;)
<span class="line-number">356</span>            if line[pos : pos + 2] in [&quot;&lt;&lt;&quot;, &quot;&gt;&gt;&quot;]:
<span class="line-number">357</span>                op = line[pos : pos + 2]
<span class="line-number">358</span>                tokens.append(
<span class="line-number">359</span>                    Token(
<span class="line-number">360</span>                        (
<span class="line-number">361</span>                            TokenType.OPERATOR
<span class="line-number">362</span>                            if hasattr(TokenType, &quot;OPERATOR&quot;)
<span class="line-number">363</span>                            else TokenType.UNKNOWN
<span class="line-number">364</span>                        ),
<span class="line-number">365</span>                        op,
<span class="line-number">366</span>                        line_num,
<span class="line-number">367</span>                        pos,
<span class="line-number">368</span>                    )
<span class="line-number">369</span>                )
<span class="line-number">370</span>                pos += 2
<span class="line-number">371</span>                continue
<span class="line-number">372</span>
<span class="line-number">373</span>            # Identifiers and keywords
<span class="line-number">374</span>            if match := self.patterns[&quot;identifier&quot;].match(line, pos):
<span class="line-number">375</span>                value = match.group()
<span class="line-number">376</span>                token_type = self.KEYWORDS.get(value.lower(), TokenType.IDENTIFIER)
<span class="line-number">377</span>                tokens.append(Token(token_type, value, line_num, pos))
<span class="line-number">378</span>                pos = match.end()
<span class="line-number">379</span>                continue
<span class="line-number">380</span>
<span class="line-number">381</span>            # Unknown character (always one at a time)
<span class="line-number">382</span>            tokens.append(Token(TokenType.UNKNOWN, line[pos], line_num, pos))
<span class="line-number">383</span>            pos += 1
<span class="line-number">384</span>
<span class="line-number">385</span>        return tokens
<span class="line-number">386</span>
<span class="line-number">387</span>    def filter_tokens(
<span class="line-number">388</span>        self, tokens: List[Token], exclude_types: Optional[List[TokenType]] = None
<span class="line-number">389</span>    ) -&gt; List[Token]:
<span class="line-number">390</span>        &quot;&quot;&quot;Filter tokens by type&quot;&quot;&quot;
<span class="line-number">391</span>        if exclude_types is None:
<span class="line-number">392</span>            exclude_types = [
<span class="line-number">393</span>                TokenType.WHITESPACE,
<span class="line-number">394</span>                TokenType.COMMENT,
<span class="line-number">395</span>                TokenType.NEWLINE,
<span class="line-number">396</span>                TokenType.EOF,
<span class="line-number">397</span>            ]
<span class="line-number">398</span>
<span class="line-number">399</span>        return [token for token in tokens if token.type not in exclude_types]
<span class="line-number">400</span>
<span class="line-number">401</span>    def _merge_multiline_macros(
<span class="line-number">402</span>        self, tokens: List[Token], lines: List[str]
<span class="line-number">403</span>    ) -&gt; List[Token]:
<span class="line-number">404</span>        &quot;&quot;&quot;Merge multi-line macro tokens that span multiple lines with backslashes&quot;&quot;&quot;
<span class="line-number">405</span>        merged_tokens = []
<span class="line-number">406</span>        i = 0
<span class="line-number">407</span>
<span class="line-number">408</span>        while i &lt; len(tokens):
<span class="line-number">409</span>            token = tokens[i]
<span class="line-number">410</span>
<span class="line-number">411</span>            if token.type == TokenType.DEFINE and token.value.rstrip().endswith(&quot;\\&quot;):
<span class="line-number">412</span>                # Found a multi-line macro, merge with subsequent lines
<span class="line-number">413</span><span class="uncovered">                macro_content = token.value</span>
<span class="line-number">414</span><span class="uncovered">                current_line = token.line</span>
<span class="line-number">415</span>
<span class="line-number">416</span>                # Continue merging lines until we find one that doesn&#x27;t end with backslash
<span class="line-number">417</span><span class="uncovered">                while macro_content.rstrip().endswith(&quot;\\&quot;):</span>
<span class="line-number">418</span>                    # Remove the backslash and add a newline
<span class="line-number">419</span><span class="uncovered">                    macro_content = macro_content.rstrip()[:-1] + &quot;\n&quot;</span>
<span class="line-number">420</span><span class="uncovered">                    current_line += 1</span>
<span class="line-number">421</span>
<span class="line-number">422</span>                    # Find the next line content
<span class="line-number">423</span><span class="uncovered">                    if current_line &lt;= len(lines):</span>
<span class="line-number">424</span><span class="uncovered">                        next_line = lines[current_line - 1]</span>
<span class="line-number">425</span><span class="uncovered">                        macro_content += next_line</span>
<span class="line-number">426</span>                    else:
<span class="line-number">427</span><span class="uncovered">                        break</span>
<span class="line-number">428</span>
<span class="line-number">429</span>                # Create a new token with the merged content
<span class="line-number">430</span><span class="uncovered">                merged_tokens.append(</span>
<span class="line-number">431</span>                    Token(TokenType.DEFINE, macro_content, token.line, token.column)
<span class="line-number">432</span>                )
<span class="line-number">433</span>            else:
<span class="line-number">434</span>                merged_tokens.append(token)
<span class="line-number">435</span>
<span class="line-number">436</span>            i += 1
<span class="line-number">437</span>
<span class="line-number">438</span>        return merged_tokens
<span class="line-number">439</span>
<span class="line-number">440</span>
</pre>
<h4>Function: __init__ (lines 444-1270)</h4>
<pre>
<span class="line-number">444</span>    def __init__(self, tokens: List[Token]):
<span class="line-number">445</span>        self.tokens = tokens
<span class="line-number">446</span>        self.pos = 0
<span class="line-number">447</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">448</span>
<span class="line-number">449</span>    def find_structs(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">450</span>        &quot;&quot;&quot;Find struct definitions in token stream
<span class="line-number">451</span>
<span class="line-number">452</span>        Returns:
<span class="line-number">453</span>            List of tuples (start_pos, end_pos, struct_name)
<span class="line-number">454</span>        &quot;&quot;&quot;
<span class="line-number">455</span>        structs = []
<span class="line-number">456</span>        self.pos = 0
<span class="line-number">457</span>
<span class="line-number">458</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">459</span>            if self._current_token_is(TokenType.STRUCT):
<span class="line-number">460</span>                struct_info = self._parse_struct()
<span class="line-number">461</span>                if struct_info:
<span class="line-number">462</span>                    structs.append(struct_info)
<span class="line-number">463</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">464</span>                typedef_struct = self._parse_typedef_struct()
<span class="line-number">465</span>                if typedef_struct:
<span class="line-number">466</span>                    structs.append(typedef_struct)
<span class="line-number">467</span>            else:
<span class="line-number">468</span>                self.pos += 1
<span class="line-number">469</span>
<span class="line-number">470</span>        return structs
<span class="line-number">471</span>
<span class="line-number">472</span>    def find_enums(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">473</span>        &quot;&quot;&quot;Find enum definitions in token stream&quot;&quot;&quot;
<span class="line-number">474</span>        enums = []
<span class="line-number">475</span>        self.pos = 0
<span class="line-number">476</span>
<span class="line-number">477</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">478</span>            if self._current_token_is(TokenType.ENUM):
<span class="line-number">479</span>                enum_info = self._parse_enum()
<span class="line-number">480</span>                if enum_info:
<span class="line-number">481</span>                    enums.append(enum_info)
<span class="line-number">482</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">483</span>                typedef_enum = self._parse_typedef_enum()
<span class="line-number">484</span>                if typedef_enum:
<span class="line-number">485</span>                    enums.append(typedef_enum)
<span class="line-number">486</span>            else:
<span class="line-number">487</span>                self.pos += 1
<span class="line-number">488</span>
<span class="line-number">489</span>        return enums
<span class="line-number">490</span>
<span class="line-number">491</span>    def find_functions(self) -&gt; List[Tuple[int, int, str, str, bool]]:
<span class="line-number">492</span>        &quot;&quot;&quot;Find all function declarations and definitions in the token stream
<span class="line-number">493</span>
<span class="line-number">494</span>        Returns:
<span class="line-number">495</span>            List of tuples (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">496</span>        &quot;&quot;&quot;
<span class="line-number">497</span>        functions = []
<span class="line-number">498</span>        self.pos = 0
<span class="line-number">499</span>
<span class="line-number">500</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">501</span>            result = self._parse_function()
<span class="line-number">502</span>            if result:
<span class="line-number">503</span>                functions.append(result)
<span class="line-number">504</span>
<span class="line-number">505</span>        return functions
<span class="line-number">506</span>
<span class="line-number">507</span>    def find_unions(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">508</span>        &quot;&quot;&quot;Find union definitions in token stream&quot;&quot;&quot;
<span class="line-number">509</span>        unions = []
<span class="line-number">510</span>        self.pos = 0
<span class="line-number">511</span>
<span class="line-number">512</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">513</span>            if self._current_token_is(TokenType.UNION):
<span class="line-number">514</span>                union_info = self._parse_union()
<span class="line-number">515</span>                if union_info:
<span class="line-number">516</span>                    unions.append(union_info)
<span class="line-number">517</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">518</span>                typedef_union = self._parse_typedef_union()
<span class="line-number">519</span>                if typedef_union:
<span class="line-number">520</span>                    unions.append(typedef_union)
<span class="line-number">521</span>            else:
<span class="line-number">522</span>                self.pos += 1
<span class="line-number">523</span>
<span class="line-number">524</span>        return unions
<span class="line-number">525</span>
<span class="line-number">526</span>    def _current_token_is(self, token_type: TokenType) -&gt; bool:
<span class="line-number">527</span>        &quot;&quot;&quot;Check if current token is of specified type&quot;&quot;&quot;
<span class="line-number">528</span>        return self.pos &lt; len(self.tokens) and self.tokens[self.pos].type == token_type
<span class="line-number">529</span>
<span class="line-number">530</span>    def _peek_token(self, offset: int = 1) -&gt; Optional[Token]:
<span class="line-number">531</span>        &quot;&quot;&quot;Peek at token at current position + offset&quot;&quot;&quot;
<span class="line-number">532</span><span class="uncovered">        peek_pos = self.pos + offset</span>
<span class="line-number">533</span><span class="uncovered">        return self.tokens[peek_pos] if peek_pos &lt; len(self.tokens) else None</span>
<span class="line-number">534</span>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: find_structs (lines 449-1270)</h4>
<pre>
<span class="line-number">449</span>    def find_structs(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">450</span>        &quot;&quot;&quot;Find struct definitions in token stream
<span class="line-number">451</span>
<span class="line-number">452</span>        Returns:
<span class="line-number">453</span>            List of tuples (start_pos, end_pos, struct_name)
<span class="line-number">454</span>        &quot;&quot;&quot;
<span class="line-number">455</span>        structs = []
<span class="line-number">456</span>        self.pos = 0
<span class="line-number">457</span>
<span class="line-number">458</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">459</span>            if self._current_token_is(TokenType.STRUCT):
<span class="line-number">460</span>                struct_info = self._parse_struct()
<span class="line-number">461</span>                if struct_info:
<span class="line-number">462</span>                    structs.append(struct_info)
<span class="line-number">463</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">464</span>                typedef_struct = self._parse_typedef_struct()
<span class="line-number">465</span>                if typedef_struct:
<span class="line-number">466</span>                    structs.append(typedef_struct)
<span class="line-number">467</span>            else:
<span class="line-number">468</span>                self.pos += 1
<span class="line-number">469</span>
<span class="line-number">470</span>        return structs
<span class="line-number">471</span>
<span class="line-number">472</span>    def find_enums(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">473</span>        &quot;&quot;&quot;Find enum definitions in token stream&quot;&quot;&quot;
<span class="line-number">474</span>        enums = []
<span class="line-number">475</span>        self.pos = 0
<span class="line-number">476</span>
<span class="line-number">477</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">478</span>            if self._current_token_is(TokenType.ENUM):
<span class="line-number">479</span>                enum_info = self._parse_enum()
<span class="line-number">480</span>                if enum_info:
<span class="line-number">481</span>                    enums.append(enum_info)
<span class="line-number">482</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">483</span>                typedef_enum = self._parse_typedef_enum()
<span class="line-number">484</span>                if typedef_enum:
<span class="line-number">485</span>                    enums.append(typedef_enum)
<span class="line-number">486</span>            else:
<span class="line-number">487</span>                self.pos += 1
<span class="line-number">488</span>
<span class="line-number">489</span>        return enums
<span class="line-number">490</span>
<span class="line-number">491</span>    def find_functions(self) -&gt; List[Tuple[int, int, str, str, bool]]:
<span class="line-number">492</span>        &quot;&quot;&quot;Find all function declarations and definitions in the token stream
<span class="line-number">493</span>
<span class="line-number">494</span>        Returns:
<span class="line-number">495</span>            List of tuples (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">496</span>        &quot;&quot;&quot;
<span class="line-number">497</span>        functions = []
<span class="line-number">498</span>        self.pos = 0
<span class="line-number">499</span>
<span class="line-number">500</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">501</span>            result = self._parse_function()
<span class="line-number">502</span>            if result:
<span class="line-number">503</span>                functions.append(result)
<span class="line-number">504</span>
<span class="line-number">505</span>        return functions
<span class="line-number">506</span>
<span class="line-number">507</span>    def find_unions(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">508</span>        &quot;&quot;&quot;Find union definitions in token stream&quot;&quot;&quot;
<span class="line-number">509</span>        unions = []
<span class="line-number">510</span>        self.pos = 0
<span class="line-number">511</span>
<span class="line-number">512</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">513</span>            if self._current_token_is(TokenType.UNION):
<span class="line-number">514</span>                union_info = self._parse_union()
<span class="line-number">515</span>                if union_info:
<span class="line-number">516</span>                    unions.append(union_info)
<span class="line-number">517</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">518</span>                typedef_union = self._parse_typedef_union()
<span class="line-number">519</span>                if typedef_union:
<span class="line-number">520</span>                    unions.append(typedef_union)
<span class="line-number">521</span>            else:
<span class="line-number">522</span>                self.pos += 1
<span class="line-number">523</span>
<span class="line-number">524</span>        return unions
<span class="line-number">525</span>
<span class="line-number">526</span>    def _current_token_is(self, token_type: TokenType) -&gt; bool:
<span class="line-number">527</span>        &quot;&quot;&quot;Check if current token is of specified type&quot;&quot;&quot;
<span class="line-number">528</span>        return self.pos &lt; len(self.tokens) and self.tokens[self.pos].type == token_type
<span class="line-number">529</span>
<span class="line-number">530</span>    def _peek_token(self, offset: int = 1) -&gt; Optional[Token]:
<span class="line-number">531</span>        &quot;&quot;&quot;Peek at token at current position + offset&quot;&quot;&quot;
<span class="line-number">532</span><span class="uncovered">        peek_pos = self.pos + offset</span>
<span class="line-number">533</span><span class="uncovered">        return self.tokens[peek_pos] if peek_pos &lt; len(self.tokens) else None</span>
<span class="line-number">534</span>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: find_enums (lines 472-1270)</h4>
<pre>
<span class="line-number">472</span>    def find_enums(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">473</span>        &quot;&quot;&quot;Find enum definitions in token stream&quot;&quot;&quot;
<span class="line-number">474</span>        enums = []
<span class="line-number">475</span>        self.pos = 0
<span class="line-number">476</span>
<span class="line-number">477</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">478</span>            if self._current_token_is(TokenType.ENUM):
<span class="line-number">479</span>                enum_info = self._parse_enum()
<span class="line-number">480</span>                if enum_info:
<span class="line-number">481</span>                    enums.append(enum_info)
<span class="line-number">482</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">483</span>                typedef_enum = self._parse_typedef_enum()
<span class="line-number">484</span>                if typedef_enum:
<span class="line-number">485</span>                    enums.append(typedef_enum)
<span class="line-number">486</span>            else:
<span class="line-number">487</span>                self.pos += 1
<span class="line-number">488</span>
<span class="line-number">489</span>        return enums
<span class="line-number">490</span>
<span class="line-number">491</span>    def find_functions(self) -&gt; List[Tuple[int, int, str, str, bool]]:
<span class="line-number">492</span>        &quot;&quot;&quot;Find all function declarations and definitions in the token stream
<span class="line-number">493</span>
<span class="line-number">494</span>        Returns:
<span class="line-number">495</span>            List of tuples (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">496</span>        &quot;&quot;&quot;
<span class="line-number">497</span>        functions = []
<span class="line-number">498</span>        self.pos = 0
<span class="line-number">499</span>
<span class="line-number">500</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">501</span>            result = self._parse_function()
<span class="line-number">502</span>            if result:
<span class="line-number">503</span>                functions.append(result)
<span class="line-number">504</span>
<span class="line-number">505</span>        return functions
<span class="line-number">506</span>
<span class="line-number">507</span>    def find_unions(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">508</span>        &quot;&quot;&quot;Find union definitions in token stream&quot;&quot;&quot;
<span class="line-number">509</span>        unions = []
<span class="line-number">510</span>        self.pos = 0
<span class="line-number">511</span>
<span class="line-number">512</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">513</span>            if self._current_token_is(TokenType.UNION):
<span class="line-number">514</span>                union_info = self._parse_union()
<span class="line-number">515</span>                if union_info:
<span class="line-number">516</span>                    unions.append(union_info)
<span class="line-number">517</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">518</span>                typedef_union = self._parse_typedef_union()
<span class="line-number">519</span>                if typedef_union:
<span class="line-number">520</span>                    unions.append(typedef_union)
<span class="line-number">521</span>            else:
<span class="line-number">522</span>                self.pos += 1
<span class="line-number">523</span>
<span class="line-number">524</span>        return unions
<span class="line-number">525</span>
<span class="line-number">526</span>    def _current_token_is(self, token_type: TokenType) -&gt; bool:
<span class="line-number">527</span>        &quot;&quot;&quot;Check if current token is of specified type&quot;&quot;&quot;
<span class="line-number">528</span>        return self.pos &lt; len(self.tokens) and self.tokens[self.pos].type == token_type
<span class="line-number">529</span>
<span class="line-number">530</span>    def _peek_token(self, offset: int = 1) -&gt; Optional[Token]:
<span class="line-number">531</span>        &quot;&quot;&quot;Peek at token at current position + offset&quot;&quot;&quot;
<span class="line-number">532</span><span class="uncovered">        peek_pos = self.pos + offset</span>
<span class="line-number">533</span><span class="uncovered">        return self.tokens[peek_pos] if peek_pos &lt; len(self.tokens) else None</span>
<span class="line-number">534</span>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: find_functions (lines 491-1270)</h4>
<pre>
<span class="line-number">491</span>    def find_functions(self) -&gt; List[Tuple[int, int, str, str, bool]]:
<span class="line-number">492</span>        &quot;&quot;&quot;Find all function declarations and definitions in the token stream
<span class="line-number">493</span>
<span class="line-number">494</span>        Returns:
<span class="line-number">495</span>            List of tuples (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">496</span>        &quot;&quot;&quot;
<span class="line-number">497</span>        functions = []
<span class="line-number">498</span>        self.pos = 0
<span class="line-number">499</span>
<span class="line-number">500</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">501</span>            result = self._parse_function()
<span class="line-number">502</span>            if result:
<span class="line-number">503</span>                functions.append(result)
<span class="line-number">504</span>
<span class="line-number">505</span>        return functions
<span class="line-number">506</span>
<span class="line-number">507</span>    def find_unions(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">508</span>        &quot;&quot;&quot;Find union definitions in token stream&quot;&quot;&quot;
<span class="line-number">509</span>        unions = []
<span class="line-number">510</span>        self.pos = 0
<span class="line-number">511</span>
<span class="line-number">512</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">513</span>            if self._current_token_is(TokenType.UNION):
<span class="line-number">514</span>                union_info = self._parse_union()
<span class="line-number">515</span>                if union_info:
<span class="line-number">516</span>                    unions.append(union_info)
<span class="line-number">517</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">518</span>                typedef_union = self._parse_typedef_union()
<span class="line-number">519</span>                if typedef_union:
<span class="line-number">520</span>                    unions.append(typedef_union)
<span class="line-number">521</span>            else:
<span class="line-number">522</span>                self.pos += 1
<span class="line-number">523</span>
<span class="line-number">524</span>        return unions
<span class="line-number">525</span>
<span class="line-number">526</span>    def _current_token_is(self, token_type: TokenType) -&gt; bool:
<span class="line-number">527</span>        &quot;&quot;&quot;Check if current token is of specified type&quot;&quot;&quot;
<span class="line-number">528</span>        return self.pos &lt; len(self.tokens) and self.tokens[self.pos].type == token_type
<span class="line-number">529</span>
<span class="line-number">530</span>    def _peek_token(self, offset: int = 1) -&gt; Optional[Token]:
<span class="line-number">531</span>        &quot;&quot;&quot;Peek at token at current position + offset&quot;&quot;&quot;
<span class="line-number">532</span><span class="uncovered">        peek_pos = self.pos + offset</span>
<span class="line-number">533</span><span class="uncovered">        return self.tokens[peek_pos] if peek_pos &lt; len(self.tokens) else None</span>
<span class="line-number">534</span>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: find_unions (lines 507-1270)</h4>
<pre>
<span class="line-number">507</span>    def find_unions(self) -&gt; List[Tuple[int, int, str]]:
<span class="line-number">508</span>        &quot;&quot;&quot;Find union definitions in token stream&quot;&quot;&quot;
<span class="line-number">509</span>        unions = []
<span class="line-number">510</span>        self.pos = 0
<span class="line-number">511</span>
<span class="line-number">512</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">513</span>            if self._current_token_is(TokenType.UNION):
<span class="line-number">514</span>                union_info = self._parse_union()
<span class="line-number">515</span>                if union_info:
<span class="line-number">516</span>                    unions.append(union_info)
<span class="line-number">517</span>            elif self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">518</span>                typedef_union = self._parse_typedef_union()
<span class="line-number">519</span>                if typedef_union:
<span class="line-number">520</span>                    unions.append(typedef_union)
<span class="line-number">521</span>            else:
<span class="line-number">522</span>                self.pos += 1
<span class="line-number">523</span>
<span class="line-number">524</span>        return unions
<span class="line-number">525</span>
<span class="line-number">526</span>    def _current_token_is(self, token_type: TokenType) -&gt; bool:
<span class="line-number">527</span>        &quot;&quot;&quot;Check if current token is of specified type&quot;&quot;&quot;
<span class="line-number">528</span>        return self.pos &lt; len(self.tokens) and self.tokens[self.pos].type == token_type
<span class="line-number">529</span>
<span class="line-number">530</span>    def _peek_token(self, offset: int = 1) -&gt; Optional[Token]:
<span class="line-number">531</span>        &quot;&quot;&quot;Peek at token at current position + offset&quot;&quot;&quot;
<span class="line-number">532</span><span class="uncovered">        peek_pos = self.pos + offset</span>
<span class="line-number">533</span><span class="uncovered">        return self.tokens[peek_pos] if peek_pos &lt; len(self.tokens) else None</span>
<span class="line-number">534</span>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _current_token_is (lines 526-1270)</h4>
<pre>
<span class="line-number">526</span>    def _current_token_is(self, token_type: TokenType) -&gt; bool:
<span class="line-number">527</span>        &quot;&quot;&quot;Check if current token is of specified type&quot;&quot;&quot;
<span class="line-number">528</span>        return self.pos &lt; len(self.tokens) and self.tokens[self.pos].type == token_type
<span class="line-number">529</span>
<span class="line-number">530</span>    def _peek_token(self, offset: int = 1) -&gt; Optional[Token]:
<span class="line-number">531</span>        &quot;&quot;&quot;Peek at token at current position + offset&quot;&quot;&quot;
<span class="line-number">532</span><span class="uncovered">        peek_pos = self.pos + offset</span>
<span class="line-number">533</span><span class="uncovered">        return self.tokens[peek_pos] if peek_pos &lt; len(self.tokens) else None</span>
<span class="line-number">534</span>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _peek_token (lines 530-1270)</h4>
<pre>
<span class="line-number">530</span>    def _peek_token(self, offset: int = 1) -&gt; Optional[Token]:
<span class="line-number">531</span>        &quot;&quot;&quot;Peek at token at current position + offset&quot;&quot;&quot;
<span class="line-number">532</span><span class="uncovered">        peek_pos = self.pos + offset</span>
<span class="line-number">533</span><span class="uncovered">        return self.tokens[peek_pos] if peek_pos &lt; len(self.tokens) else None</span>
<span class="line-number">534</span>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _advance (lines 535-1270)</h4>
<pre>
<span class="line-number">535</span>    def _advance(self) -&gt; Optional[Token]:
<span class="line-number">536</span>        &quot;&quot;&quot;Advance to next token and return current&quot;&quot;&quot;
<span class="line-number">537</span>        if self.pos &lt; len(self.tokens):
<span class="line-number">538</span>            token = self.tokens[self.pos]
<span class="line-number">539</span>            self.pos += 1
<span class="line-number">540</span>            return token
<span class="line-number">541</span><span class="uncovered">        return None</span>
<span class="line-number">542</span>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _find_matching_brace (lines 543-1270)</h4>
<pre>
<span class="line-number">543</span>    def _find_matching_brace(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">544</span>        &quot;&quot;&quot;Find matching closing brace starting from open brace position&quot;&quot;&quot;
<span class="line-number">545</span>        if (
<span class="line-number">546</span>            start_pos &gt;= len(self.tokens)
<span class="line-number">547</span>            or self.tokens[start_pos].type != TokenType.LBRACE
<span class="line-number">548</span>        ):
<span class="line-number">549</span><span class="uncovered">            return None</span>
<span class="line-number">550</span>
<span class="line-number">551</span>        depth = 1
<span class="line-number">552</span>        pos = start_pos + 1
<span class="line-number">553</span>
<span class="line-number">554</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">555</span>            if self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">556</span>                depth += 1
<span class="line-number">557</span>            elif self.tokens[pos].type == TokenType.RBRACE:
<span class="line-number">558</span>                depth -= 1
<span class="line-number">559</span>            pos += 1
<span class="line-number">560</span>
<span class="line-number">561</span>        return pos - 1 if depth == 0 else None
<span class="line-number">562</span>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _parse_struct (lines 563-1270)</h4>
<pre>
<span class="line-number">563</span>    def _parse_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">564</span>        &quot;&quot;&quot;Parse struct definition starting at current position&quot;&quot;&quot;
<span class="line-number">565</span>        start_pos = self.pos
<span class="line-number">566</span>
<span class="line-number">567</span>        # Consume &#x27;struct&#x27; keyword
<span class="line-number">568</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">569</span><span class="uncovered">            return None</span>
<span class="line-number">570</span>        self._advance()
<span class="line-number">571</span>
<span class="line-number">572</span>        # Skip whitespace
<span class="line-number">573</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">574</span>            TokenType.WHITESPACE
<span class="line-number">575</span>        ):
<span class="line-number">576</span>            self.pos += 1
<span class="line-number">577</span>
<span class="line-number">578</span>        # Get struct tag name (optional for anonymous structs)
<span class="line-number">579</span>        struct_tag = &quot;&quot;
<span class="line-number">580</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">581</span>            struct_tag = self._advance().value
<span class="line-number">582</span>
<span class="line-number">583</span>        # Find opening brace
<span class="line-number">584</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">585</span>            TokenType.LBRACE
<span class="line-number">586</span>        ):
<span class="line-number">587</span>            self.pos += 1
<span class="line-number">588</span>
<span class="line-number">589</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">590</span>            return None
<span class="line-number">591</span>
<span class="line-number">592</span>        # Find matching closing brace
<span class="line-number">593</span>        brace_pos = self.pos
<span class="line-number">594</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">595</span>
<span class="line-number">596</span>        if end_brace_pos is None:
<span class="line-number">597</span><span class="uncovered">            return None</span>
<span class="line-number">598</span>
<span class="line-number">599</span>        # Look for struct name after closing brace
<span class="line-number">600</span>        name_pos = end_brace_pos + 1
<span class="line-number">601</span>        struct_name = struct_tag  # Default to tag name
<span class="line-number">602</span>
<span class="line-number">603</span>        # Check if this is a typedef struct by looking backwards
<span class="line-number">604</span>        is_typedef = False
<span class="line-number">605</span>        check_pos = start_pos - 1
<span class="line-number">606</span>        while check_pos &gt;= 0:
<span class="line-number">607</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">608</span>                is_typedef = True
<span class="line-number">609</span>                break
<span class="line-number">610</span>            elif self.tokens[check_pos].type in [
<span class="line-number">611</span>                TokenType.STRUCT,
<span class="line-number">612</span>                TokenType.LBRACE,
<span class="line-number">613</span>                TokenType.RBRACE,
<span class="line-number">614</span>            ]:
<span class="line-number">615</span>                break
<span class="line-number">616</span>            check_pos -= 1
<span class="line-number">617</span>
<span class="line-number">618</span>        if is_typedef:
<span class="line-number">619</span>            # For typedef struct, look for the typedef name after the closing brace
<span class="line-number">620</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">621</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">622</span>                    struct_name = self.tokens[name_pos].value
<span class="line-number">623</span>                    break
<span class="line-number">624</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">625</span>                    break
<span class="line-number">626</span>                name_pos += 1
<span class="line-number">627</span>        else:
<span class="line-number">628</span>            # Check if there&#x27;s a variable name after the brace
<span class="line-number">629</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">630</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">631</span>                    # This is a variable name, not a struct name
<span class="line-number">632</span>                    struct_name = &quot;&quot;
<span class="line-number">633</span>                    break
<span class="line-number">634</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">635</span>                    break
<span class="line-number">636</span>                name_pos += 1
<span class="line-number">637</span>
<span class="line-number">638</span>        # Find semicolon (for struct definitions)
<span class="line-number">639</span>        self.pos = end_brace_pos + 1
<span class="line-number">640</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">641</span>            TokenType.SEMICOLON
<span class="line-number">642</span>        ):
<span class="line-number">643</span>            self.pos += 1
<span class="line-number">644</span>
<span class="line-number">645</span>        end_pos = self.pos
<span class="line-number">646</span>        return (start_pos, end_pos, struct_name)
<span class="line-number">647</span>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _parse_typedef_struct (lines 648-1270)</h4>
<pre>
<span class="line-number">648</span>    def _parse_typedef_struct(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">649</span>        &quot;&quot;&quot;Parse typedef struct definition&quot;&quot;&quot;
<span class="line-number">650</span>        start_pos = self.pos
<span class="line-number">651</span>
<span class="line-number">652</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">653</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">654</span><span class="uncovered">            return None</span>
<span class="line-number">655</span>        self._advance()
<span class="line-number">656</span>
<span class="line-number">657</span>        # Look for &#x27;struct&#x27;
<span class="line-number">658</span>        if not self._current_token_is(TokenType.STRUCT):
<span class="line-number">659</span>            # Not a typedef struct, reset position
<span class="line-number">660</span>            self.pos = start_pos + 1
<span class="line-number">661</span>            return None
<span class="line-number">662</span>
<span class="line-number">663</span>        # Skip &#x27;struct&#x27;
<span class="line-number">664</span>        self._advance()
<span class="line-number">665</span>
<span class="line-number">666</span>        # Skip whitespace
<span class="line-number">667</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">668</span>            TokenType.WHITESPACE
<span class="line-number">669</span>        ):
<span class="line-number">670</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">671</span>
<span class="line-number">672</span>        # Get struct tag name (optional)
<span class="line-number">673</span>        struct_tag = &quot;&quot;
<span class="line-number">674</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">675</span>            struct_tag = self._advance().value
<span class="line-number">676</span>
<span class="line-number">677</span>        # Skip whitespace
<span class="line-number">678</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">679</span>            TokenType.WHITESPACE
<span class="line-number">680</span>        ):
<span class="line-number">681</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">682</span>
<span class="line-number">683</span>        # Check if this is a forward declaration (no braces)
<span class="line-number">684</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">685</span>            # This is a forward declaration like &quot;typedef struct Node* NodePtr;&quot;
<span class="line-number">686</span>            # Not a struct definition, so skip it
<span class="line-number">687</span>            self.pos = start_pos + 1
<span class="line-number">688</span>            return None
<span class="line-number">689</span>
<span class="line-number">690</span>        # Find matching closing brace
<span class="line-number">691</span>        end_brace_pos = self._find_matching_brace(self.pos)
<span class="line-number">692</span>        if end_brace_pos is None:
<span class="line-number">693</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">694</span><span class="uncovered">            return None</span>
<span class="line-number">695</span>
<span class="line-number">696</span>        # Look for typedef name after closing brace
<span class="line-number">697</span>        typedef_name = &quot;&quot;
<span class="line-number">698</span>        name_pos = end_brace_pos + 1
<span class="line-number">699</span>        while name_pos &lt; len(self.tokens):
<span class="line-number">700</span>            if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">701</span>                typedef_name = self.tokens[name_pos].value
<span class="line-number">702</span>                break
<span class="line-number">703</span><span class="uncovered">            elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">704</span><span class="uncovered">                break</span>
<span class="line-number">705</span><span class="uncovered">            name_pos += 1</span>
<span class="line-number">706</span>
<span class="line-number">707</span>        # Find semicolon
<span class="line-number">708</span>        while (
<span class="line-number">709</span>            name_pos &lt; len(self.tokens)
<span class="line-number">710</span>            and not self.tokens[name_pos].type == TokenType.SEMICOLON
<span class="line-number">711</span>        ):
<span class="line-number">712</span>            name_pos += 1
<span class="line-number">713</span>
<span class="line-number">714</span>        end_pos = name_pos
<span class="line-number">715</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">716</span>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _parse_enum (lines 717-1270)</h4>
<pre>
<span class="line-number">717</span>    def _parse_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">718</span>        &quot;&quot;&quot;Parse enum definition starting at current position&quot;&quot;&quot;
<span class="line-number">719</span>        start_pos = self.pos
<span class="line-number">720</span>
<span class="line-number">721</span>        # Consume &#x27;enum&#x27; keyword
<span class="line-number">722</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">723</span><span class="uncovered">            return None</span>
<span class="line-number">724</span>        self._advance()
<span class="line-number">725</span>
<span class="line-number">726</span>        # Skip whitespace
<span class="line-number">727</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">728</span>            TokenType.WHITESPACE
<span class="line-number">729</span>        ):
<span class="line-number">730</span>            self.pos += 1
<span class="line-number">731</span>
<span class="line-number">732</span>        # Get enum tag name (optional for anonymous enums)
<span class="line-number">733</span>        enum_tag = &quot;&quot;
<span class="line-number">734</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">735</span>            enum_tag = self._advance().value
<span class="line-number">736</span>
<span class="line-number">737</span>        # Find opening brace
<span class="line-number">738</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">739</span>            TokenType.LBRACE
<span class="line-number">740</span>        ):
<span class="line-number">741</span>            self.pos += 1
<span class="line-number">742</span>
<span class="line-number">743</span>        if not self._current_token_is(TokenType.LBRACE):
<span class="line-number">744</span>            return None
<span class="line-number">745</span>
<span class="line-number">746</span>        # Find matching closing brace
<span class="line-number">747</span>        brace_pos = self.pos
<span class="line-number">748</span>        end_brace_pos = self._find_matching_brace(brace_pos)
<span class="line-number">749</span>
<span class="line-number">750</span>        if end_brace_pos is None:
<span class="line-number">751</span><span class="uncovered">            return None</span>
<span class="line-number">752</span>
<span class="line-number">753</span>        # Look for enum name after closing brace
<span class="line-number">754</span>        name_pos = end_brace_pos + 1
<span class="line-number">755</span>        enum_name = enum_tag  # Default to tag name
<span class="line-number">756</span>
<span class="line-number">757</span>        # Check if this is a typedef enum by looking backwards
<span class="line-number">758</span>        is_typedef = False
<span class="line-number">759</span>        check_pos = start_pos - 1
<span class="line-number">760</span>        while check_pos &gt;= 0:
<span class="line-number">761</span>            if self.tokens[check_pos].type == TokenType.TYPEDEF:
<span class="line-number">762</span>                is_typedef = True
<span class="line-number">763</span>                break
<span class="line-number">764</span>            elif self.tokens[check_pos].type in [
<span class="line-number">765</span>                TokenType.ENUM,
<span class="line-number">766</span>                TokenType.LBRACE,
<span class="line-number">767</span>                TokenType.RBRACE,
<span class="line-number">768</span>            ]:
<span class="line-number">769</span>                break
<span class="line-number">770</span>            check_pos -= 1
<span class="line-number">771</span>
<span class="line-number">772</span>        if is_typedef:
<span class="line-number">773</span>            # For typedef enum, look for the typedef name after the closing brace
<span class="line-number">774</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">775</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">776</span>                    enum_name = self.tokens[name_pos].value
<span class="line-number">777</span>                    break
<span class="line-number">778</span>                elif self.tokens[name_pos].type == TokenType.SEMICOLON:
<span class="line-number">779</span><span class="uncovered">                    break</span>
<span class="line-number">780</span>                name_pos += 1
<span class="line-number">781</span>        elif not enum_tag:
<span class="line-number">782</span>            # Anonymous enum - check if there&#x27;s a variable name after the brace
<span class="line-number">783</span>            while name_pos &lt; len(self.tokens):
<span class="line-number">784</span>                if self.tokens[name_pos].type == TokenType.IDENTIFIER:
<span class="line-number">785</span>                    # This is a variable name, not an enum name
<span class="line-number">786</span>                    enum_name = &quot;&quot;
<span class="line-number">787</span>                    break
<span class="line-number">788</span><span class="uncovered">                elif self.tokens[name_pos].type == TokenType.SEMICOLON:</span>
<span class="line-number">789</span><span class="uncovered">                    break</span>
<span class="line-number">790</span><span class="uncovered">                name_pos += 1</span>
<span class="line-number">791</span>
<span class="line-number">792</span>        # Find semicolon
<span class="line-number">793</span>        self.pos = end_brace_pos + 1
<span class="line-number">794</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">795</span>            TokenType.SEMICOLON
<span class="line-number">796</span>        ):
<span class="line-number">797</span>            self.pos += 1
<span class="line-number">798</span>
<span class="line-number">799</span>        end_pos = self.pos
<span class="line-number">800</span>        return (start_pos, end_pos, enum_name)
<span class="line-number">801</span>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _parse_typedef_enum (lines 802-1270)</h4>
<pre>
<span class="line-number">802</span>    def _parse_typedef_enum(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">803</span>        &quot;&quot;&quot;Parse typedef enum definition&quot;&quot;&quot;
<span class="line-number">804</span>        start_pos = self.pos
<span class="line-number">805</span>
<span class="line-number">806</span>        # Consume &#x27;typedef&#x27;
<span class="line-number">807</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">808</span><span class="uncovered">            return None</span>
<span class="line-number">809</span>        self._advance()
<span class="line-number">810</span>
<span class="line-number">811</span>        # Look for &#x27;enum&#x27;
<span class="line-number">812</span>        if not self._current_token_is(TokenType.ENUM):
<span class="line-number">813</span>            # Not a typedef enum, reset position
<span class="line-number">814</span>            self.pos = start_pos + 1
<span class="line-number">815</span>            return None
<span class="line-number">816</span>
<span class="line-number">817</span>        # Parse the enum part - this will return the tag name (e.g., StatusEnum_tag)
<span class="line-number">818</span>        enum_info = self._parse_enum()
<span class="line-number">819</span>        if not enum_info:
<span class="line-number">820</span><span class="uncovered">            self.pos = start_pos + 1</span>
<span class="line-number">821</span><span class="uncovered">            return None</span>
<span class="line-number">822</span>
<span class="line-number">823</span>        # For typedef enums, we want to return the tag name, not the typedef name
<span class="line-number">824</span>        # The typedef name will be handled separately in the parser
<span class="line-number">825</span>        return enum_info
<span class="line-number">826</span>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _parse_function (lines 827-1270)</h4>
<pre>
<span class="line-number">827</span>    def _parse_function(self) -&gt; Optional[Tuple[int, int, str, str, bool]]:
<span class="line-number">828</span>        &quot;&quot;&quot;Parse function declaration/definition
<span class="line-number">829</span>
<span class="line-number">830</span>        Returns:
<span class="line-number">831</span>            Tuple of (start_pos, end_pos, func_name, return_type, is_declaration)
<span class="line-number">832</span>        &quot;&quot;&quot;
<span class="line-number">833</span>        start_pos = self.pos
<span class="line-number">834</span>
<span class="line-number">835</span>        # Look for function pattern: [modifiers] return_type function_name (params)
<span class="line-number">836</span>        while self.pos &lt; len(self.tokens):
<span class="line-number">837</span>            token = self.tokens[self.pos]
<span class="line-number">838</span>
<span class="line-number">839</span>            # If we hit a parenthesis, check if this is a function
<span class="line-number">840</span>            if token.type == TokenType.LPAREN:
<span class="line-number">841</span>                # Look backwards for function name
<span class="line-number">842</span>                if (
<span class="line-number">843</span>                    self.pos &gt; 0
<span class="line-number">844</span>                    and self.tokens[self.pos - 1].type == TokenType.IDENTIFIER
<span class="line-number">845</span>                ):
<span class="line-number">846</span>                    func_name = self.tokens[self.pos - 1].value
<span class="line-number">847</span>                    func_name_pos = self.pos - 1
<span class="line-number">848</span>
<span class="line-number">849</span>                    # Look backwards from function name to find return type
<span class="line-number">850</span>                    # Start from just before the function name
<span class="line-number">851</span>                    return_type_end = func_name_pos - 1
<span class="line-number">852</span>                    return_type_start = return_type_end
<span class="line-number">853</span>
<span class="line-number">854</span>                    # Skip backwards over whitespace and comments
<span class="line-number">855</span>                    while return_type_start &gt;= 0:
<span class="line-number">856</span>                        token_type = self.tokens[return_type_start].type
<span class="line-number">857</span>                        if token_type in [
<span class="line-number">858</span>                            TokenType.WHITESPACE,
<span class="line-number">859</span>                            TokenType.COMMENT,
<span class="line-number">860</span>                            TokenType.NEWLINE,
<span class="line-number">861</span>                        ]:
<span class="line-number">862</span>                            return_type_start -= 1
<span class="line-number">863</span>                        else:
<span class="line-number">864</span><span class="uncovered">                            break</span>
<span class="line-number">865</span>
<span class="line-number">866</span>                    # If we found a non-whitespace token, that&#x27;s the end of the return type
<span class="line-number">867</span>                    # Now we need to find the start by looking backwards from there
<span class="line-number">868</span>                    if return_type_start &gt;= 0:
<span class="line-number">869</span>                        return_type_end = return_type_start
<span class="line-number">870</span>                        return_type_start = return_type_end
<span class="line-number">871</span>
<span class="line-number">872</span>                        # Define modifiers set (used in token type checking below)
<span class="line-number">873</span>
<span class="line-number">874</span>                        # Collect all tokens that are part of the return type (including modifiers)
<span class="line-number">875</span>                        return_type_tokens = []
<span class="line-number">876</span>
<span class="line-number">877</span>                        # Look back at most 10 tokens to capture multi-token return types
<span class="line-number">878</span>                        max_lookback = max(0, func_name_pos - 10)
<span class="line-number">879</span>                        current_pos = return_type_start
<span class="line-number">880</span>
<span class="line-number">881</span>                        # Collect tokens backwards until we hit a limit or non-return-type token
<span class="line-number">882</span>                        while current_pos &gt;= max_lookback:
<span class="line-number">883</span>                            token_type = self.tokens[current_pos].type
<span class="line-number">884</span>                            if token_type in [
<span class="line-number">885</span>                                TokenType.IDENTIFIER,
<span class="line-number">886</span>                                TokenType.INT,
<span class="line-number">887</span>                                TokenType.VOID,
<span class="line-number">888</span>                                TokenType.CHAR,
<span class="line-number">889</span>                                TokenType.FLOAT,
<span class="line-number">890</span>                                TokenType.DOUBLE,
<span class="line-number">891</span>                                TokenType.LONG,
<span class="line-number">892</span>                                TokenType.SHORT,
<span class="line-number">893</span>                                TokenType.UNSIGNED,
<span class="line-number">894</span>                                TokenType.SIGNED,
<span class="line-number">895</span>                                TokenType.ASTERISK,
<span class="line-number">896</span>                                TokenType.CONST,
<span class="line-number">897</span>                                TokenType.STATIC,
<span class="line-number">898</span>                                TokenType.EXTERN,
<span class="line-number">899</span>                                TokenType.INLINE,
<span class="line-number">900</span>                            ]:
<span class="line-number">901</span>                                return_type_tokens.insert(0, self.tokens[current_pos])
<span class="line-number">902</span>                                current_pos -= 1
<span class="line-number">903</span>                            elif token_type in [
<span class="line-number">904</span>                                TokenType.WHITESPACE,
<span class="line-number">905</span>                                TokenType.COMMENT,
<span class="line-number">906</span>                                TokenType.NEWLINE,
<span class="line-number">907</span>                            ]:
<span class="line-number">908</span>                                # Skip whitespace and continue looking
<span class="line-number">909</span>                                current_pos -= 1
<span class="line-number">910</span>                            else:
<span class="line-number">911</span><span class="uncovered">                                break</span>
<span class="line-number">912</span>
<span class="line-number">913</span>                        # Extract return type
<span class="line-number">914</span>                        if return_type_tokens:
<span class="line-number">915</span>                            return_type = &quot; &quot;.join(
<span class="line-number">916</span>                                t.value for t in return_type_tokens
<span class="line-number">917</span>                            ).strip()
<span class="line-number">918</span>
<span class="line-number">919</span>                            # Find end of function (either ; for declaration or { for definition)
<span class="line-number">920</span>                            end_pos = self._find_function_end(self.pos)
<span class="line-number">921</span>                            if end_pos:
<span class="line-number">922</span>                                # Determine if this is a declaration or definition
<span class="line-number">923</span>                                is_declaration = self._is_function_declaration(end_pos)
<span class="line-number">924</span>                                self.pos = end_pos + 1
<span class="line-number">925</span>                                return (
<span class="line-number">926</span>                                    start_pos,
<span class="line-number">927</span>                                    end_pos,
<span class="line-number">928</span>                                    func_name,
<span class="line-number">929</span>                                    return_type,
<span class="line-number">930</span>                                    is_declaration,
<span class="line-number">931</span>                                )
<span class="line-number">932</span>
<span class="line-number">933</span>            self.pos += 1
<span class="line-number">934</span>
<span class="line-number">935</span>            # Prevent infinite loops - if we&#x27;ve gone too far, this isn&#x27;t a function
<span class="line-number">936</span>            if self.pos - start_pos &gt; 50:
<span class="line-number">937</span>                break
<span class="line-number">938</span>
<span class="line-number">939</span>        # Reset position if no function found
<span class="line-number">940</span>        self.pos = start_pos + 1
<span class="line-number">941</span>        return None
<span class="line-number">942</span>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _is_function_declaration (lines 943-1270)</h4>
<pre>
<span class="line-number">943</span>    def _is_function_declaration(self, end_pos: int) -&gt; bool:
<span class="line-number">944</span>        &quot;&quot;&quot;Check if the function at end_pos is a declaration (ends with ;) or definition (ends with })&quot;&quot;&quot;
<span class="line-number">945</span>        if end_pos &gt;= len(self.tokens):
<span class="line-number">946</span><span class="uncovered">            return False</span>
<span class="line-number">947</span>
<span class="line-number">948</span>        # Look backwards from end_pos to find the last significant token
<span class="line-number">949</span>        pos = end_pos
<span class="line-number">950</span>        while pos &gt;= 0:
<span class="line-number">951</span>            token_type = self.tokens[pos].type
<span class="line-number">952</span>            if token_type not in [
<span class="line-number">953</span>                TokenType.WHITESPACE,
<span class="line-number">954</span>                TokenType.COMMENT,
<span class="line-number">955</span>                TokenType.NEWLINE,
<span class="line-number">956</span>            ]:
<span class="line-number">957</span>                return token_type == TokenType.SEMICOLON
<span class="line-number">958</span><span class="uncovered">            pos -= 1</span>
<span class="line-number">959</span>
<span class="line-number">960</span><span class="uncovered">        return False</span>
<span class="line-number">961</span>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _find_function_end (lines 962-1270)</h4>
<pre>
<span class="line-number">962</span>    def _find_function_end(self, start_pos: int) -&gt; Optional[int]:
<span class="line-number">963</span>        &quot;&quot;&quot;Find end of function declaration or definition&quot;&quot;&quot;
<span class="line-number">964</span>        pos = start_pos
<span class="line-number">965</span>
<span class="line-number">966</span>        # Find matching closing parenthesis
<span class="line-number">967</span>        if pos &gt;= len(self.tokens) or self.tokens[pos].type != TokenType.LPAREN:
<span class="line-number">968</span><span class="uncovered">            return None</span>
<span class="line-number">969</span>
<span class="line-number">970</span>        depth = 1
<span class="line-number">971</span>        pos += 1
<span class="line-number">972</span>
<span class="line-number">973</span>        while pos &lt; len(self.tokens) and depth &gt; 0:
<span class="line-number">974</span>            if self.tokens[pos].type == TokenType.LPAREN:
<span class="line-number">975</span>                depth += 1
<span class="line-number">976</span>            elif self.tokens[pos].type == TokenType.RPAREN:
<span class="line-number">977</span>                depth -= 1
<span class="line-number">978</span>            pos += 1
<span class="line-number">979</span>
<span class="line-number">980</span>        if depth &gt; 0:
<span class="line-number">981</span>            return None
<span class="line-number">982</span>
<span class="line-number">983</span>        # Now look for either ; (declaration) or { (definition)
<span class="line-number">984</span>        while pos &lt; len(self.tokens):
<span class="line-number">985</span>            if self.tokens[pos].type == TokenType.SEMICOLON:
<span class="line-number">986</span>                return pos
<span class="line-number">987</span>            elif self.tokens[pos].type == TokenType.LBRACE:
<span class="line-number">988</span>                # Function definition - find matching brace
<span class="line-number">989</span>                end_brace = self._find_matching_brace(pos)
<span class="line-number">990</span>                return end_brace if end_brace else pos
<span class="line-number">991</span>            pos += 1
<span class="line-number">992</span>
<span class="line-number">993</span><span class="uncovered">        return None</span>
<span class="line-number">994</span>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _parse_union (lines 995-1270)</h4>
<pre>
<span class="line-number">995</span>    def _parse_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">996</span>        &quot;&quot;&quot;Parse union definition&quot;&quot;&quot;
<span class="line-number">997</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">998</span><span class="uncovered">            return None</span>
<span class="line-number">999</span>
<span class="line-number">1000</span>        start_pos = self.pos
<span class="line-number">1001</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1002</span>
<span class="line-number">1003</span>        # Skip whitespace
<span class="line-number">1004</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1005</span>            TokenType.WHITESPACE
<span class="line-number">1006</span>        ):
<span class="line-number">1007</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Get union tag name (optional for anonymous unions)
<span class="line-number">1010</span>        union_tag = &quot;&quot;
<span class="line-number">1011</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1012</span>            union_tag = self._advance().value
<span class="line-number">1013</span>
<span class="line-number">1014</span>        # Find opening brace
<span class="line-number">1015</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1016</span>            TokenType.LBRACE
<span class="line-number">1017</span>        ):
<span class="line-number">1018</span>            self.pos += 1
<span class="line-number">1019</span>
<span class="line-number">1020</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1021</span>            return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>        # Find matching closing brace
<span class="line-number">1024</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1025</span>        if end_pos is None:
<span class="line-number">1026</span><span class="uncovered">            return None</span>
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Look for union name after closing brace (for typedefs or named unions)
<span class="line-number">1029</span>        union_name = union_tag  # Default to tag name
<span class="line-number">1030</span>
<span class="line-number">1031</span>        # Skip to semicolon
<span class="line-number">1032</span>        self.pos = end_pos + 1
<span class="line-number">1033</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1034</span>            TokenType.SEMICOLON
<span class="line-number">1035</span>        ):
<span class="line-number">1036</span><span class="uncovered">            if self._current_token_is(TokenType.IDENTIFIER):</span>
<span class="line-number">1037</span><span class="uncovered">                union_name = self._advance().value</span>
<span class="line-number">1038</span><span class="uncovered">                break</span>
<span class="line-number">1039</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1040</span>
<span class="line-number">1041</span>        return (start_pos, end_pos, union_name)
<span class="line-number">1042</span>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: _parse_typedef_union (lines 1043-1270)</h4>
<pre>
<span class="line-number">1043</span>    def _parse_typedef_union(self) -&gt; Optional[Tuple[int, int, str]]:
<span class="line-number">1044</span>        &quot;&quot;&quot;Parse typedef union definition&quot;&quot;&quot;
<span class="line-number">1045</span>        if not self._current_token_is(TokenType.TYPEDEF):
<span class="line-number">1046</span><span class="uncovered">            return None</span>
<span class="line-number">1047</span>
<span class="line-number">1048</span>        start_pos = self.pos
<span class="line-number">1049</span>        self._advance()  # Consumes &#x27;typedef&#x27;
<span class="line-number">1050</span>
<span class="line-number">1051</span>        # Skip whitespace
<span class="line-number">1052</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1053</span>            TokenType.WHITESPACE
<span class="line-number">1054</span>        ):
<span class="line-number">1055</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1056</span>
<span class="line-number">1057</span>        # Check if next token is &#x27;union&#x27;
<span class="line-number">1058</span>        if not self._current_token_is(TokenType.UNION):
<span class="line-number">1059</span>            return None
<span class="line-number">1060</span>
<span class="line-number">1061</span>        self._advance()  # Consumes &#x27;union&#x27;
<span class="line-number">1062</span>
<span class="line-number">1063</span>        # Skip whitespace
<span class="line-number">1064</span>        while self.pos &lt; len(self.tokens) and self._current_token_is(
<span class="line-number">1065</span>            TokenType.WHITESPACE
<span class="line-number">1066</span>        ):
<span class="line-number">1067</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1068</span>
<span class="line-number">1069</span>        # Get union tag name (optional)
<span class="line-number">1070</span>        union_tag = &quot;&quot;
<span class="line-number">1071</span>        if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1072</span><span class="uncovered">            union_tag = self._advance().value</span>
<span class="line-number">1073</span>
<span class="line-number">1074</span>        # Find opening brace
<span class="line-number">1075</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1076</span>            TokenType.LBRACE
<span class="line-number">1077</span>        ):
<span class="line-number">1078</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1079</span>
<span class="line-number">1080</span>        if self.pos &gt;= len(self.tokens):
<span class="line-number">1081</span><span class="uncovered">            return None</span>
<span class="line-number">1082</span>
<span class="line-number">1083</span>        # Find matching closing brace
<span class="line-number">1084</span>        end_pos = self._find_matching_brace(self.pos)
<span class="line-number">1085</span>        if end_pos is None:
<span class="line-number">1086</span><span class="uncovered">            return None</span>
<span class="line-number">1087</span>
<span class="line-number">1088</span>        # Look for typedef name after closing brace
<span class="line-number">1089</span>        typedef_name = &quot;&quot;
<span class="line-number">1090</span>        self.pos = end_pos + 1
<span class="line-number">1091</span>        while self.pos &lt; len(self.tokens) and not self._current_token_is(
<span class="line-number">1092</span>            TokenType.SEMICOLON
<span class="line-number">1093</span>        ):
<span class="line-number">1094</span>            if self._current_token_is(TokenType.IDENTIFIER):
<span class="line-number">1095</span>                typedef_name = self._advance().value
<span class="line-number">1096</span>                break
<span class="line-number">1097</span><span class="uncovered">            self.pos += 1</span>
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return (start_pos, end_pos, typedef_name)
<span class="line-number">1100</span>
<span class="line-number">1101</span>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: extract_token_range (lines 1102-1270)</h4>
<pre>
<span class="line-number">1102</span>def extract_token_range(tokens: List[Token], start: int, end: int) -&gt; str:
<span class="line-number">1103</span>    &quot;&quot;&quot;Extract raw text from token range, excluding whitespace, comments, and newlines&quot;&quot;&quot;
<span class="line-number">1104</span>    if start &gt;= len(tokens) or end &gt;= len(tokens) or start &gt; end:
<span class="line-number">1105</span>        return &quot;&quot;
<span class="line-number">1106</span>    return &quot; &quot;.join(
<span class="line-number">1107</span>        token.value
<span class="line-number">1108</span>        for token in tokens[start : end + 1]
<span class="line-number">1109</span>        if token.type
<span class="line-number">1110</span>        not in [TokenType.WHITESPACE, TokenType.COMMENT, TokenType.NEWLINE]
<span class="line-number">1111</span>    )
<span class="line-number">1112</span>
<span class="line-number">1113</span>
<span class="line-number">1114</span>def find_struct_fields(
<span class="line-number">1115</span>    tokens: List[Token], struct_start: int, struct_end: int
<span class="line-number">1116</span>) -&gt; List[Tuple[str, str]]:
<span class="line-number">1117</span>    &quot;&quot;&quot;Extract field information from struct token range
<span class="line-number">1118</span>    Returns:
<span class="line-number">1119</span>        List of tuples (field_name, field_type)
<span class="line-number">1120</span>    &quot;&quot;&quot;
<span class="line-number">1121</span>    fields = []
<span class="line-number">1122</span>    pos = struct_start
<span class="line-number">1123</span>    while pos &lt;= struct_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1124</span>        pos += 1
<span class="line-number">1125</span>    if pos &gt; struct_end:
<span class="line-number">1126</span><span class="uncovered">        return fields</span>
<span class="line-number">1127</span>    pos += 1  # Skip opening brace
<span class="line-number">1128</span>
<span class="line-number">1129</span>    # Find the closing brace position
<span class="line-number">1130</span>    closing_brace_pos = pos
<span class="line-number">1131</span>    while (
<span class="line-number">1132</span>        closing_brace_pos &lt;= struct_end
<span class="line-number">1133</span>        and tokens[closing_brace_pos].type != TokenType.RBRACE
<span class="line-number">1134</span>    ):
<span class="line-number">1135</span>        closing_brace_pos += 1
<span class="line-number">1136</span>
<span class="line-number">1137</span>    # Only parse fields up to the closing brace
<span class="line-number">1138</span>    while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1139</span>        field_tokens = []
<span class="line-number">1140</span>        while pos &lt; closing_brace_pos and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">1141</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1142</span>                field_tokens.append(tokens[pos])
<span class="line-number">1143</span>            pos += 1
<span class="line-number">1144</span>
<span class="line-number">1145</span>        # Parse field from collected tokens
<span class="line-number">1146</span>        if len(field_tokens) &gt;= 2:
<span class="line-number">1147</span>            # Check if this is a nested struct field
<span class="line-number">1148</span>            if (
<span class="line-number">1149</span>                len(field_tokens) &gt;= 3
<span class="line-number">1150</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1151</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1152</span>            ):
<span class="line-number">1153</span>                # This is a nested anonymous struct
<span class="line-number">1154</span>                # Find the struct name (last token before semicolon)
<span class="line-number">1155</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1156</span>                # Create a simplified type representation for nested struct
<span class="line-number">1157</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1158</span><span class="uncovered">                if (</span>
<span class="line-number">1159</span>                    field_name
<span class="line-number">1160</span>                    and field_name.strip()
<span class="line-number">1161</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1162</span>                ):
<span class="line-number">1163</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1164</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1165</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1166</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1167</span><span class="uncovered">                        continue</span>
<span class="line-number">1168</span>            # Check if this is a nested struct field with more complex structure
<span class="line-number">1169</span>            elif (
<span class="line-number">1170</span>                len(field_tokens) &gt;= 4
<span class="line-number">1171</span>                and field_tokens[0].type == TokenType.STRUCT
<span class="line-number">1172</span>                and field_tokens[1].type == TokenType.LBRACE
<span class="line-number">1173</span>                and field_tokens[-1].type == TokenType.IDENTIFIER
<span class="line-number">1174</span>            ):
<span class="line-number">1175</span>                # This is a nested anonymous struct with a name
<span class="line-number">1176</span><span class="uncovered">                field_name = field_tokens[-1].value</span>
<span class="line-number">1177</span><span class="uncovered">                field_type = &quot;struct { ... }&quot;</span>
<span class="line-number">1178</span><span class="uncovered">                if (</span>
<span class="line-number">1179</span>                    field_name
<span class="line-number">1180</span>                    and field_name.strip()
<span class="line-number">1181</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1182</span>                ):
<span class="line-number">1183</span><span class="uncovered">                    stripped_name = field_name.strip()</span>
<span class="line-number">1184</span><span class="uncovered">                    if stripped_name:</span>
<span class="line-number">1185</span><span class="uncovered">                        fields.append((stripped_name, field_type))</span>
<span class="line-number">1186</span>                        # Skip parsing the nested struct&#x27;s fields as separate fields
<span class="line-number">1187</span><span class="uncovered">                        continue</span>
<span class="line-number">1188</span>            # Array field: type name [ size ]
<span class="line-number">1189</span>            elif (
<span class="line-number">1190</span>                len(field_tokens) &gt;= 4
<span class="line-number">1191</span>                and field_tokens[-3].type == TokenType.LBRACKET
<span class="line-number">1192</span>                and field_tokens[-1].type == TokenType.RBRACKET
<span class="line-number">1193</span>            ):
<span class="line-number">1194</span>                field_name = field_tokens[-4].value
<span class="line-number">1195</span>                # Fix: Put the size inside the brackets, not before them
<span class="line-number">1196</span>                field_type = (
<span class="line-number">1197</span>                    &quot; &quot;.join(t.value for t in field_tokens[:-4])
<span class="line-number">1198</span>                    + &quot;[&quot;
<span class="line-number">1199</span>                    + field_tokens[-2].value
<span class="line-number">1200</span>                    + &quot;]&quot;
<span class="line-number">1201</span>                )
<span class="line-number">1202</span>                if (
<span class="line-number">1203</span>                    field_name
<span class="line-number">1204</span>                    and field_name.strip()
<span class="line-number">1205</span>                    and field_type.strip()
<span class="line-number">1206</span>                    and field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1207</span>                ):
<span class="line-number">1208</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1209</span>                    stripped_name = field_name.strip()
<span class="line-number">1210</span>                    stripped_type = field_type.strip()
<span class="line-number">1211</span>                    if stripped_name and stripped_type:
<span class="line-number">1212</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1213</span>            else:
<span class="line-number">1214</span>                # Regular field: type name
<span class="line-number">1215</span>                field_name = field_tokens[-1].value
<span class="line-number">1216</span>                field_type = &quot; &quot;.join(t.value for t in field_tokens[:-1])
<span class="line-number">1217</span>                if (
<span class="line-number">1218</span>                    field_name not in [&quot;[&quot;, &quot;]&quot;, &quot;;&quot;, &quot;}&quot;]
<span class="line-number">1219</span>                    and field_name
<span class="line-number">1220</span>                    and field_name.strip()
<span class="line-number">1221</span>                    and field_type.strip()
<span class="line-number">1222</span>                ):
<span class="line-number">1223</span>                    # Additional validation to ensure we don&#x27;t have empty strings
<span class="line-number">1224</span>                    stripped_name = field_name.strip()
<span class="line-number">1225</span>                    stripped_type = field_type.strip()
<span class="line-number">1226</span>                    if stripped_name and stripped_type:
<span class="line-number">1227</span>                        fields.append((stripped_name, stripped_type))
<span class="line-number">1228</span>        if pos &lt; closing_brace_pos:
<span class="line-number">1229</span>            pos += 1  # Skip semicolon
<span class="line-number">1230</span>    return fields
<span class="line-number">1231</span>
<span class="line-number">1232</span>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
<h4>Function: find_enum_values (lines 1233-1270)</h4>
<pre>
<span class="line-number">1233</span>def find_enum_values(tokens: List[Token], enum_start: int, enum_end: int) -&gt; List[str]:
<span class="line-number">1234</span>    &quot;&quot;&quot;Extract enum values from enum token range&quot;&quot;&quot;
<span class="line-number">1235</span>    values = []
<span class="line-number">1236</span>    pos = enum_start
<span class="line-number">1237</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">1238</span>        pos += 1
<span class="line-number">1239</span>    if pos &gt; enum_end:
<span class="line-number">1240</span><span class="uncovered">        return values</span>
<span class="line-number">1241</span>    pos += 1  # Skip opening brace
<span class="line-number">1242</span>    current_value = []
<span class="line-number">1243</span>    while pos &lt;= enum_end and tokens[pos].type != TokenType.RBRACE:
<span class="line-number">1244</span>        token = tokens[pos]
<span class="line-number">1245</span>        if token.type == TokenType.COMMA:
<span class="line-number">1246</span>            if current_value:
<span class="line-number">1247</span>                filtered_value = [
<span class="line-number">1248</span>                    t
<span class="line-number">1249</span>                    for t in current_value
<span class="line-number">1250</span>                    if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1251</span>                ]
<span class="line-number">1252</span>                if filtered_value:
<span class="line-number">1253</span>                    value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1254</span>                    if value_str:
<span class="line-number">1255</span>                        values.append(value_str)
<span class="line-number">1256</span>                current_value = []
<span class="line-number">1257</span>        elif token.type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1258</span>            current_value.append(token)
<span class="line-number">1259</span>        pos += 1
<span class="line-number">1260</span>    if current_value:
<span class="line-number">1261</span>        filtered_value = [
<span class="line-number">1262</span>            t
<span class="line-number">1263</span>            for t in current_value
<span class="line-number">1264</span>            if t.type not in [TokenType.WHITESPACE, TokenType.COMMENT]
<span class="line-number">1265</span>        ]
<span class="line-number">1266</span>        if filtered_value:
<span class="line-number">1267</span>            value_str = &quot; &quot;.join(t.value for t in filtered_value).strip()
<span class="line-number">1268</span>            if value_str:
<span class="line-number">1269</span>                values.append(value_str)
<span class="line-number">1270</span>    return values
</pre>
</div>
<div class="file-section">
<div class="file-header">
/home/runner/work/generator_project/generator_project/c_to_plantuml/verifier.py - 84.17% coverage (117/139 lines)
</div>
<h4>Function: __init__ (lines 18-278)</h4>
<pre>
<span class="line-number"> 18</span>    def __init__(self):
<span class="line-number"> 19</span>        self.logger = logging.getLogger(__name__)
<span class="line-number"> 20</span>        self.issues = []
<span class="line-number"> 21</span>
<span class="line-number"> 22</span>    def verify_model(self, model: ProjectModel) -&gt; Tuple[bool, List[str]]:
<span class="line-number"> 23</span>        &quot;&quot;&quot;
<span class="line-number"> 24</span>        Verify the sanity of the entire model
<span class="line-number"> 25</span>
<span class="line-number"> 26</span>        Args:
<span class="line-number"> 27</span>            model: The ProjectModel to verify
<span class="line-number"> 28</span>
<span class="line-number"> 29</span>        Returns:
<span class="line-number"> 30</span>            Tuple of (is_valid, list_of_issues)
<span class="line-number"> 31</span>        &quot;&quot;&quot;
<span class="line-number"> 32</span>        self.issues = []
<span class="line-number"> 33</span>
<span class="line-number"> 34</span>        # Verify project-level data
<span class="line-number"> 35</span>        self._verify_project_data(model)
<span class="line-number"> 36</span>
<span class="line-number"> 37</span>        # Verify each file
<span class="line-number"> 38</span>        for file_path, file_model in model.files.items():
<span class="line-number"> 39</span>            self._verify_file(file_path, file_model)
<span class="line-number"> 40</span>
<span class="line-number"> 41</span>        is_valid = len(self.issues) == 0
<span class="line-number"> 42</span>
<span class="line-number"> 43</span>        if self.issues:
<span class="line-number"> 44</span>            self.logger.warning(&quot;Model verification found %d issues:&quot;, len(self.issues))
<span class="line-number"> 45</span>            for issue in self.issues:
<span class="line-number"> 46</span>                self.logger.warning(&quot;  - %s&quot;, issue)
<span class="line-number"> 47</span>        else:
<span class="line-number"> 48</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number"> 49</span>
<span class="line-number"> 50</span>        return is_valid, self.issues
<span class="line-number"> 51</span>
<span class="line-number"> 52</span>    def _verify_project_data(self, model: ProjectModel) -&gt; None:
<span class="line-number"> 53</span>        &quot;&quot;&quot;Verify project-level data&quot;&quot;&quot;
<span class="line-number"> 54</span>        if not model.project_name or not model.project_name.strip():
<span class="line-number"> 55</span>            self.issues.append(&quot;Project name is empty or whitespace&quot;)
<span class="line-number"> 56</span>
<span class="line-number"> 57</span>        if not model.project_root or not model.project_root.strip():
<span class="line-number"> 58</span>            self.issues.append(&quot;Project root is empty or whitespace&quot;)
<span class="line-number"> 59</span>
<span class="line-number"> 60</span>        if not model.files:
<span class="line-number"> 61</span>            self.issues.append(&quot;No files found in project&quot;)
<span class="line-number"> 62</span>
<span class="line-number"> 63</span>    def _verify_file(self, file_path: str, file_model: FileModel) -&gt; None:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Verify a single file model&quot;&quot;&quot;
<span class="line-number"> 65</span>        # Verify file-level data
<span class="line-number"> 66</span>        if not file_model.file_path or not file_model.file_path.strip():
<span class="line-number"> 67</span><span class="uncovered">            self.issues.append(f&quot;File path is empty in {file_path}&quot;)</span>
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>        if not file_model.relative_path or not file_model.relative_path.strip():
<span class="line-number"> 70</span><span class="uncovered">            self.issues.append(f&quot;Relative path is empty in {file_path}&quot;)</span>
<span class="line-number"> 71</span>
<span class="line-number"> 72</span>        # Verify structs
<span class="line-number"> 73</span>        for struct_name, struct in file_model.structs.items():
<span class="line-number"> 74</span>            self._verify_struct(file_path, struct_name, struct)
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Verify enums
<span class="line-number"> 77</span>        for enum_name, enum in file_model.enums.items():
<span class="line-number"> 78</span>            self._verify_enum(file_path, enum_name, enum)
<span class="line-number"> 79</span>
<span class="line-number"> 80</span>        # Verify unions
<span class="line-number"> 81</span>        for union_name, union in file_model.unions.items():
<span class="line-number"> 82</span>            self._verify_union(file_path, union_name, union)
<span class="line-number"> 83</span>
<span class="line-number"> 84</span>        # Verify functions
<span class="line-number"> 85</span>        for function in file_model.functions:
<span class="line-number"> 86</span>            self._verify_function(file_path, function)
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        # Verify globals
<span class="line-number"> 89</span>        for global_var in file_model.globals:
<span class="line-number"> 90</span>            self._verify_global(file_path, global_var)
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Verify aliases
<span class="line-number"> 93</span>        for alias_name, alias in file_model.aliases.items():
<span class="line-number"> 94</span>            self._verify_alias(file_path, alias_name, alias)
<span class="line-number"> 95</span>
<span class="line-number"> 96</span>    def _verify_struct(self, file_path: str, struct_name: str, struct: Struct) -&gt; None:
<span class="line-number"> 97</span>        &quot;&quot;&quot;Verify a struct definition&quot;&quot;&quot;
<span class="line-number"> 98</span>        if not self._is_valid_identifier(struct_name):
<span class="line-number"> 99</span>            self.issues.append(f&quot;Invalid struct name &#x27;{struct_name}&#x27; in {file_path}&quot;)
<span class="line-number">100</span>
<span class="line-number">101</span>        if not struct.name or not struct.name.strip():
<span class="line-number">102</span>            self.issues.append(f&quot;Struct name is empty in {file_path}&quot;)
<span class="line-number">103</span>
<span class="line-number">104</span>        # Verify fields
<span class="line-number">105</span>        for field in struct.fields:
<span class="line-number">106</span>            self._verify_field(file_path, f&quot;struct {struct_name}&quot;, field)
<span class="line-number">107</span>
<span class="line-number">108</span>    def _verify_enum(self, file_path: str, enum_name: str, enum: Enum) -&gt; None:
<span class="line-number">109</span>        &quot;&quot;&quot;Verify an enum definition&quot;&quot;&quot;
<span class="line-number">110</span>        if not self._is_valid_identifier(enum_name):
<span class="line-number">111</span><span class="uncovered">            self.issues.append(f&quot;Invalid enum name &#x27;{enum_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">112</span>
<span class="line-number">113</span>        if not enum.name or not enum.name.strip():
<span class="line-number">114</span><span class="uncovered">            self.issues.append(f&quot;Enum name is empty in {file_path}&quot;)</span>
<span class="line-number">115</span>
<span class="line-number">116</span>        # Verify enum values
<span class="line-number">117</span>        for enum_value in enum.values:
<span class="line-number">118</span>            if not enum_value.name or not enum_value.name.strip():
<span class="line-number">119</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">120</span>                    f&quot;Enum value name is empty in enum {enum_name} in {file_path}&quot;
<span class="line-number">121</span>                )
<span class="line-number">122</span>            elif not self._is_valid_identifier(enum_value.name):
<span class="line-number">123</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">124</span>                    f&quot;Invalid enum value name &#x27;{enum_value.name}&#x27; in enum {enum_name} in {file_path}&quot;
<span class="line-number">125</span>                )
<span class="line-number">126</span>
<span class="line-number">127</span>    def _verify_union(self, file_path: str, union_name: str, union: Union) -&gt; None:
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
<span class="line-number">129</span>        if not self._is_valid_identifier(union_name):
<span class="line-number">130</span><span class="uncovered">            self.issues.append(f&quot;Invalid union name &#x27;{union_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">131</span>
<span class="line-number">132</span>        if not union.name or not union.name.strip():
<span class="line-number">133</span><span class="uncovered">            self.issues.append(f&quot;Union name is empty in {file_path}&quot;)</span>
<span class="line-number">134</span>
<span class="line-number">135</span>        # Verify fields
<span class="line-number">136</span>        for field in union.fields:
<span class="line-number">137</span>            self._verify_field(file_path, f&quot;union {union_name}&quot;, field)
<span class="line-number">138</span>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span><span class="uncovered">            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)</span>
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">150</span>                f&quot;Function return type is empty for &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">151</span>            )
<span class="line-number">152</span>
<span class="line-number">153</span>        # Verify parameters (skip variadic parameter &#x27;...&#x27;)
<span class="line-number">154</span>        for param in function.parameters:
<span class="line-number">155</span>            if param.name == &quot;...&quot;:  # Skip variadic parameter
<span class="line-number">156</span>                continue
<span class="line-number">157</span>            self._verify_field(file_path, f&quot;function {function.name}&quot;, param)
<span class="line-number">158</span>
<span class="line-number">159</span>    def _verify_global(self, file_path: str, global_var: Field) -&gt; None:
<span class="line-number">160</span>        &quot;&quot;&quot;Verify a global variable&quot;&quot;&quot;
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: verify_model (lines 22-278)</h4>
<pre>
<span class="line-number"> 22</span>    def verify_model(self, model: ProjectModel) -&gt; Tuple[bool, List[str]]:
<span class="line-number"> 23</span>        &quot;&quot;&quot;
<span class="line-number"> 24</span>        Verify the sanity of the entire model
<span class="line-number"> 25</span>
<span class="line-number"> 26</span>        Args:
<span class="line-number"> 27</span>            model: The ProjectModel to verify
<span class="line-number"> 28</span>
<span class="line-number"> 29</span>        Returns:
<span class="line-number"> 30</span>            Tuple of (is_valid, list_of_issues)
<span class="line-number"> 31</span>        &quot;&quot;&quot;
<span class="line-number"> 32</span>        self.issues = []
<span class="line-number"> 33</span>
<span class="line-number"> 34</span>        # Verify project-level data
<span class="line-number"> 35</span>        self._verify_project_data(model)
<span class="line-number"> 36</span>
<span class="line-number"> 37</span>        # Verify each file
<span class="line-number"> 38</span>        for file_path, file_model in model.files.items():
<span class="line-number"> 39</span>            self._verify_file(file_path, file_model)
<span class="line-number"> 40</span>
<span class="line-number"> 41</span>        is_valid = len(self.issues) == 0
<span class="line-number"> 42</span>
<span class="line-number"> 43</span>        if self.issues:
<span class="line-number"> 44</span>            self.logger.warning(&quot;Model verification found %d issues:&quot;, len(self.issues))
<span class="line-number"> 45</span>            for issue in self.issues:
<span class="line-number"> 46</span>                self.logger.warning(&quot;  - %s&quot;, issue)
<span class="line-number"> 47</span>        else:
<span class="line-number"> 48</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number"> 49</span>
<span class="line-number"> 50</span>        return is_valid, self.issues
<span class="line-number"> 51</span>
<span class="line-number"> 52</span>    def _verify_project_data(self, model: ProjectModel) -&gt; None:
<span class="line-number"> 53</span>        &quot;&quot;&quot;Verify project-level data&quot;&quot;&quot;
<span class="line-number"> 54</span>        if not model.project_name or not model.project_name.strip():
<span class="line-number"> 55</span>            self.issues.append(&quot;Project name is empty or whitespace&quot;)
<span class="line-number"> 56</span>
<span class="line-number"> 57</span>        if not model.project_root or not model.project_root.strip():
<span class="line-number"> 58</span>            self.issues.append(&quot;Project root is empty or whitespace&quot;)
<span class="line-number"> 59</span>
<span class="line-number"> 60</span>        if not model.files:
<span class="line-number"> 61</span>            self.issues.append(&quot;No files found in project&quot;)
<span class="line-number"> 62</span>
<span class="line-number"> 63</span>    def _verify_file(self, file_path: str, file_model: FileModel) -&gt; None:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Verify a single file model&quot;&quot;&quot;
<span class="line-number"> 65</span>        # Verify file-level data
<span class="line-number"> 66</span>        if not file_model.file_path or not file_model.file_path.strip():
<span class="line-number"> 67</span><span class="uncovered">            self.issues.append(f&quot;File path is empty in {file_path}&quot;)</span>
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>        if not file_model.relative_path or not file_model.relative_path.strip():
<span class="line-number"> 70</span><span class="uncovered">            self.issues.append(f&quot;Relative path is empty in {file_path}&quot;)</span>
<span class="line-number"> 71</span>
<span class="line-number"> 72</span>        # Verify structs
<span class="line-number"> 73</span>        for struct_name, struct in file_model.structs.items():
<span class="line-number"> 74</span>            self._verify_struct(file_path, struct_name, struct)
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Verify enums
<span class="line-number"> 77</span>        for enum_name, enum in file_model.enums.items():
<span class="line-number"> 78</span>            self._verify_enum(file_path, enum_name, enum)
<span class="line-number"> 79</span>
<span class="line-number"> 80</span>        # Verify unions
<span class="line-number"> 81</span>        for union_name, union in file_model.unions.items():
<span class="line-number"> 82</span>            self._verify_union(file_path, union_name, union)
<span class="line-number"> 83</span>
<span class="line-number"> 84</span>        # Verify functions
<span class="line-number"> 85</span>        for function in file_model.functions:
<span class="line-number"> 86</span>            self._verify_function(file_path, function)
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        # Verify globals
<span class="line-number"> 89</span>        for global_var in file_model.globals:
<span class="line-number"> 90</span>            self._verify_global(file_path, global_var)
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Verify aliases
<span class="line-number"> 93</span>        for alias_name, alias in file_model.aliases.items():
<span class="line-number"> 94</span>            self._verify_alias(file_path, alias_name, alias)
<span class="line-number"> 95</span>
<span class="line-number"> 96</span>    def _verify_struct(self, file_path: str, struct_name: str, struct: Struct) -&gt; None:
<span class="line-number"> 97</span>        &quot;&quot;&quot;Verify a struct definition&quot;&quot;&quot;
<span class="line-number"> 98</span>        if not self._is_valid_identifier(struct_name):
<span class="line-number"> 99</span>            self.issues.append(f&quot;Invalid struct name &#x27;{struct_name}&#x27; in {file_path}&quot;)
<span class="line-number">100</span>
<span class="line-number">101</span>        if not struct.name or not struct.name.strip():
<span class="line-number">102</span>            self.issues.append(f&quot;Struct name is empty in {file_path}&quot;)
<span class="line-number">103</span>
<span class="line-number">104</span>        # Verify fields
<span class="line-number">105</span>        for field in struct.fields:
<span class="line-number">106</span>            self._verify_field(file_path, f&quot;struct {struct_name}&quot;, field)
<span class="line-number">107</span>
<span class="line-number">108</span>    def _verify_enum(self, file_path: str, enum_name: str, enum: Enum) -&gt; None:
<span class="line-number">109</span>        &quot;&quot;&quot;Verify an enum definition&quot;&quot;&quot;
<span class="line-number">110</span>        if not self._is_valid_identifier(enum_name):
<span class="line-number">111</span><span class="uncovered">            self.issues.append(f&quot;Invalid enum name &#x27;{enum_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">112</span>
<span class="line-number">113</span>        if not enum.name or not enum.name.strip():
<span class="line-number">114</span><span class="uncovered">            self.issues.append(f&quot;Enum name is empty in {file_path}&quot;)</span>
<span class="line-number">115</span>
<span class="line-number">116</span>        # Verify enum values
<span class="line-number">117</span>        for enum_value in enum.values:
<span class="line-number">118</span>            if not enum_value.name or not enum_value.name.strip():
<span class="line-number">119</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">120</span>                    f&quot;Enum value name is empty in enum {enum_name} in {file_path}&quot;
<span class="line-number">121</span>                )
<span class="line-number">122</span>            elif not self._is_valid_identifier(enum_value.name):
<span class="line-number">123</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">124</span>                    f&quot;Invalid enum value name &#x27;{enum_value.name}&#x27; in enum {enum_name} in {file_path}&quot;
<span class="line-number">125</span>                )
<span class="line-number">126</span>
<span class="line-number">127</span>    def _verify_union(self, file_path: str, union_name: str, union: Union) -&gt; None:
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
<span class="line-number">129</span>        if not self._is_valid_identifier(union_name):
<span class="line-number">130</span><span class="uncovered">            self.issues.append(f&quot;Invalid union name &#x27;{union_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">131</span>
<span class="line-number">132</span>        if not union.name or not union.name.strip():
<span class="line-number">133</span><span class="uncovered">            self.issues.append(f&quot;Union name is empty in {file_path}&quot;)</span>
<span class="line-number">134</span>
<span class="line-number">135</span>        # Verify fields
<span class="line-number">136</span>        for field in union.fields:
<span class="line-number">137</span>            self._verify_field(file_path, f&quot;union {union_name}&quot;, field)
<span class="line-number">138</span>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span><span class="uncovered">            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)</span>
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">150</span>                f&quot;Function return type is empty for &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">151</span>            )
<span class="line-number">152</span>
<span class="line-number">153</span>        # Verify parameters (skip variadic parameter &#x27;...&#x27;)
<span class="line-number">154</span>        for param in function.parameters:
<span class="line-number">155</span>            if param.name == &quot;...&quot;:  # Skip variadic parameter
<span class="line-number">156</span>                continue
<span class="line-number">157</span>            self._verify_field(file_path, f&quot;function {function.name}&quot;, param)
<span class="line-number">158</span>
<span class="line-number">159</span>    def _verify_global(self, file_path: str, global_var: Field) -&gt; None:
<span class="line-number">160</span>        &quot;&quot;&quot;Verify a global variable&quot;&quot;&quot;
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _verify_project_data (lines 52-278)</h4>
<pre>
<span class="line-number"> 52</span>    def _verify_project_data(self, model: ProjectModel) -&gt; None:
<span class="line-number"> 53</span>        &quot;&quot;&quot;Verify project-level data&quot;&quot;&quot;
<span class="line-number"> 54</span>        if not model.project_name or not model.project_name.strip():
<span class="line-number"> 55</span>            self.issues.append(&quot;Project name is empty or whitespace&quot;)
<span class="line-number"> 56</span>
<span class="line-number"> 57</span>        if not model.project_root or not model.project_root.strip():
<span class="line-number"> 58</span>            self.issues.append(&quot;Project root is empty or whitespace&quot;)
<span class="line-number"> 59</span>
<span class="line-number"> 60</span>        if not model.files:
<span class="line-number"> 61</span>            self.issues.append(&quot;No files found in project&quot;)
<span class="line-number"> 62</span>
<span class="line-number"> 63</span>    def _verify_file(self, file_path: str, file_model: FileModel) -&gt; None:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Verify a single file model&quot;&quot;&quot;
<span class="line-number"> 65</span>        # Verify file-level data
<span class="line-number"> 66</span>        if not file_model.file_path or not file_model.file_path.strip():
<span class="line-number"> 67</span><span class="uncovered">            self.issues.append(f&quot;File path is empty in {file_path}&quot;)</span>
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>        if not file_model.relative_path or not file_model.relative_path.strip():
<span class="line-number"> 70</span><span class="uncovered">            self.issues.append(f&quot;Relative path is empty in {file_path}&quot;)</span>
<span class="line-number"> 71</span>
<span class="line-number"> 72</span>        # Verify structs
<span class="line-number"> 73</span>        for struct_name, struct in file_model.structs.items():
<span class="line-number"> 74</span>            self._verify_struct(file_path, struct_name, struct)
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Verify enums
<span class="line-number"> 77</span>        for enum_name, enum in file_model.enums.items():
<span class="line-number"> 78</span>            self._verify_enum(file_path, enum_name, enum)
<span class="line-number"> 79</span>
<span class="line-number"> 80</span>        # Verify unions
<span class="line-number"> 81</span>        for union_name, union in file_model.unions.items():
<span class="line-number"> 82</span>            self._verify_union(file_path, union_name, union)
<span class="line-number"> 83</span>
<span class="line-number"> 84</span>        # Verify functions
<span class="line-number"> 85</span>        for function in file_model.functions:
<span class="line-number"> 86</span>            self._verify_function(file_path, function)
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        # Verify globals
<span class="line-number"> 89</span>        for global_var in file_model.globals:
<span class="line-number"> 90</span>            self._verify_global(file_path, global_var)
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Verify aliases
<span class="line-number"> 93</span>        for alias_name, alias in file_model.aliases.items():
<span class="line-number"> 94</span>            self._verify_alias(file_path, alias_name, alias)
<span class="line-number"> 95</span>
<span class="line-number"> 96</span>    def _verify_struct(self, file_path: str, struct_name: str, struct: Struct) -&gt; None:
<span class="line-number"> 97</span>        &quot;&quot;&quot;Verify a struct definition&quot;&quot;&quot;
<span class="line-number"> 98</span>        if not self._is_valid_identifier(struct_name):
<span class="line-number"> 99</span>            self.issues.append(f&quot;Invalid struct name &#x27;{struct_name}&#x27; in {file_path}&quot;)
<span class="line-number">100</span>
<span class="line-number">101</span>        if not struct.name or not struct.name.strip():
<span class="line-number">102</span>            self.issues.append(f&quot;Struct name is empty in {file_path}&quot;)
<span class="line-number">103</span>
<span class="line-number">104</span>        # Verify fields
<span class="line-number">105</span>        for field in struct.fields:
<span class="line-number">106</span>            self._verify_field(file_path, f&quot;struct {struct_name}&quot;, field)
<span class="line-number">107</span>
<span class="line-number">108</span>    def _verify_enum(self, file_path: str, enum_name: str, enum: Enum) -&gt; None:
<span class="line-number">109</span>        &quot;&quot;&quot;Verify an enum definition&quot;&quot;&quot;
<span class="line-number">110</span>        if not self._is_valid_identifier(enum_name):
<span class="line-number">111</span><span class="uncovered">            self.issues.append(f&quot;Invalid enum name &#x27;{enum_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">112</span>
<span class="line-number">113</span>        if not enum.name or not enum.name.strip():
<span class="line-number">114</span><span class="uncovered">            self.issues.append(f&quot;Enum name is empty in {file_path}&quot;)</span>
<span class="line-number">115</span>
<span class="line-number">116</span>        # Verify enum values
<span class="line-number">117</span>        for enum_value in enum.values:
<span class="line-number">118</span>            if not enum_value.name or not enum_value.name.strip():
<span class="line-number">119</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">120</span>                    f&quot;Enum value name is empty in enum {enum_name} in {file_path}&quot;
<span class="line-number">121</span>                )
<span class="line-number">122</span>            elif not self._is_valid_identifier(enum_value.name):
<span class="line-number">123</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">124</span>                    f&quot;Invalid enum value name &#x27;{enum_value.name}&#x27; in enum {enum_name} in {file_path}&quot;
<span class="line-number">125</span>                )
<span class="line-number">126</span>
<span class="line-number">127</span>    def _verify_union(self, file_path: str, union_name: str, union: Union) -&gt; None:
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
<span class="line-number">129</span>        if not self._is_valid_identifier(union_name):
<span class="line-number">130</span><span class="uncovered">            self.issues.append(f&quot;Invalid union name &#x27;{union_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">131</span>
<span class="line-number">132</span>        if not union.name or not union.name.strip():
<span class="line-number">133</span><span class="uncovered">            self.issues.append(f&quot;Union name is empty in {file_path}&quot;)</span>
<span class="line-number">134</span>
<span class="line-number">135</span>        # Verify fields
<span class="line-number">136</span>        for field in union.fields:
<span class="line-number">137</span>            self._verify_field(file_path, f&quot;union {union_name}&quot;, field)
<span class="line-number">138</span>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span><span class="uncovered">            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)</span>
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">150</span>                f&quot;Function return type is empty for &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">151</span>            )
<span class="line-number">152</span>
<span class="line-number">153</span>        # Verify parameters (skip variadic parameter &#x27;...&#x27;)
<span class="line-number">154</span>        for param in function.parameters:
<span class="line-number">155</span>            if param.name == &quot;...&quot;:  # Skip variadic parameter
<span class="line-number">156</span>                continue
<span class="line-number">157</span>            self._verify_field(file_path, f&quot;function {function.name}&quot;, param)
<span class="line-number">158</span>
<span class="line-number">159</span>    def _verify_global(self, file_path: str, global_var: Field) -&gt; None:
<span class="line-number">160</span>        &quot;&quot;&quot;Verify a global variable&quot;&quot;&quot;
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _verify_file (lines 63-278)</h4>
<pre>
<span class="line-number"> 63</span>    def _verify_file(self, file_path: str, file_model: FileModel) -&gt; None:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Verify a single file model&quot;&quot;&quot;
<span class="line-number"> 65</span>        # Verify file-level data
<span class="line-number"> 66</span>        if not file_model.file_path or not file_model.file_path.strip():
<span class="line-number"> 67</span><span class="uncovered">            self.issues.append(f&quot;File path is empty in {file_path}&quot;)</span>
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>        if not file_model.relative_path or not file_model.relative_path.strip():
<span class="line-number"> 70</span><span class="uncovered">            self.issues.append(f&quot;Relative path is empty in {file_path}&quot;)</span>
<span class="line-number"> 71</span>
<span class="line-number"> 72</span>        # Verify structs
<span class="line-number"> 73</span>        for struct_name, struct in file_model.structs.items():
<span class="line-number"> 74</span>            self._verify_struct(file_path, struct_name, struct)
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Verify enums
<span class="line-number"> 77</span>        for enum_name, enum in file_model.enums.items():
<span class="line-number"> 78</span>            self._verify_enum(file_path, enum_name, enum)
<span class="line-number"> 79</span>
<span class="line-number"> 80</span>        # Verify unions
<span class="line-number"> 81</span>        for union_name, union in file_model.unions.items():
<span class="line-number"> 82</span>            self._verify_union(file_path, union_name, union)
<span class="line-number"> 83</span>
<span class="line-number"> 84</span>        # Verify functions
<span class="line-number"> 85</span>        for function in file_model.functions:
<span class="line-number"> 86</span>            self._verify_function(file_path, function)
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        # Verify globals
<span class="line-number"> 89</span>        for global_var in file_model.globals:
<span class="line-number"> 90</span>            self._verify_global(file_path, global_var)
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Verify aliases
<span class="line-number"> 93</span>        for alias_name, alias in file_model.aliases.items():
<span class="line-number"> 94</span>            self._verify_alias(file_path, alias_name, alias)
<span class="line-number"> 95</span>
<span class="line-number"> 96</span>    def _verify_struct(self, file_path: str, struct_name: str, struct: Struct) -&gt; None:
<span class="line-number"> 97</span>        &quot;&quot;&quot;Verify a struct definition&quot;&quot;&quot;
<span class="line-number"> 98</span>        if not self._is_valid_identifier(struct_name):
<span class="line-number"> 99</span>            self.issues.append(f&quot;Invalid struct name &#x27;{struct_name}&#x27; in {file_path}&quot;)
<span class="line-number">100</span>
<span class="line-number">101</span>        if not struct.name or not struct.name.strip():
<span class="line-number">102</span>            self.issues.append(f&quot;Struct name is empty in {file_path}&quot;)
<span class="line-number">103</span>
<span class="line-number">104</span>        # Verify fields
<span class="line-number">105</span>        for field in struct.fields:
<span class="line-number">106</span>            self._verify_field(file_path, f&quot;struct {struct_name}&quot;, field)
<span class="line-number">107</span>
<span class="line-number">108</span>    def _verify_enum(self, file_path: str, enum_name: str, enum: Enum) -&gt; None:
<span class="line-number">109</span>        &quot;&quot;&quot;Verify an enum definition&quot;&quot;&quot;
<span class="line-number">110</span>        if not self._is_valid_identifier(enum_name):
<span class="line-number">111</span><span class="uncovered">            self.issues.append(f&quot;Invalid enum name &#x27;{enum_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">112</span>
<span class="line-number">113</span>        if not enum.name or not enum.name.strip():
<span class="line-number">114</span><span class="uncovered">            self.issues.append(f&quot;Enum name is empty in {file_path}&quot;)</span>
<span class="line-number">115</span>
<span class="line-number">116</span>        # Verify enum values
<span class="line-number">117</span>        for enum_value in enum.values:
<span class="line-number">118</span>            if not enum_value.name or not enum_value.name.strip():
<span class="line-number">119</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">120</span>                    f&quot;Enum value name is empty in enum {enum_name} in {file_path}&quot;
<span class="line-number">121</span>                )
<span class="line-number">122</span>            elif not self._is_valid_identifier(enum_value.name):
<span class="line-number">123</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">124</span>                    f&quot;Invalid enum value name &#x27;{enum_value.name}&#x27; in enum {enum_name} in {file_path}&quot;
<span class="line-number">125</span>                )
<span class="line-number">126</span>
<span class="line-number">127</span>    def _verify_union(self, file_path: str, union_name: str, union: Union) -&gt; None:
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
<span class="line-number">129</span>        if not self._is_valid_identifier(union_name):
<span class="line-number">130</span><span class="uncovered">            self.issues.append(f&quot;Invalid union name &#x27;{union_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">131</span>
<span class="line-number">132</span>        if not union.name or not union.name.strip():
<span class="line-number">133</span><span class="uncovered">            self.issues.append(f&quot;Union name is empty in {file_path}&quot;)</span>
<span class="line-number">134</span>
<span class="line-number">135</span>        # Verify fields
<span class="line-number">136</span>        for field in union.fields:
<span class="line-number">137</span>            self._verify_field(file_path, f&quot;union {union_name}&quot;, field)
<span class="line-number">138</span>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span><span class="uncovered">            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)</span>
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">150</span>                f&quot;Function return type is empty for &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">151</span>            )
<span class="line-number">152</span>
<span class="line-number">153</span>        # Verify parameters (skip variadic parameter &#x27;...&#x27;)
<span class="line-number">154</span>        for param in function.parameters:
<span class="line-number">155</span>            if param.name == &quot;...&quot;:  # Skip variadic parameter
<span class="line-number">156</span>                continue
<span class="line-number">157</span>            self._verify_field(file_path, f&quot;function {function.name}&quot;, param)
<span class="line-number">158</span>
<span class="line-number">159</span>    def _verify_global(self, file_path: str, global_var: Field) -&gt; None:
<span class="line-number">160</span>        &quot;&quot;&quot;Verify a global variable&quot;&quot;&quot;
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _verify_struct (lines 96-278)</h4>
<pre>
<span class="line-number"> 96</span>    def _verify_struct(self, file_path: str, struct_name: str, struct: Struct) -&gt; None:
<span class="line-number"> 97</span>        &quot;&quot;&quot;Verify a struct definition&quot;&quot;&quot;
<span class="line-number"> 98</span>        if not self._is_valid_identifier(struct_name):
<span class="line-number"> 99</span>            self.issues.append(f&quot;Invalid struct name &#x27;{struct_name}&#x27; in {file_path}&quot;)
<span class="line-number">100</span>
<span class="line-number">101</span>        if not struct.name or not struct.name.strip():
<span class="line-number">102</span>            self.issues.append(f&quot;Struct name is empty in {file_path}&quot;)
<span class="line-number">103</span>
<span class="line-number">104</span>        # Verify fields
<span class="line-number">105</span>        for field in struct.fields:
<span class="line-number">106</span>            self._verify_field(file_path, f&quot;struct {struct_name}&quot;, field)
<span class="line-number">107</span>
<span class="line-number">108</span>    def _verify_enum(self, file_path: str, enum_name: str, enum: Enum) -&gt; None:
<span class="line-number">109</span>        &quot;&quot;&quot;Verify an enum definition&quot;&quot;&quot;
<span class="line-number">110</span>        if not self._is_valid_identifier(enum_name):
<span class="line-number">111</span><span class="uncovered">            self.issues.append(f&quot;Invalid enum name &#x27;{enum_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">112</span>
<span class="line-number">113</span>        if not enum.name or not enum.name.strip():
<span class="line-number">114</span><span class="uncovered">            self.issues.append(f&quot;Enum name is empty in {file_path}&quot;)</span>
<span class="line-number">115</span>
<span class="line-number">116</span>        # Verify enum values
<span class="line-number">117</span>        for enum_value in enum.values:
<span class="line-number">118</span>            if not enum_value.name or not enum_value.name.strip():
<span class="line-number">119</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">120</span>                    f&quot;Enum value name is empty in enum {enum_name} in {file_path}&quot;
<span class="line-number">121</span>                )
<span class="line-number">122</span>            elif not self._is_valid_identifier(enum_value.name):
<span class="line-number">123</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">124</span>                    f&quot;Invalid enum value name &#x27;{enum_value.name}&#x27; in enum {enum_name} in {file_path}&quot;
<span class="line-number">125</span>                )
<span class="line-number">126</span>
<span class="line-number">127</span>    def _verify_union(self, file_path: str, union_name: str, union: Union) -&gt; None:
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
<span class="line-number">129</span>        if not self._is_valid_identifier(union_name):
<span class="line-number">130</span><span class="uncovered">            self.issues.append(f&quot;Invalid union name &#x27;{union_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">131</span>
<span class="line-number">132</span>        if not union.name or not union.name.strip():
<span class="line-number">133</span><span class="uncovered">            self.issues.append(f&quot;Union name is empty in {file_path}&quot;)</span>
<span class="line-number">134</span>
<span class="line-number">135</span>        # Verify fields
<span class="line-number">136</span>        for field in union.fields:
<span class="line-number">137</span>            self._verify_field(file_path, f&quot;union {union_name}&quot;, field)
<span class="line-number">138</span>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span><span class="uncovered">            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)</span>
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">150</span>                f&quot;Function return type is empty for &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">151</span>            )
<span class="line-number">152</span>
<span class="line-number">153</span>        # Verify parameters (skip variadic parameter &#x27;...&#x27;)
<span class="line-number">154</span>        for param in function.parameters:
<span class="line-number">155</span>            if param.name == &quot;...&quot;:  # Skip variadic parameter
<span class="line-number">156</span>                continue
<span class="line-number">157</span>            self._verify_field(file_path, f&quot;function {function.name}&quot;, param)
<span class="line-number">158</span>
<span class="line-number">159</span>    def _verify_global(self, file_path: str, global_var: Field) -&gt; None:
<span class="line-number">160</span>        &quot;&quot;&quot;Verify a global variable&quot;&quot;&quot;
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _verify_enum (lines 108-278)</h4>
<pre>
<span class="line-number">108</span>    def _verify_enum(self, file_path: str, enum_name: str, enum: Enum) -&gt; None:
<span class="line-number">109</span>        &quot;&quot;&quot;Verify an enum definition&quot;&quot;&quot;
<span class="line-number">110</span>        if not self._is_valid_identifier(enum_name):
<span class="line-number">111</span><span class="uncovered">            self.issues.append(f&quot;Invalid enum name &#x27;{enum_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">112</span>
<span class="line-number">113</span>        if not enum.name or not enum.name.strip():
<span class="line-number">114</span><span class="uncovered">            self.issues.append(f&quot;Enum name is empty in {file_path}&quot;)</span>
<span class="line-number">115</span>
<span class="line-number">116</span>        # Verify enum values
<span class="line-number">117</span>        for enum_value in enum.values:
<span class="line-number">118</span>            if not enum_value.name or not enum_value.name.strip():
<span class="line-number">119</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">120</span>                    f&quot;Enum value name is empty in enum {enum_name} in {file_path}&quot;
<span class="line-number">121</span>                )
<span class="line-number">122</span>            elif not self._is_valid_identifier(enum_value.name):
<span class="line-number">123</span><span class="uncovered">                self.issues.append(</span>
<span class="line-number">124</span>                    f&quot;Invalid enum value name &#x27;{enum_value.name}&#x27; in enum {enum_name} in {file_path}&quot;
<span class="line-number">125</span>                )
<span class="line-number">126</span>
<span class="line-number">127</span>    def _verify_union(self, file_path: str, union_name: str, union: Union) -&gt; None:
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
<span class="line-number">129</span>        if not self._is_valid_identifier(union_name):
<span class="line-number">130</span><span class="uncovered">            self.issues.append(f&quot;Invalid union name &#x27;{union_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">131</span>
<span class="line-number">132</span>        if not union.name or not union.name.strip():
<span class="line-number">133</span><span class="uncovered">            self.issues.append(f&quot;Union name is empty in {file_path}&quot;)</span>
<span class="line-number">134</span>
<span class="line-number">135</span>        # Verify fields
<span class="line-number">136</span>        for field in union.fields:
<span class="line-number">137</span>            self._verify_field(file_path, f&quot;union {union_name}&quot;, field)
<span class="line-number">138</span>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span><span class="uncovered">            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)</span>
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">150</span>                f&quot;Function return type is empty for &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">151</span>            )
<span class="line-number">152</span>
<span class="line-number">153</span>        # Verify parameters (skip variadic parameter &#x27;...&#x27;)
<span class="line-number">154</span>        for param in function.parameters:
<span class="line-number">155</span>            if param.name == &quot;...&quot;:  # Skip variadic parameter
<span class="line-number">156</span>                continue
<span class="line-number">157</span>            self._verify_field(file_path, f&quot;function {function.name}&quot;, param)
<span class="line-number">158</span>
<span class="line-number">159</span>    def _verify_global(self, file_path: str, global_var: Field) -&gt; None:
<span class="line-number">160</span>        &quot;&quot;&quot;Verify a global variable&quot;&quot;&quot;
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _verify_union (lines 127-278)</h4>
<pre>
<span class="line-number">127</span>    def _verify_union(self, file_path: str, union_name: str, union: Union) -&gt; None:
<span class="line-number">128</span>        &quot;&quot;&quot;Verify a union definition&quot;&quot;&quot;
<span class="line-number">129</span>        if not self._is_valid_identifier(union_name):
<span class="line-number">130</span><span class="uncovered">            self.issues.append(f&quot;Invalid union name &#x27;{union_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">131</span>
<span class="line-number">132</span>        if not union.name or not union.name.strip():
<span class="line-number">133</span><span class="uncovered">            self.issues.append(f&quot;Union name is empty in {file_path}&quot;)</span>
<span class="line-number">134</span>
<span class="line-number">135</span>        # Verify fields
<span class="line-number">136</span>        for field in union.fields:
<span class="line-number">137</span>            self._verify_field(file_path, f&quot;union {union_name}&quot;, field)
<span class="line-number">138</span>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span><span class="uncovered">            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)</span>
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">150</span>                f&quot;Function return type is empty for &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">151</span>            )
<span class="line-number">152</span>
<span class="line-number">153</span>        # Verify parameters (skip variadic parameter &#x27;...&#x27;)
<span class="line-number">154</span>        for param in function.parameters:
<span class="line-number">155</span>            if param.name == &quot;...&quot;:  # Skip variadic parameter
<span class="line-number">156</span>                continue
<span class="line-number">157</span>            self._verify_field(file_path, f&quot;function {function.name}&quot;, param)
<span class="line-number">158</span>
<span class="line-number">159</span>    def _verify_global(self, file_path: str, global_var: Field) -&gt; None:
<span class="line-number">160</span>        &quot;&quot;&quot;Verify a global variable&quot;&quot;&quot;
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _verify_function (lines 139-278)</h4>
<pre>
<span class="line-number">139</span>    def _verify_function(self, file_path: str, function: Function) -&gt; None:
<span class="line-number">140</span>        &quot;&quot;&quot;Verify a function definition&quot;&quot;&quot;
<span class="line-number">141</span>        if not function.name or not function.name.strip():
<span class="line-number">142</span><span class="uncovered">            self.issues.append(f&quot;Function name is empty in {file_path}&quot;)</span>
<span class="line-number">143</span>        elif not self._is_valid_identifier(function.name):
<span class="line-number">144</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">145</span>                f&quot;Invalid function name &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">146</span>            )
<span class="line-number">147</span>
<span class="line-number">148</span>        if not function.return_type or not function.return_type.strip():
<span class="line-number">149</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">150</span>                f&quot;Function return type is empty for &#x27;{function.name}&#x27; in {file_path}&quot;
<span class="line-number">151</span>            )
<span class="line-number">152</span>
<span class="line-number">153</span>        # Verify parameters (skip variadic parameter &#x27;...&#x27;)
<span class="line-number">154</span>        for param in function.parameters:
<span class="line-number">155</span>            if param.name == &quot;...&quot;:  # Skip variadic parameter
<span class="line-number">156</span>                continue
<span class="line-number">157</span>            self._verify_field(file_path, f&quot;function {function.name}&quot;, param)
<span class="line-number">158</span>
<span class="line-number">159</span>    def _verify_global(self, file_path: str, global_var: Field) -&gt; None:
<span class="line-number">160</span>        &quot;&quot;&quot;Verify a global variable&quot;&quot;&quot;
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _verify_global (lines 159-278)</h4>
<pre>
<span class="line-number">159</span>    def _verify_global(self, file_path: str, global_var: Field) -&gt; None:
<span class="line-number">160</span>        &quot;&quot;&quot;Verify a global variable&quot;&quot;&quot;
<span class="line-number">161</span>        self._verify_field(file_path, &quot;global&quot;, global_var)
<span class="line-number">162</span>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _verify_alias (lines 163-278)</h4>
<pre>
<span class="line-number">163</span>    def _verify_alias(self, file_path: str, alias_name: str, alias: Alias) -&gt; None:
<span class="line-number">164</span>        &quot;&quot;&quot;Verify a type alias (typedef)&quot;&quot;&quot;
<span class="line-number">165</span>        if not self._is_valid_identifier(alias_name):
<span class="line-number">166</span><span class="uncovered">            self.issues.append(f&quot;Invalid alias name &#x27;{alias_name}&#x27; in {file_path}&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>        if not alias.name or not alias.name.strip():
<span class="line-number">169</span><span class="uncovered">            self.issues.append(f&quot;Alias name is empty in {file_path}&quot;)</span>
<span class="line-number">170</span>
<span class="line-number">171</span>        if not alias.original_type or not alias.original_type.strip():
<span class="line-number">172</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">173</span>                f&quot;Alias original type is empty for &#x27;{alias_name}&#x27; in {file_path}&quot;
<span class="line-number">174</span>            )
<span class="line-number">175</span>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _verify_field (lines 176-278)</h4>
<pre>
<span class="line-number">176</span>    def _verify_field(self, file_path: str, context: str, field: Field) -&gt; None:
<span class="line-number">177</span>        &quot;&quot;&quot;Verify a field (struct field, function parameter, global variable)&quot;&quot;&quot;
<span class="line-number">178</span>        # Check for invalid names
<span class="line-number">179</span>        if not field.name or not field.name.strip():
<span class="line-number">180</span><span class="uncovered">            self.issues.append(f&quot;Field name is empty in {context} in {file_path}&quot;)</span>
<span class="line-number">181</span>        elif not self._is_valid_identifier(field.name):
<span class="line-number">182</span>            self.issues.append(
<span class="line-number">183</span>                f&quot;Invalid field name &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">184</span>            )
<span class="line-number">185</span>
<span class="line-number">186</span>        # Check for invalid types
<span class="line-number">187</span>        if not field.type or not field.type.strip():
<span class="line-number">188</span><span class="uncovered">            self.issues.append(</span>
<span class="line-number">189</span>                f&quot;Field type is empty for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">190</span>            )
<span class="line-number">191</span>        elif self._is_suspicious_type(field.type):
<span class="line-number">192</span>            self.issues.append(
<span class="line-number">193</span>                f&quot;Suspicious field type &#x27;{field.type}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">194</span>            )
<span class="line-number">195</span>
<span class="line-number">196</span>        # Check for suspicious values
<span class="line-number">197</span>        if field.value and self._is_suspicious_value(field.value):
<span class="line-number">198</span>            self.issues.append(
<span class="line-number">199</span>                f&quot;Suspicious field value &#x27;{field.value}&#x27; for &#x27;{field.name}&#x27; in {context} in {file_path}&quot;
<span class="line-number">200</span>            )
<span class="line-number">201</span>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _is_valid_identifier (lines 202-278)</h4>
<pre>
<span class="line-number">202</span>    def _is_valid_identifier(self, name: str) -&gt; bool:
<span class="line-number">203</span>        &quot;&quot;&quot;Check if a name is a valid C identifier&quot;&quot;&quot;
<span class="line-number">204</span>        if not name or not name.strip():
<span class="line-number">205</span>            return False
<span class="line-number">206</span>
<span class="line-number">207</span>        # C identifier rules: start with letter or underscore, then letters, digits, or underscores
<span class="line-number">208</span>        return bool(re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, name.strip()))
<span class="line-number">209</span>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _is_suspicious_type (lines 210-278)</h4>
<pre>
<span class="line-number">210</span>    def _is_suspicious_type(self, type_str: str) -&gt; bool:
<span class="line-number">211</span>        &quot;&quot;&quot;Check if a type string looks suspicious&quot;&quot;&quot;
<span class="line-number">212</span>        if not type_str or not type_str.strip():
<span class="line-number">213</span><span class="uncovered">            return True</span>
<span class="line-number">214</span>
<span class="line-number">215</span>        type_str = type_str.strip()
<span class="line-number">216</span>
<span class="line-number">217</span>        # Check for obvious parsing errors
<span class="line-number">218</span>        suspicious_patterns = [
<span class="line-number">219</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">220</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">221</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # All brackets and whitespace
<span class="line-number">222</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]*$&quot;,  # Excessive brackets/whitespace
<span class="line-number">223</span>        ]
<span class="line-number">224</span>
<span class="line-number">225</span>        for pattern in suspicious_patterns:
<span class="line-number">226</span>            if re.match(pattern, type_str):
<span class="line-number">227</span><span class="uncovered">                return True</span>
<span class="line-number">228</span>
<span class="line-number">229</span>        # Check for unbalanced brackets
<span class="line-number">230</span>        if self._has_unbalanced_brackets(type_str):
<span class="line-number">231</span>            return True
<span class="line-number">232</span>
<span class="line-number">233</span>        # Check for excessive newlines or backslashes
<span class="line-number">234</span>        if type_str.count(&quot;\n&quot;) &gt; 5 or type_str.count(&quot;\\&quot;) &gt; 10:
<span class="line-number">235</span><span class="uncovered">            return True</span>
<span class="line-number">236</span>
<span class="line-number">237</span>        return False
<span class="line-number">238</span>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
<h4>Function: _is_suspicious_value (lines 239-278)</h4>
<pre>
<span class="line-number">239</span>    def _is_suspicious_value(self, value: str) -&gt; bool:
<span class="line-number">240</span>        &quot;&quot;&quot;Check if a value string looks suspicious&quot;&quot;&quot;
<span class="line-number">241</span>        if not value or not value.strip():
<span class="line-number">242</span><span class="uncovered">            return True</span>
<span class="line-number">243</span>
<span class="line-number">244</span>        value = value.strip()
<span class="line-number">245</span>
<span class="line-number">246</span>        # Check for obvious parsing errors
<span class="line-number">247</span>        suspicious_patterns = [
<span class="line-number">248</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Only brackets, spaces, backslashes, newlines
<span class="line-number">249</span>            r&quot;^[\[\]\{\}\(\)\s\\\n]*[\[\]\{\}\(\)\s\\\n]+$&quot;,  # Mostly brackets and whitespace
<span class="line-number">250</span>        ]
<span class="line-number">251</span>
<span class="line-number">252</span>        for pattern in suspicious_patterns:
<span class="line-number">253</span>            if re.match(pattern, value):
<span class="line-number">254</span><span class="uncovered">                return True</span>
<span class="line-number">255</span>
<span class="line-number">256</span>        # Check for unbalanced brackets
<span class="line-number">257</span>        if self._has_unbalanced_brackets(value):
<span class="line-number">258</span>            return True
<span class="line-number">259</span>
<span class="line-number">260</span>        # Check for excessive newlines or backslashes
<span class="line-number">261</span>        if value.count(&quot;\n&quot;) &gt; 3 or value.count(&quot;\\&quot;) &gt; 5:
<span class="line-number">262</span><span class="uncovered">            return True</span>
<span class="line-number">263</span>
<span class="line-number">264</span>        return False
<span class="line-number">265</span>
<span class="line-number">266</span>    def _has_unbalanced_brackets(self, text: str) -&gt; bool:
<span class="line-number">267</span>        &quot;&quot;&quot;Check if text has unbalanced brackets&quot;&quot;&quot;
<span class="line-number">268</span>        stack = []
<span class="line-number">269</span>        bracket_pairs = {&quot;)&quot;: &quot;(&quot;, &quot;]&quot;: &quot;[&quot;, &quot;}&quot;: &quot;{&quot;}
<span class="line-number">270</span>
<span class="line-number">271</span>        for char in text:
<span class="line-number">272</span>            if char in &quot;([{&quot;:
<span class="line-number">273</span>                stack.append(char)
<span class="line-number">274</span>            elif char in &quot;)]}&quot;:
<span class="line-number">275</span>                if not stack or stack.pop() != bracket_pairs[char]:
<span class="line-number">276</span>                    return True
<span class="line-number">277</span>
<span class="line-number">278</span>        return len(stack) &gt; 0  # Unclosed brackets
</pre>
</div>
<div class="file-section">
<div class="file-header">
/home/runner/work/generator_project/generator_project/c_to_plantuml/utils.py - 61.19% coverage (41/67 lines)
</div>
<h4>Function: detect_file_encoding (lines 18-189)</h4>
<pre>
<span class="line-number"> 18</span>def detect_file_encoding(file_path: Path) -&gt; str:
<span class="line-number"> 19</span>    &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number"> 20</span>    try:
<span class="line-number"> 21</span>        if CHARDET_AVAILABLE:
<span class="line-number"> 22</span>            # Try to detect encoding with chardet
<span class="line-number"> 23</span><span class="uncovered">            with open(file_path, &quot;rb&quot;) as f:</span>
<span class="line-number"> 24</span><span class="uncovered">                raw_data = f.read(1024)  # Read first 1KB for detection</span>
<span class="line-number"> 25</span><span class="uncovered">                if raw_data:</span>
<span class="line-number"> 26</span><span class="uncovered">                    result = chardet.detect(raw_data)</span>
<span class="line-number"> 27</span><span class="uncovered">                    if result and result[&quot;confidence&quot;] &gt; 0.7:</span>
<span class="line-number"> 28</span><span class="uncovered">                        return result[&quot;encoding&quot;]</span>
<span class="line-number"> 29</span>
<span class="line-number"> 30</span>        # Fallback encodings in order of preference
<span class="line-number"> 31</span>        fallback_encodings = [&quot;utf-8&quot;, &quot;latin-1&quot;, &quot;cp1252&quot;, &quot;iso-8859-1&quot;]
<span class="line-number"> 32</span>
<span class="line-number"> 33</span>        for encoding in fallback_encodings:
<span class="line-number"> 34</span>            try:
<span class="line-number"> 35</span>                with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number"> 36</span>                    f.read(1024)  # Test read
<span class="line-number"> 37</span>                return encoding
<span class="line-number"> 38</span>            except (UnicodeDecodeError, UnicodeError):
<span class="line-number"> 39</span><span class="uncovered">                continue</span>
<span class="line-number"> 40</span>
<span class="line-number"> 41</span>        # Final fallback
<span class="line-number"> 42</span><span class="uncovered">        return &quot;utf-8&quot;</span>
<span class="line-number"> 43</span>
<span class="line-number"> 44</span>    except Exception as e:
<span class="line-number"> 45</span>        logging.warning(f&quot;Failed to detect encoding for {file_path}: {e}&quot;)
<span class="line-number"> 46</span>        return &quot;utf-8&quot;
<span class="line-number"> 47</span>
<span class="line-number"> 48</span>
<span class="line-number"> 49</span>def get_filename_from_path(file_path: str) -&gt; str:
<span class="line-number"> 50</span>    &quot;&quot;&quot;Extract filename from a file path (handles both absolute and relative paths)&quot;&quot;&quot;
<span class="line-number"> 51</span><span class="uncovered">    return Path(file_path).name</span>
<span class="line-number"> 52</span>
<span class="line-number"> 53</span>
<span class="line-number"> 54</span>def find_file_by_filename(filename: str, file_dict: Dict[str, any]) -&gt; Optional[str]:
<span class="line-number"> 55</span>    &quot;&quot;&quot;
<span class="line-number"> 56</span>    Find a file in a dictionary by matching its filename.
<span class="line-number"> 57</span>
<span class="line-number"> 58</span>    Args:
<span class="line-number"> 59</span>        filename: The filename to search for (e.g., &quot;header.h&quot;)
<span class="line-number"> 60</span>        file_dict: Dictionary with file paths as keys
<span class="line-number"> 61</span>
<span class="line-number"> 62</span>    Returns:
<span class="line-number"> 63</span>        The matching file path key, or None if not found
<span class="line-number"> 64</span>    &quot;&quot;&quot;
<span class="line-number"> 65</span>    # First try exact match
<span class="line-number"> 66</span><span class="uncovered">    if filename in file_dict:</span>
<span class="line-number"> 67</span><span class="uncovered">        return filename</span>
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>    # Try matching by filename
<span class="line-number"> 70</span><span class="uncovered">    for file_path in file_dict.keys():</span>
<span class="line-number"> 71</span><span class="uncovered">        if Path(file_path).name == filename:</span>
<span class="line-number"> 72</span><span class="uncovered">            return file_path</span>
<span class="line-number"> 73</span>
<span class="line-number"> 74</span><span class="uncovered">    return None</span>
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>
<span class="line-number"> 77</span>def normalize_file_path(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number"> 78</span>    &quot;&quot;&quot;
<span class="line-number"> 79</span>    Normalize file path for consistent handling.
<span class="line-number"> 80</span>    For tracking purposes, we prefer relative paths when possible.
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>    Args:
<span class="line-number"> 83</span>        file_path: The file path to normalize
<span class="line-number"> 84</span>        project_root: Optional project root for relative path conversion
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>    Returns:
<span class="line-number"> 87</span>        Normalized file path
<span class="line-number"> 88</span>    &quot;&quot;&quot;
<span class="line-number"> 89</span><span class="uncovered">    path_obj = Path(file_path)</span>
<span class="line-number"> 90</span>
<span class="line-number"> 91</span>    # If we have a project root and the path is absolute, try to make it relative
<span class="line-number"> 92</span><span class="uncovered">    if project_root and path_obj.is_absolute():</span>
<span class="line-number"> 93</span><span class="uncovered">        try:</span>
<span class="line-number"> 94</span><span class="uncovered">            relative_path = path_obj.relative_to(Path(project_root))</span>
<span class="line-number"> 95</span><span class="uncovered">            return str(relative_path)</span>
<span class="line-number"> 96</span><span class="uncovered">        except ValueError:</span>
<span class="line-number"> 97</span>            # Path is not relative to project root, keep as is
<span class="line-number"> 98</span><span class="uncovered">            pass</span>
<span class="line-number"> 99</span>
<span class="line-number">100</span><span class="uncovered">    return str(path_obj)</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>def create_file_key(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number">104</span>    &quot;&quot;&quot;
<span class="line-number">105</span>    Create a consistent file key for tracking.
<span class="line-number">106</span>    Uses filename for uniqueness since filenames are unique in the project.
<span class="line-number">107</span>
<span class="line-number">108</span>    Args:
<span class="line-number">109</span>        file_path: The file path
<span class="line-number">110</span>        project_root: Optional project root for normalization
<span class="line-number">111</span>
<span class="line-number">112</span>    Returns:
<span class="line-number">113</span>        A consistent file key (filename)
<span class="line-number">114</span>    &quot;&quot;&quot;
<span class="line-number">115</span><span class="uncovered">    return get_filename_from_path(file_path)</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span># Backward compatibility functions for existing tests
<span class="line-number">119</span>def get_acceptable_encodings() -&gt; list:
<span class="line-number">120</span>    &quot;&quot;&quot;
<span class="line-number">121</span>    Get a list of acceptable encodings for cross-platform compatibility.
<span class="line-number">122</span>
<span class="line-number">123</span>    Returns:
<span class="line-number">124</span>        List of encoding names that are considered acceptable across platforms.
<span class="line-number">125</span>    &quot;&quot;&quot;
<span class="line-number">126</span>    return [
<span class="line-number">127</span>        &quot;utf-8&quot;,
<span class="line-number">128</span>        &quot;utf-8-sig&quot;,
<span class="line-number">129</span>        &quot;utf-16&quot;,
<span class="line-number">130</span>        &quot;utf-16le&quot;,
<span class="line-number">131</span>        &quot;utf-16be&quot;,
<span class="line-number">132</span>        &quot;windows-1252&quot;,
<span class="line-number">133</span>        &quot;windows-1254&quot;,
<span class="line-number">134</span>        &quot;cp1252&quot;,
<span class="line-number">135</span>        &quot;cp1254&quot;,
<span class="line-number">136</span>        &quot;iso-8859-1&quot;,
<span class="line-number">137</span>        &quot;latin-1&quot;,
<span class="line-number">138</span>        &quot;ascii&quot;,
<span class="line-number">139</span>    ]
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>def is_acceptable_encoding(encoding: str) -&gt; bool:
<span class="line-number">143</span>    &quot;&quot;&quot;
<span class="line-number">144</span>    Check if an encoding is acceptable for cross-platform compatibility.
<span class="line-number">145</span>
<span class="line-number">146</span>    Args:
<span class="line-number">147</span>        encoding: The encoding name to check.
<span class="line-number">148</span>
<span class="line-number">149</span>    Returns:
<span class="line-number">150</span>        True if the encoding is acceptable, False otherwise.
<span class="line-number">151</span>    &quot;&quot;&quot;
<span class="line-number">152</span>    return encoding.lower() in [enc.lower() for enc in get_acceptable_encodings()]
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>def normalize_encoding(encoding: str) -&gt; str:
<span class="line-number">156</span>    &quot;&quot;&quot;
<span class="line-number">157</span>    Normalize encoding name for consistency across platforms.
<span class="line-number">158</span>
<span class="line-number">159</span>    Args:
<span class="line-number">160</span>        encoding: The encoding name to normalize.
<span class="line-number">161</span>
<span class="line-number">162</span>    Returns:
<span class="line-number">163</span>        Normalized encoding name.
<span class="line-number">164</span>    &quot;&quot;&quot;
<span class="line-number">165</span>    encoding_lower = encoding.lower()
<span class="line-number">166</span>
<span class="line-number">167</span>    # Normalize common Windows encodings
<span class="line-number">168</span>    if encoding_lower in [&quot;windows-1252&quot;, &quot;cp1252&quot;]:
<span class="line-number">169</span>        return &quot;windows-1252&quot;
<span class="line-number">170</span>    elif encoding_lower in [&quot;windows-1254&quot;, &quot;cp1254&quot;]:
<span class="line-number">171</span>        return &quot;windows-1254&quot;
<span class="line-number">172</span>    elif encoding_lower in [&quot;iso-8859-1&quot;, &quot;latin-1&quot;]:
<span class="line-number">173</span>        return &quot;iso-8859-1&quot;
<span class="line-number">174</span>
<span class="line-number">175</span>    return encoding_lower
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>def get_platform_default_encoding() -&gt; str:
<span class="line-number">179</span>    &quot;&quot;&quot;
<span class="line-number">180</span>    Get the default encoding for the current platform.
<span class="line-number">181</span>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
<h4>Function: get_filename_from_path (lines 49-189)</h4>
<pre>
<span class="line-number"> 49</span>def get_filename_from_path(file_path: str) -&gt; str:
<span class="line-number"> 50</span>    &quot;&quot;&quot;Extract filename from a file path (handles both absolute and relative paths)&quot;&quot;&quot;
<span class="line-number"> 51</span><span class="uncovered">    return Path(file_path).name</span>
<span class="line-number"> 52</span>
<span class="line-number"> 53</span>
<span class="line-number"> 54</span>def find_file_by_filename(filename: str, file_dict: Dict[str, any]) -&gt; Optional[str]:
<span class="line-number"> 55</span>    &quot;&quot;&quot;
<span class="line-number"> 56</span>    Find a file in a dictionary by matching its filename.
<span class="line-number"> 57</span>
<span class="line-number"> 58</span>    Args:
<span class="line-number"> 59</span>        filename: The filename to search for (e.g., &quot;header.h&quot;)
<span class="line-number"> 60</span>        file_dict: Dictionary with file paths as keys
<span class="line-number"> 61</span>
<span class="line-number"> 62</span>    Returns:
<span class="line-number"> 63</span>        The matching file path key, or None if not found
<span class="line-number"> 64</span>    &quot;&quot;&quot;
<span class="line-number"> 65</span>    # First try exact match
<span class="line-number"> 66</span><span class="uncovered">    if filename in file_dict:</span>
<span class="line-number"> 67</span><span class="uncovered">        return filename</span>
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>    # Try matching by filename
<span class="line-number"> 70</span><span class="uncovered">    for file_path in file_dict.keys():</span>
<span class="line-number"> 71</span><span class="uncovered">        if Path(file_path).name == filename:</span>
<span class="line-number"> 72</span><span class="uncovered">            return file_path</span>
<span class="line-number"> 73</span>
<span class="line-number"> 74</span><span class="uncovered">    return None</span>
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>
<span class="line-number"> 77</span>def normalize_file_path(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number"> 78</span>    &quot;&quot;&quot;
<span class="line-number"> 79</span>    Normalize file path for consistent handling.
<span class="line-number"> 80</span>    For tracking purposes, we prefer relative paths when possible.
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>    Args:
<span class="line-number"> 83</span>        file_path: The file path to normalize
<span class="line-number"> 84</span>        project_root: Optional project root for relative path conversion
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>    Returns:
<span class="line-number"> 87</span>        Normalized file path
<span class="line-number"> 88</span>    &quot;&quot;&quot;
<span class="line-number"> 89</span><span class="uncovered">    path_obj = Path(file_path)</span>
<span class="line-number"> 90</span>
<span class="line-number"> 91</span>    # If we have a project root and the path is absolute, try to make it relative
<span class="line-number"> 92</span><span class="uncovered">    if project_root and path_obj.is_absolute():</span>
<span class="line-number"> 93</span><span class="uncovered">        try:</span>
<span class="line-number"> 94</span><span class="uncovered">            relative_path = path_obj.relative_to(Path(project_root))</span>
<span class="line-number"> 95</span><span class="uncovered">            return str(relative_path)</span>
<span class="line-number"> 96</span><span class="uncovered">        except ValueError:</span>
<span class="line-number"> 97</span>            # Path is not relative to project root, keep as is
<span class="line-number"> 98</span><span class="uncovered">            pass</span>
<span class="line-number"> 99</span>
<span class="line-number">100</span><span class="uncovered">    return str(path_obj)</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>def create_file_key(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number">104</span>    &quot;&quot;&quot;
<span class="line-number">105</span>    Create a consistent file key for tracking.
<span class="line-number">106</span>    Uses filename for uniqueness since filenames are unique in the project.
<span class="line-number">107</span>
<span class="line-number">108</span>    Args:
<span class="line-number">109</span>        file_path: The file path
<span class="line-number">110</span>        project_root: Optional project root for normalization
<span class="line-number">111</span>
<span class="line-number">112</span>    Returns:
<span class="line-number">113</span>        A consistent file key (filename)
<span class="line-number">114</span>    &quot;&quot;&quot;
<span class="line-number">115</span><span class="uncovered">    return get_filename_from_path(file_path)</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span># Backward compatibility functions for existing tests
<span class="line-number">119</span>def get_acceptable_encodings() -&gt; list:
<span class="line-number">120</span>    &quot;&quot;&quot;
<span class="line-number">121</span>    Get a list of acceptable encodings for cross-platform compatibility.
<span class="line-number">122</span>
<span class="line-number">123</span>    Returns:
<span class="line-number">124</span>        List of encoding names that are considered acceptable across platforms.
<span class="line-number">125</span>    &quot;&quot;&quot;
<span class="line-number">126</span>    return [
<span class="line-number">127</span>        &quot;utf-8&quot;,
<span class="line-number">128</span>        &quot;utf-8-sig&quot;,
<span class="line-number">129</span>        &quot;utf-16&quot;,
<span class="line-number">130</span>        &quot;utf-16le&quot;,
<span class="line-number">131</span>        &quot;utf-16be&quot;,
<span class="line-number">132</span>        &quot;windows-1252&quot;,
<span class="line-number">133</span>        &quot;windows-1254&quot;,
<span class="line-number">134</span>        &quot;cp1252&quot;,
<span class="line-number">135</span>        &quot;cp1254&quot;,
<span class="line-number">136</span>        &quot;iso-8859-1&quot;,
<span class="line-number">137</span>        &quot;latin-1&quot;,
<span class="line-number">138</span>        &quot;ascii&quot;,
<span class="line-number">139</span>    ]
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>def is_acceptable_encoding(encoding: str) -&gt; bool:
<span class="line-number">143</span>    &quot;&quot;&quot;
<span class="line-number">144</span>    Check if an encoding is acceptable for cross-platform compatibility.
<span class="line-number">145</span>
<span class="line-number">146</span>    Args:
<span class="line-number">147</span>        encoding: The encoding name to check.
<span class="line-number">148</span>
<span class="line-number">149</span>    Returns:
<span class="line-number">150</span>        True if the encoding is acceptable, False otherwise.
<span class="line-number">151</span>    &quot;&quot;&quot;
<span class="line-number">152</span>    return encoding.lower() in [enc.lower() for enc in get_acceptable_encodings()]
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>def normalize_encoding(encoding: str) -&gt; str:
<span class="line-number">156</span>    &quot;&quot;&quot;
<span class="line-number">157</span>    Normalize encoding name for consistency across platforms.
<span class="line-number">158</span>
<span class="line-number">159</span>    Args:
<span class="line-number">160</span>        encoding: The encoding name to normalize.
<span class="line-number">161</span>
<span class="line-number">162</span>    Returns:
<span class="line-number">163</span>        Normalized encoding name.
<span class="line-number">164</span>    &quot;&quot;&quot;
<span class="line-number">165</span>    encoding_lower = encoding.lower()
<span class="line-number">166</span>
<span class="line-number">167</span>    # Normalize common Windows encodings
<span class="line-number">168</span>    if encoding_lower in [&quot;windows-1252&quot;, &quot;cp1252&quot;]:
<span class="line-number">169</span>        return &quot;windows-1252&quot;
<span class="line-number">170</span>    elif encoding_lower in [&quot;windows-1254&quot;, &quot;cp1254&quot;]:
<span class="line-number">171</span>        return &quot;windows-1254&quot;
<span class="line-number">172</span>    elif encoding_lower in [&quot;iso-8859-1&quot;, &quot;latin-1&quot;]:
<span class="line-number">173</span>        return &quot;iso-8859-1&quot;
<span class="line-number">174</span>
<span class="line-number">175</span>    return encoding_lower
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>def get_platform_default_encoding() -&gt; str:
<span class="line-number">179</span>    &quot;&quot;&quot;
<span class="line-number">180</span>    Get the default encoding for the current platform.
<span class="line-number">181</span>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
<h4>Function: find_file_by_filename (lines 54-189)</h4>
<pre>
<span class="line-number"> 54</span>def find_file_by_filename(filename: str, file_dict: Dict[str, any]) -&gt; Optional[str]:
<span class="line-number"> 55</span>    &quot;&quot;&quot;
<span class="line-number"> 56</span>    Find a file in a dictionary by matching its filename.
<span class="line-number"> 57</span>
<span class="line-number"> 58</span>    Args:
<span class="line-number"> 59</span>        filename: The filename to search for (e.g., &quot;header.h&quot;)
<span class="line-number"> 60</span>        file_dict: Dictionary with file paths as keys
<span class="line-number"> 61</span>
<span class="line-number"> 62</span>    Returns:
<span class="line-number"> 63</span>        The matching file path key, or None if not found
<span class="line-number"> 64</span>    &quot;&quot;&quot;
<span class="line-number"> 65</span>    # First try exact match
<span class="line-number"> 66</span><span class="uncovered">    if filename in file_dict:</span>
<span class="line-number"> 67</span><span class="uncovered">        return filename</span>
<span class="line-number"> 68</span>
<span class="line-number"> 69</span>    # Try matching by filename
<span class="line-number"> 70</span><span class="uncovered">    for file_path in file_dict.keys():</span>
<span class="line-number"> 71</span><span class="uncovered">        if Path(file_path).name == filename:</span>
<span class="line-number"> 72</span><span class="uncovered">            return file_path</span>
<span class="line-number"> 73</span>
<span class="line-number"> 74</span><span class="uncovered">    return None</span>
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>
<span class="line-number"> 77</span>def normalize_file_path(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number"> 78</span>    &quot;&quot;&quot;
<span class="line-number"> 79</span>    Normalize file path for consistent handling.
<span class="line-number"> 80</span>    For tracking purposes, we prefer relative paths when possible.
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>    Args:
<span class="line-number"> 83</span>        file_path: The file path to normalize
<span class="line-number"> 84</span>        project_root: Optional project root for relative path conversion
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>    Returns:
<span class="line-number"> 87</span>        Normalized file path
<span class="line-number"> 88</span>    &quot;&quot;&quot;
<span class="line-number"> 89</span><span class="uncovered">    path_obj = Path(file_path)</span>
<span class="line-number"> 90</span>
<span class="line-number"> 91</span>    # If we have a project root and the path is absolute, try to make it relative
<span class="line-number"> 92</span><span class="uncovered">    if project_root and path_obj.is_absolute():</span>
<span class="line-number"> 93</span><span class="uncovered">        try:</span>
<span class="line-number"> 94</span><span class="uncovered">            relative_path = path_obj.relative_to(Path(project_root))</span>
<span class="line-number"> 95</span><span class="uncovered">            return str(relative_path)</span>
<span class="line-number"> 96</span><span class="uncovered">        except ValueError:</span>
<span class="line-number"> 97</span>            # Path is not relative to project root, keep as is
<span class="line-number"> 98</span><span class="uncovered">            pass</span>
<span class="line-number"> 99</span>
<span class="line-number">100</span><span class="uncovered">    return str(path_obj)</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>def create_file_key(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number">104</span>    &quot;&quot;&quot;
<span class="line-number">105</span>    Create a consistent file key for tracking.
<span class="line-number">106</span>    Uses filename for uniqueness since filenames are unique in the project.
<span class="line-number">107</span>
<span class="line-number">108</span>    Args:
<span class="line-number">109</span>        file_path: The file path
<span class="line-number">110</span>        project_root: Optional project root for normalization
<span class="line-number">111</span>
<span class="line-number">112</span>    Returns:
<span class="line-number">113</span>        A consistent file key (filename)
<span class="line-number">114</span>    &quot;&quot;&quot;
<span class="line-number">115</span><span class="uncovered">    return get_filename_from_path(file_path)</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span># Backward compatibility functions for existing tests
<span class="line-number">119</span>def get_acceptable_encodings() -&gt; list:
<span class="line-number">120</span>    &quot;&quot;&quot;
<span class="line-number">121</span>    Get a list of acceptable encodings for cross-platform compatibility.
<span class="line-number">122</span>
<span class="line-number">123</span>    Returns:
<span class="line-number">124</span>        List of encoding names that are considered acceptable across platforms.
<span class="line-number">125</span>    &quot;&quot;&quot;
<span class="line-number">126</span>    return [
<span class="line-number">127</span>        &quot;utf-8&quot;,
<span class="line-number">128</span>        &quot;utf-8-sig&quot;,
<span class="line-number">129</span>        &quot;utf-16&quot;,
<span class="line-number">130</span>        &quot;utf-16le&quot;,
<span class="line-number">131</span>        &quot;utf-16be&quot;,
<span class="line-number">132</span>        &quot;windows-1252&quot;,
<span class="line-number">133</span>        &quot;windows-1254&quot;,
<span class="line-number">134</span>        &quot;cp1252&quot;,
<span class="line-number">135</span>        &quot;cp1254&quot;,
<span class="line-number">136</span>        &quot;iso-8859-1&quot;,
<span class="line-number">137</span>        &quot;latin-1&quot;,
<span class="line-number">138</span>        &quot;ascii&quot;,
<span class="line-number">139</span>    ]
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>def is_acceptable_encoding(encoding: str) -&gt; bool:
<span class="line-number">143</span>    &quot;&quot;&quot;
<span class="line-number">144</span>    Check if an encoding is acceptable for cross-platform compatibility.
<span class="line-number">145</span>
<span class="line-number">146</span>    Args:
<span class="line-number">147</span>        encoding: The encoding name to check.
<span class="line-number">148</span>
<span class="line-number">149</span>    Returns:
<span class="line-number">150</span>        True if the encoding is acceptable, False otherwise.
<span class="line-number">151</span>    &quot;&quot;&quot;
<span class="line-number">152</span>    return encoding.lower() in [enc.lower() for enc in get_acceptable_encodings()]
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>def normalize_encoding(encoding: str) -&gt; str:
<span class="line-number">156</span>    &quot;&quot;&quot;
<span class="line-number">157</span>    Normalize encoding name for consistency across platforms.
<span class="line-number">158</span>
<span class="line-number">159</span>    Args:
<span class="line-number">160</span>        encoding: The encoding name to normalize.
<span class="line-number">161</span>
<span class="line-number">162</span>    Returns:
<span class="line-number">163</span>        Normalized encoding name.
<span class="line-number">164</span>    &quot;&quot;&quot;
<span class="line-number">165</span>    encoding_lower = encoding.lower()
<span class="line-number">166</span>
<span class="line-number">167</span>    # Normalize common Windows encodings
<span class="line-number">168</span>    if encoding_lower in [&quot;windows-1252&quot;, &quot;cp1252&quot;]:
<span class="line-number">169</span>        return &quot;windows-1252&quot;
<span class="line-number">170</span>    elif encoding_lower in [&quot;windows-1254&quot;, &quot;cp1254&quot;]:
<span class="line-number">171</span>        return &quot;windows-1254&quot;
<span class="line-number">172</span>    elif encoding_lower in [&quot;iso-8859-1&quot;, &quot;latin-1&quot;]:
<span class="line-number">173</span>        return &quot;iso-8859-1&quot;
<span class="line-number">174</span>
<span class="line-number">175</span>    return encoding_lower
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>def get_platform_default_encoding() -&gt; str:
<span class="line-number">179</span>    &quot;&quot;&quot;
<span class="line-number">180</span>    Get the default encoding for the current platform.
<span class="line-number">181</span>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
<h4>Function: normalize_file_path (lines 77-189)</h4>
<pre>
<span class="line-number"> 77</span>def normalize_file_path(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number"> 78</span>    &quot;&quot;&quot;
<span class="line-number"> 79</span>    Normalize file path for consistent handling.
<span class="line-number"> 80</span>    For tracking purposes, we prefer relative paths when possible.
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>    Args:
<span class="line-number"> 83</span>        file_path: The file path to normalize
<span class="line-number"> 84</span>        project_root: Optional project root for relative path conversion
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>    Returns:
<span class="line-number"> 87</span>        Normalized file path
<span class="line-number"> 88</span>    &quot;&quot;&quot;
<span class="line-number"> 89</span><span class="uncovered">    path_obj = Path(file_path)</span>
<span class="line-number"> 90</span>
<span class="line-number"> 91</span>    # If we have a project root and the path is absolute, try to make it relative
<span class="line-number"> 92</span><span class="uncovered">    if project_root and path_obj.is_absolute():</span>
<span class="line-number"> 93</span><span class="uncovered">        try:</span>
<span class="line-number"> 94</span><span class="uncovered">            relative_path = path_obj.relative_to(Path(project_root))</span>
<span class="line-number"> 95</span><span class="uncovered">            return str(relative_path)</span>
<span class="line-number"> 96</span><span class="uncovered">        except ValueError:</span>
<span class="line-number"> 97</span>            # Path is not relative to project root, keep as is
<span class="line-number"> 98</span><span class="uncovered">            pass</span>
<span class="line-number"> 99</span>
<span class="line-number">100</span><span class="uncovered">    return str(path_obj)</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>def create_file_key(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number">104</span>    &quot;&quot;&quot;
<span class="line-number">105</span>    Create a consistent file key for tracking.
<span class="line-number">106</span>    Uses filename for uniqueness since filenames are unique in the project.
<span class="line-number">107</span>
<span class="line-number">108</span>    Args:
<span class="line-number">109</span>        file_path: The file path
<span class="line-number">110</span>        project_root: Optional project root for normalization
<span class="line-number">111</span>
<span class="line-number">112</span>    Returns:
<span class="line-number">113</span>        A consistent file key (filename)
<span class="line-number">114</span>    &quot;&quot;&quot;
<span class="line-number">115</span><span class="uncovered">    return get_filename_from_path(file_path)</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span># Backward compatibility functions for existing tests
<span class="line-number">119</span>def get_acceptable_encodings() -&gt; list:
<span class="line-number">120</span>    &quot;&quot;&quot;
<span class="line-number">121</span>    Get a list of acceptable encodings for cross-platform compatibility.
<span class="line-number">122</span>
<span class="line-number">123</span>    Returns:
<span class="line-number">124</span>        List of encoding names that are considered acceptable across platforms.
<span class="line-number">125</span>    &quot;&quot;&quot;
<span class="line-number">126</span>    return [
<span class="line-number">127</span>        &quot;utf-8&quot;,
<span class="line-number">128</span>        &quot;utf-8-sig&quot;,
<span class="line-number">129</span>        &quot;utf-16&quot;,
<span class="line-number">130</span>        &quot;utf-16le&quot;,
<span class="line-number">131</span>        &quot;utf-16be&quot;,
<span class="line-number">132</span>        &quot;windows-1252&quot;,
<span class="line-number">133</span>        &quot;windows-1254&quot;,
<span class="line-number">134</span>        &quot;cp1252&quot;,
<span class="line-number">135</span>        &quot;cp1254&quot;,
<span class="line-number">136</span>        &quot;iso-8859-1&quot;,
<span class="line-number">137</span>        &quot;latin-1&quot;,
<span class="line-number">138</span>        &quot;ascii&quot;,
<span class="line-number">139</span>    ]
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>def is_acceptable_encoding(encoding: str) -&gt; bool:
<span class="line-number">143</span>    &quot;&quot;&quot;
<span class="line-number">144</span>    Check if an encoding is acceptable for cross-platform compatibility.
<span class="line-number">145</span>
<span class="line-number">146</span>    Args:
<span class="line-number">147</span>        encoding: The encoding name to check.
<span class="line-number">148</span>
<span class="line-number">149</span>    Returns:
<span class="line-number">150</span>        True if the encoding is acceptable, False otherwise.
<span class="line-number">151</span>    &quot;&quot;&quot;
<span class="line-number">152</span>    return encoding.lower() in [enc.lower() for enc in get_acceptable_encodings()]
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>def normalize_encoding(encoding: str) -&gt; str:
<span class="line-number">156</span>    &quot;&quot;&quot;
<span class="line-number">157</span>    Normalize encoding name for consistency across platforms.
<span class="line-number">158</span>
<span class="line-number">159</span>    Args:
<span class="line-number">160</span>        encoding: The encoding name to normalize.
<span class="line-number">161</span>
<span class="line-number">162</span>    Returns:
<span class="line-number">163</span>        Normalized encoding name.
<span class="line-number">164</span>    &quot;&quot;&quot;
<span class="line-number">165</span>    encoding_lower = encoding.lower()
<span class="line-number">166</span>
<span class="line-number">167</span>    # Normalize common Windows encodings
<span class="line-number">168</span>    if encoding_lower in [&quot;windows-1252&quot;, &quot;cp1252&quot;]:
<span class="line-number">169</span>        return &quot;windows-1252&quot;
<span class="line-number">170</span>    elif encoding_lower in [&quot;windows-1254&quot;, &quot;cp1254&quot;]:
<span class="line-number">171</span>        return &quot;windows-1254&quot;
<span class="line-number">172</span>    elif encoding_lower in [&quot;iso-8859-1&quot;, &quot;latin-1&quot;]:
<span class="line-number">173</span>        return &quot;iso-8859-1&quot;
<span class="line-number">174</span>
<span class="line-number">175</span>    return encoding_lower
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>def get_platform_default_encoding() -&gt; str:
<span class="line-number">179</span>    &quot;&quot;&quot;
<span class="line-number">180</span>    Get the default encoding for the current platform.
<span class="line-number">181</span>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
<h4>Function: create_file_key (lines 103-189)</h4>
<pre>
<span class="line-number">103</span>def create_file_key(file_path: str, project_root: str = None) -&gt; str:
<span class="line-number">104</span>    &quot;&quot;&quot;
<span class="line-number">105</span>    Create a consistent file key for tracking.
<span class="line-number">106</span>    Uses filename for uniqueness since filenames are unique in the project.
<span class="line-number">107</span>
<span class="line-number">108</span>    Args:
<span class="line-number">109</span>        file_path: The file path
<span class="line-number">110</span>        project_root: Optional project root for normalization
<span class="line-number">111</span>
<span class="line-number">112</span>    Returns:
<span class="line-number">113</span>        A consistent file key (filename)
<span class="line-number">114</span>    &quot;&quot;&quot;
<span class="line-number">115</span><span class="uncovered">    return get_filename_from_path(file_path)</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span># Backward compatibility functions for existing tests
<span class="line-number">119</span>def get_acceptable_encodings() -&gt; list:
<span class="line-number">120</span>    &quot;&quot;&quot;
<span class="line-number">121</span>    Get a list of acceptable encodings for cross-platform compatibility.
<span class="line-number">122</span>
<span class="line-number">123</span>    Returns:
<span class="line-number">124</span>        List of encoding names that are considered acceptable across platforms.
<span class="line-number">125</span>    &quot;&quot;&quot;
<span class="line-number">126</span>    return [
<span class="line-number">127</span>        &quot;utf-8&quot;,
<span class="line-number">128</span>        &quot;utf-8-sig&quot;,
<span class="line-number">129</span>        &quot;utf-16&quot;,
<span class="line-number">130</span>        &quot;utf-16le&quot;,
<span class="line-number">131</span>        &quot;utf-16be&quot;,
<span class="line-number">132</span>        &quot;windows-1252&quot;,
<span class="line-number">133</span>        &quot;windows-1254&quot;,
<span class="line-number">134</span>        &quot;cp1252&quot;,
<span class="line-number">135</span>        &quot;cp1254&quot;,
<span class="line-number">136</span>        &quot;iso-8859-1&quot;,
<span class="line-number">137</span>        &quot;latin-1&quot;,
<span class="line-number">138</span>        &quot;ascii&quot;,
<span class="line-number">139</span>    ]
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>def is_acceptable_encoding(encoding: str) -&gt; bool:
<span class="line-number">143</span>    &quot;&quot;&quot;
<span class="line-number">144</span>    Check if an encoding is acceptable for cross-platform compatibility.
<span class="line-number">145</span>
<span class="line-number">146</span>    Args:
<span class="line-number">147</span>        encoding: The encoding name to check.
<span class="line-number">148</span>
<span class="line-number">149</span>    Returns:
<span class="line-number">150</span>        True if the encoding is acceptable, False otherwise.
<span class="line-number">151</span>    &quot;&quot;&quot;
<span class="line-number">152</span>    return encoding.lower() in [enc.lower() for enc in get_acceptable_encodings()]
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>def normalize_encoding(encoding: str) -&gt; str:
<span class="line-number">156</span>    &quot;&quot;&quot;
<span class="line-number">157</span>    Normalize encoding name for consistency across platforms.
<span class="line-number">158</span>
<span class="line-number">159</span>    Args:
<span class="line-number">160</span>        encoding: The encoding name to normalize.
<span class="line-number">161</span>
<span class="line-number">162</span>    Returns:
<span class="line-number">163</span>        Normalized encoding name.
<span class="line-number">164</span>    &quot;&quot;&quot;
<span class="line-number">165</span>    encoding_lower = encoding.lower()
<span class="line-number">166</span>
<span class="line-number">167</span>    # Normalize common Windows encodings
<span class="line-number">168</span>    if encoding_lower in [&quot;windows-1252&quot;, &quot;cp1252&quot;]:
<span class="line-number">169</span>        return &quot;windows-1252&quot;
<span class="line-number">170</span>    elif encoding_lower in [&quot;windows-1254&quot;, &quot;cp1254&quot;]:
<span class="line-number">171</span>        return &quot;windows-1254&quot;
<span class="line-number">172</span>    elif encoding_lower in [&quot;iso-8859-1&quot;, &quot;latin-1&quot;]:
<span class="line-number">173</span>        return &quot;iso-8859-1&quot;
<span class="line-number">174</span>
<span class="line-number">175</span>    return encoding_lower
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>def get_platform_default_encoding() -&gt; str:
<span class="line-number">179</span>    &quot;&quot;&quot;
<span class="line-number">180</span>    Get the default encoding for the current platform.
<span class="line-number">181</span>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
<h4>Function: get_acceptable_encodings (lines 119-189)</h4>
<pre>
<span class="line-number">119</span>def get_acceptable_encodings() -&gt; list:
<span class="line-number">120</span>    &quot;&quot;&quot;
<span class="line-number">121</span>    Get a list of acceptable encodings for cross-platform compatibility.
<span class="line-number">122</span>
<span class="line-number">123</span>    Returns:
<span class="line-number">124</span>        List of encoding names that are considered acceptable across platforms.
<span class="line-number">125</span>    &quot;&quot;&quot;
<span class="line-number">126</span>    return [
<span class="line-number">127</span>        &quot;utf-8&quot;,
<span class="line-number">128</span>        &quot;utf-8-sig&quot;,
<span class="line-number">129</span>        &quot;utf-16&quot;,
<span class="line-number">130</span>        &quot;utf-16le&quot;,
<span class="line-number">131</span>        &quot;utf-16be&quot;,
<span class="line-number">132</span>        &quot;windows-1252&quot;,
<span class="line-number">133</span>        &quot;windows-1254&quot;,
<span class="line-number">134</span>        &quot;cp1252&quot;,
<span class="line-number">135</span>        &quot;cp1254&quot;,
<span class="line-number">136</span>        &quot;iso-8859-1&quot;,
<span class="line-number">137</span>        &quot;latin-1&quot;,
<span class="line-number">138</span>        &quot;ascii&quot;,
<span class="line-number">139</span>    ]
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>def is_acceptable_encoding(encoding: str) -&gt; bool:
<span class="line-number">143</span>    &quot;&quot;&quot;
<span class="line-number">144</span>    Check if an encoding is acceptable for cross-platform compatibility.
<span class="line-number">145</span>
<span class="line-number">146</span>    Args:
<span class="line-number">147</span>        encoding: The encoding name to check.
<span class="line-number">148</span>
<span class="line-number">149</span>    Returns:
<span class="line-number">150</span>        True if the encoding is acceptable, False otherwise.
<span class="line-number">151</span>    &quot;&quot;&quot;
<span class="line-number">152</span>    return encoding.lower() in [enc.lower() for enc in get_acceptable_encodings()]
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>def normalize_encoding(encoding: str) -&gt; str:
<span class="line-number">156</span>    &quot;&quot;&quot;
<span class="line-number">157</span>    Normalize encoding name for consistency across platforms.
<span class="line-number">158</span>
<span class="line-number">159</span>    Args:
<span class="line-number">160</span>        encoding: The encoding name to normalize.
<span class="line-number">161</span>
<span class="line-number">162</span>    Returns:
<span class="line-number">163</span>        Normalized encoding name.
<span class="line-number">164</span>    &quot;&quot;&quot;
<span class="line-number">165</span>    encoding_lower = encoding.lower()
<span class="line-number">166</span>
<span class="line-number">167</span>    # Normalize common Windows encodings
<span class="line-number">168</span>    if encoding_lower in [&quot;windows-1252&quot;, &quot;cp1252&quot;]:
<span class="line-number">169</span>        return &quot;windows-1252&quot;
<span class="line-number">170</span>    elif encoding_lower in [&quot;windows-1254&quot;, &quot;cp1254&quot;]:
<span class="line-number">171</span>        return &quot;windows-1254&quot;
<span class="line-number">172</span>    elif encoding_lower in [&quot;iso-8859-1&quot;, &quot;latin-1&quot;]:
<span class="line-number">173</span>        return &quot;iso-8859-1&quot;
<span class="line-number">174</span>
<span class="line-number">175</span>    return encoding_lower
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>def get_platform_default_encoding() -&gt; str:
<span class="line-number">179</span>    &quot;&quot;&quot;
<span class="line-number">180</span>    Get the default encoding for the current platform.
<span class="line-number">181</span>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
<h4>Function: is_acceptable_encoding (lines 142-189)</h4>
<pre>
<span class="line-number">142</span>def is_acceptable_encoding(encoding: str) -&gt; bool:
<span class="line-number">143</span>    &quot;&quot;&quot;
<span class="line-number">144</span>    Check if an encoding is acceptable for cross-platform compatibility.
<span class="line-number">145</span>
<span class="line-number">146</span>    Args:
<span class="line-number">147</span>        encoding: The encoding name to check.
<span class="line-number">148</span>
<span class="line-number">149</span>    Returns:
<span class="line-number">150</span>        True if the encoding is acceptable, False otherwise.
<span class="line-number">151</span>    &quot;&quot;&quot;
<span class="line-number">152</span>    return encoding.lower() in [enc.lower() for enc in get_acceptable_encodings()]
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>def normalize_encoding(encoding: str) -&gt; str:
<span class="line-number">156</span>    &quot;&quot;&quot;
<span class="line-number">157</span>    Normalize encoding name for consistency across platforms.
<span class="line-number">158</span>
<span class="line-number">159</span>    Args:
<span class="line-number">160</span>        encoding: The encoding name to normalize.
<span class="line-number">161</span>
<span class="line-number">162</span>    Returns:
<span class="line-number">163</span>        Normalized encoding name.
<span class="line-number">164</span>    &quot;&quot;&quot;
<span class="line-number">165</span>    encoding_lower = encoding.lower()
<span class="line-number">166</span>
<span class="line-number">167</span>    # Normalize common Windows encodings
<span class="line-number">168</span>    if encoding_lower in [&quot;windows-1252&quot;, &quot;cp1252&quot;]:
<span class="line-number">169</span>        return &quot;windows-1252&quot;
<span class="line-number">170</span>    elif encoding_lower in [&quot;windows-1254&quot;, &quot;cp1254&quot;]:
<span class="line-number">171</span>        return &quot;windows-1254&quot;
<span class="line-number">172</span>    elif encoding_lower in [&quot;iso-8859-1&quot;, &quot;latin-1&quot;]:
<span class="line-number">173</span>        return &quot;iso-8859-1&quot;
<span class="line-number">174</span>
<span class="line-number">175</span>    return encoding_lower
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>def get_platform_default_encoding() -&gt; str:
<span class="line-number">179</span>    &quot;&quot;&quot;
<span class="line-number">180</span>    Get the default encoding for the current platform.
<span class="line-number">181</span>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
<h4>Function: normalize_encoding (lines 155-189)</h4>
<pre>
<span class="line-number">155</span>def normalize_encoding(encoding: str) -&gt; str:
<span class="line-number">156</span>    &quot;&quot;&quot;
<span class="line-number">157</span>    Normalize encoding name for consistency across platforms.
<span class="line-number">158</span>
<span class="line-number">159</span>    Args:
<span class="line-number">160</span>        encoding: The encoding name to normalize.
<span class="line-number">161</span>
<span class="line-number">162</span>    Returns:
<span class="line-number">163</span>        Normalized encoding name.
<span class="line-number">164</span>    &quot;&quot;&quot;
<span class="line-number">165</span>    encoding_lower = encoding.lower()
<span class="line-number">166</span>
<span class="line-number">167</span>    # Normalize common Windows encodings
<span class="line-number">168</span>    if encoding_lower in [&quot;windows-1252&quot;, &quot;cp1252&quot;]:
<span class="line-number">169</span>        return &quot;windows-1252&quot;
<span class="line-number">170</span>    elif encoding_lower in [&quot;windows-1254&quot;, &quot;cp1254&quot;]:
<span class="line-number">171</span>        return &quot;windows-1254&quot;
<span class="line-number">172</span>    elif encoding_lower in [&quot;iso-8859-1&quot;, &quot;latin-1&quot;]:
<span class="line-number">173</span>        return &quot;iso-8859-1&quot;
<span class="line-number">174</span>
<span class="line-number">175</span>    return encoding_lower
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>def get_platform_default_encoding() -&gt; str:
<span class="line-number">179</span>    &quot;&quot;&quot;
<span class="line-number">180</span>    Get the default encoding for the current platform.
<span class="line-number">181</span>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
<h4>Function: get_platform_default_encoding (lines 178-189)</h4>
<pre>
<span class="line-number">178</span>def get_platform_default_encoding() -&gt; str:
<span class="line-number">179</span>    &quot;&quot;&quot;
<span class="line-number">180</span>    Get the default encoding for the current platform.
<span class="line-number">181</span>
<span class="line-number">182</span>    Returns:
<span class="line-number">183</span>        The default encoding name for the current platform.
<span class="line-number">184</span>    &quot;&quot;&quot;
<span class="line-number">185</span>    import sys
<span class="line-number">186</span>    if sys.platform.startswith(&quot;win&quot;):
<span class="line-number">187</span><span class="uncovered">        return &quot;windows-1252&quot;  # Common Windows default</span>
<span class="line-number">188</span>    else:
<span class="line-number">189</span>        return &quot;utf-8&quot;  # Common Unix/Linux default
</pre>
</div>
<div class="file-section">
<div class="file-header">
/home/runner/work/generator_project/generator_project/c_to_plantuml/config.py - 89.00% coverage (178/200 lines)
</div>
<h4>Function: __init__ (lines 44-405)</h4>
<pre>
<span class="line-number"> 44</span>    def __init__(self, *args, **kwargs):
<span class="line-number"> 45</span>        &quot;&quot;&quot;Initialize configuration with keyword arguments or a single dict&quot;&quot;&quot;
<span class="line-number"> 46</span>        # Initialize logger
<span class="line-number"> 47</span>        self.logger = logging.getLogger(__name__)
<span class="line-number"> 48</span>
<span class="line-number"> 49</span>        # Initialize with default values first
<span class="line-number"> 50</span>        object.__init__(self)
<span class="line-number"> 51</span>
<span class="line-number"> 52</span>        # Ensure all dataclass fields are initialized with defaults
<span class="line-number"> 53</span>        if not hasattr(self, &quot;project_name&quot;):
<span class="line-number"> 54</span><span class="uncovered">            self.project_name = &quot;Unknown_Project&quot;</span>
<span class="line-number"> 55</span>        if not hasattr(self, &quot;source_folders&quot;):
<span class="line-number"> 56</span>            self.source_folders = []
<span class="line-number"> 57</span>        if not hasattr(self, &quot;output_dir&quot;):
<span class="line-number"> 58</span><span class="uncovered">            self.output_dir = &quot;./output&quot;</span>
<span class="line-number"> 59</span>        if not hasattr(self, &quot;model_output_path&quot;):
<span class="line-number"> 60</span><span class="uncovered">            self.model_output_path = &quot;model.json&quot;</span>
<span class="line-number"> 61</span>        if not hasattr(self, &quot;recursive_search&quot;):
<span class="line-number"> 62</span><span class="uncovered">            self.recursive_search = True</span>
<span class="line-number"> 63</span>        if not hasattr(self, &quot;include_depth&quot;):
<span class="line-number"> 64</span><span class="uncovered">            self.include_depth = 1</span>
<span class="line-number"> 65</span>        if not hasattr(self, &quot;file_filters&quot;):
<span class="line-number"> 66</span>            self.file_filters = {}
<span class="line-number"> 67</span>        if not hasattr(self, &quot;element_filters&quot;):
<span class="line-number"> 68</span>            self.element_filters = {}
<span class="line-number"> 69</span>        if not hasattr(self, &quot;transformations&quot;):
<span class="line-number"> 70</span>            self.transformations = {}
<span class="line-number"> 71</span>        if not hasattr(self, &quot;file_include_patterns&quot;):
<span class="line-number"> 72</span>            self.file_include_patterns = []
<span class="line-number"> 73</span>        if not hasattr(self, &quot;file_exclude_patterns&quot;):
<span class="line-number"> 74</span>            self.file_exclude_patterns = []
<span class="line-number"> 75</span>        if not hasattr(self, &quot;element_include_patterns&quot;):
<span class="line-number"> 76</span>            self.element_include_patterns = {}
<span class="line-number"> 77</span>        if not hasattr(self, &quot;element_exclude_patterns&quot;):
<span class="line-number"> 78</span>            self.element_exclude_patterns = {}
<span class="line-number"> 79</span>
<span class="line-number"> 80</span>        if len(args) == 1 and isinstance(args[0], dict):
<span class="line-number"> 81</span>            # Handle case where a single dict is passed as positional argument
<span class="line-number"> 82</span>            data = args[0]
<span class="line-number"> 83</span>            # Set attributes manually
<span class="line-number"> 84</span>            for key, value in data.items():
<span class="line-number"> 85</span>                if hasattr(self, key):
<span class="line-number"> 86</span>                    setattr(self, key, value)
<span class="line-number"> 87</span>        elif len(kwargs) == 1 and isinstance(next(iter(kwargs.values())), dict):
<span class="line-number"> 88</span>            # Handle case where a single dict is passed as keyword argument
<span class="line-number"> 89</span><span class="uncovered">            data = next(iter(kwargs.values()))</span>
<span class="line-number"> 90</span><span class="uncovered">            for key, value in data.items():</span>
<span class="line-number"> 91</span><span class="uncovered">                if hasattr(self, key):</span>
<span class="line-number"> 92</span><span class="uncovered">                    setattr(self, key, value)</span>
<span class="line-number"> 93</span>        else:
<span class="line-number"> 94</span>            # Handle normal keyword arguments
<span class="line-number"> 95</span>            for key, value in kwargs.items():
<span class="line-number"> 96</span>                if hasattr(self, key):
<span class="line-number"> 97</span>                    setattr(self, key, value)
<span class="line-number"> 98</span>
<span class="line-number"> 99</span>        # Compile patterns after initialization
<span class="line-number">100</span>        self._compile_patterns()
<span class="line-number">101</span>
<span class="line-number">102</span>    def __post_init__(self):
<span class="line-number">103</span>        &quot;&quot;&quot;Compile regex patterns after initialization&quot;&quot;&quot;
<span class="line-number">104</span><span class="uncovered">        self._compile_patterns()</span>
<span class="line-number">105</span>
<span class="line-number">106</span>    def _compile_patterns(self):
<span class="line-number">107</span>        &quot;&quot;&quot;Compile regex patterns for filtering&quot;&quot;&quot;
<span class="line-number">108</span>        # Compile file filter patterns with error handling
<span class="line-number">109</span>        self.file_include_patterns = []
<span class="line-number">110</span>        for pattern in self.file_filters.get(&quot;include&quot;, []):
<span class="line-number">111</span>            try:
<span class="line-number">112</span>                self.file_include_patterns.append(re.compile(pattern))
<span class="line-number">113</span>            except re.error as e:
<span class="line-number">114</span>                self.logger.warning(&quot;Invalid include pattern &#x27;%s&#x27;: %s&quot;, pattern, e)
<span class="line-number">115</span>                # Skip invalid patterns
<span class="line-number">116</span>
<span class="line-number">117</span>        self.file_exclude_patterns = []
<span class="line-number">118</span>        for pattern in self.file_filters.get(&quot;exclude&quot;, []):
<span class="line-number">119</span>            try:
<span class="line-number">120</span>                self.file_exclude_patterns.append(re.compile(pattern))
<span class="line-number">121</span>            except re.error as e:
<span class="line-number">122</span>                self.logger.warning(&quot;Invalid exclude pattern &#x27;%s&#x27;: %s&quot;, pattern, e)
<span class="line-number">123</span>                # Skip invalid patterns
<span class="line-number">124</span>
<span class="line-number">125</span>        # Compile element filter patterns with error handling
<span class="line-number">126</span>        self.element_include_patterns = {}
<span class="line-number">127</span>        self.element_exclude_patterns = {}
<span class="line-number">128</span>
<span class="line-number">129</span>        for element_type, filters in self.element_filters.items():
<span class="line-number">130</span>            self.element_include_patterns[element_type] = []
<span class="line-number">131</span>            for pattern in filters.get(&quot;include&quot;, []):
<span class="line-number">132</span>                try:
<span class="line-number">133</span>                    self.element_include_patterns[element_type].append(
<span class="line-number">134</span>                        re.compile(pattern)
<span class="line-number">135</span>                    )
<span class="line-number">136</span>                except re.error as e:
<span class="line-number">137</span>                    self.logger.warning(
<span class="line-number">138</span>                        &quot;Invalid %s include pattern &#x27;%s&#x27;: %s&quot;, element_type, pattern, e
<span class="line-number">139</span>                    )
<span class="line-number">140</span>                    # Skip invalid patterns
<span class="line-number">141</span>
<span class="line-number">142</span>            self.element_exclude_patterns[element_type] = []
<span class="line-number">143</span>            for pattern in filters.get(&quot;exclude&quot;, []):
<span class="line-number">144</span>                try:
<span class="line-number">145</span>                    self.element_exclude_patterns[element_type].append(
<span class="line-number">146</span>                        re.compile(pattern)
<span class="line-number">147</span>                    )
<span class="line-number">148</span><span class="uncovered">                except re.error as e:</span>
<span class="line-number">149</span><span class="uncovered">                    self.logger.warning(</span>
<span class="line-number">150</span>                        &quot;Invalid %s exclude pattern &#x27;%s&#x27;: %s&quot;, element_type, pattern, e
<span class="line-number">151</span>                    )
<span class="line-number">152</span>                    # Skip invalid patterns
<span class="line-number">153</span>
<span class="line-number">154</span>    @classmethod
<span class="line-number">155</span>    def load(cls, config_file: str) -&gt; &quot;Config&quot;:
<span class="line-number">156</span>        &quot;&quot;&quot;Load configuration from JSON file&quot;&quot;&quot;
<span class="line-number">157</span>        if not Path(config_file).exists():
<span class="line-number">158</span><span class="uncovered">            raise FileNotFoundError(f&quot;Configuration file not found: {config_file}&quot;)</span>
<span class="line-number">159</span>
<span class="line-number">160</span>        try:
<span class="line-number">161</span>            with open(config_file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">162</span>                data = json.load(f)
<span class="line-number">163</span>
<span class="line-number">164</span>            # Handle backward compatibility: project_roots -&gt; source_folders
<span class="line-number">165</span>            if &quot;project_roots&quot; in data and &quot;source_folders&quot; not in data:
<span class="line-number">166</span><span class="uncovered">                data[&quot;source_folders&quot;] = data.pop(&quot;project_roots&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>            # Validate required fields
<span class="line-number">169</span>            if &quot;source_folders&quot; not in data:
<span class="line-number">170</span><span class="uncovered">                raise ValueError(&quot;Configuration must contain &#x27;source_folders&#x27; field&quot;)</span>
<span class="line-number">171</span>
<span class="line-number">172</span>            if not isinstance(data[&quot;source_folders&quot;], list):
<span class="line-number">173</span>                raise ValueError(&quot;&#x27;source_folders&#x27; must be a list&quot;)
<span class="line-number">174</span>
<span class="line-number">175</span>            return cls(**data)
<span class="line-number">176</span>
<span class="line-number">177</span>        except Exception as e:
<span class="line-number">178</span>            raise ValueError(
<span class="line-number">179</span>                f&quot;Failed to load configuration from {config_file}: {e}&quot;
<span class="line-number">180</span>            ) from e
<span class="line-number">181</span>
<span class="line-number">182</span>    def save(self, config_file: str) -&gt; None:
<span class="line-number">183</span>        &quot;&quot;&quot;Save configuration to JSON file&quot;&quot;&quot;
<span class="line-number">184</span>        data = {
<span class="line-number">185</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">186</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">187</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">188</span>            &quot;model_output_path&quot;: self.model_output_path,
<span class="line-number">189</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">190</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">191</span>            &quot;file_filters&quot;: self.file_filters,
<span class="line-number">192</span>            &quot;element_filters&quot;: self.element_filters,
<span class="line-number">193</span>            &quot;transformations&quot;: self.transformations,
<span class="line-number">194</span>        }
<span class="line-number">195</span>
<span class="line-number">196</span>        try:
<span class="line-number">197</span>            with open(config_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">198</span>                json.dump(data, f, indent=2, ensure_ascii=False)
<span class="line-number">199</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">200</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number">201</span>                f&quot;Failed to save configuration to {config_file}: {e}&quot;
<span class="line-number">202</span>            ) from e
<span class="line-number">203</span>
<span class="line-number">204</span>    def has_filters(self) -&gt; bool:
<span class="line-number">205</span>        &quot;&quot;&quot;Check if configuration has any filters defined&quot;&quot;&quot;
<span class="line-number">206</span>        return bool(self.file_filters or self.element_filters)
<span class="line-number">207</span>
<span class="line-number">208</span>    def _should_include_file(self, file_path: str) -&gt; bool:
<span class="line-number">209</span>        &quot;&quot;&quot;Check if a file should be included based on filters&quot;&quot;&quot;
<span class="line-number">210</span>        # Check exclude patterns first
<span class="line-number">211</span>        for pattern in self.file_exclude_patterns:
<span class="line-number">212</span>            if pattern.search(file_path):
<span class="line-number">213</span>                return False
<span class="line-number">214</span>
<span class="line-number">215</span>        # If no include patterns, include all files (after exclusions)
<span class="line-number">216</span>        if not self.file_include_patterns:
<span class="line-number">217</span>            return True
<span class="line-number">218</span>
<span class="line-number">219</span>        # Check include patterns - file must match at least one
<span class="line-number">220</span>        for pattern in self.file_include_patterns:
<span class="line-number">221</span>            if pattern.search(file_path):
<span class="line-number">222</span>                return True
<span class="line-number">223</span>
<span class="line-number">224</span>        return False
<span class="line-number">225</span>
<span class="line-number">226</span>    def _apply_element_filters(self, file_model) -&gt; Any:
<span class="line-number">227</span>        &quot;&quot;&quot;Apply element filters to a file model&quot;&quot;&quot;
<span class="line-number">228</span>
<span class="line-number">229</span>        # Create a copy of the file model to avoid modifying the original
<span class="line-number">230</span>        filtered_model = FileModel(
<span class="line-number">231</span>            file_path=file_model.file_path,
<span class="line-number">232</span>            relative_path=file_model.relative_path,
<span class="line-number">233</span>            project_root=file_model.project_root,
<span class="line-number">234</span>            encoding_used=file_model.encoding_used,
<span class="line-number">235</span>            structs=file_model.structs.copy(),
<span class="line-number">236</span>            enums=file_model.enums.copy(),
<span class="line-number">237</span>            unions=file_model.unions.copy(),
<span class="line-number">238</span>            functions=file_model.functions.copy(),
<span class="line-number">239</span>            globals=file_model.globals.copy(),
<span class="line-number">240</span>            includes=file_model.includes.copy(),
<span class="line-number">241</span>            macros=file_model.macros.copy(),
<span class="line-number">242</span>            aliases=file_model.aliases.copy(),
<span class="line-number">243</span>            # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">244</span>        )
<span class="line-number">245</span>
<span class="line-number">246</span>        # Filter structs
<span class="line-number">247</span>        if &quot;structs&quot; in self.element_filters:
<span class="line-number">248</span>            filtered_model.structs = self._filter_dict(
<span class="line-number">249</span>                filtered_model.structs, self.element_filters[&quot;structs&quot;]
<span class="line-number">250</span>            )
<span class="line-number">251</span>
<span class="line-number">252</span>        # Filter enums
<span class="line-number">253</span>        if &quot;enums&quot; in self.element_filters:
<span class="line-number">254</span>            filtered_model.enums = self._filter_dict(
<span class="line-number">255</span>                filtered_model.enums, self.element_filters[&quot;enums&quot;]
<span class="line-number">256</span>            )
<span class="line-number">257</span>
<span class="line-number">258</span>        # Filter unions
<span class="line-number">259</span>        if &quot;unions&quot; in self.element_filters:
<span class="line-number">260</span><span class="uncovered">            filtered_model.unions = self._filter_dict(</span>
<span class="line-number">261</span>                filtered_model.unions, self.element_filters[&quot;unions&quot;]
<span class="line-number">262</span>            )
<span class="line-number">263</span>
<span class="line-number">264</span>        # Filter functions
<span class="line-number">265</span>        if &quot;functions&quot; in self.element_filters:
<span class="line-number">266</span>            filtered_model.functions = self._filter_list(
<span class="line-number">267</span>                filtered_model.functions,
<span class="line-number">268</span>                self.element_filters[&quot;functions&quot;],
<span class="line-number">269</span>                key=lambda f: f.name,
<span class="line-number">270</span>            )
<span class="line-number">271</span>
<span class="line-number">272</span>        # Filter globals
<span class="line-number">273</span>        if &quot;globals&quot; in self.element_filters:
<span class="line-number">274</span>            filtered_model.globals = self._filter_list(
<span class="line-number">275</span>                filtered_model.globals,
<span class="line-number">276</span>                self.element_filters[&quot;globals&quot;],
<span class="line-number">277</span>                key=lambda g: g.name,
<span class="line-number">278</span>            )
<span class="line-number">279</span>
<span class="line-number">280</span>        # Filter macros
<span class="line-number">281</span>        if &quot;macros&quot; in self.element_filters:
<span class="line-number">282</span>            filtered_model.macros = self._filter_list(
<span class="line-number">283</span>                filtered_model.macros, self.element_filters[&quot;macros&quot;]
<span class="line-number">284</span>            )
<span class="line-number">285</span>
<span class="line-number">286</span>        # Filter aliases
<span class="line-number">287</span>        if &quot;aliases&quot; in self.element_filters:
<span class="line-number">288</span>            filtered_model.aliases = self._filter_dict(
<span class="line-number">289</span>                filtered_model.aliases, self.element_filters[&quot;aliases&quot;]
<span class="line-number">290</span>            )
<span class="line-number">291</span>
<span class="line-number">292</span>        return filtered_model
<span class="line-number">293</span>
<span class="line-number">294</span>    def _filter_dict(self, items: dict, filters: dict) -&gt; dict:
<span class="line-number">295</span>        &quot;&quot;&quot;Filter dictionary items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">296</span>        include_patterns = [
<span class="line-number">297</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">298</span>        ]
<span class="line-number">299</span>        exclude_patterns = [
<span class="line-number">300</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">301</span>        ]
<span class="line-number">302</span>
<span class="line-number">303</span>        filtered_items = {}
<span class="line-number">304</span>
<span class="line-number">305</span>        for name, item in items.items():
<span class="line-number">306</span>            # Check include patterns
<span class="line-number">307</span>            if include_patterns:
<span class="line-number">308</span>                should_include = False
<span class="line-number">309</span>                for pattern in include_patterns:
<span class="line-number">310</span>                    if pattern.search(name):
<span class="line-number">311</span>                        should_include = True
<span class="line-number">312</span>                        break
<span class="line-number">313</span>                if not should_include:
<span class="line-number">314</span>                    continue
<span class="line-number">315</span>
<span class="line-number">316</span>            # Check exclude patterns
<span class="line-number">317</span>            should_exclude = False
<span class="line-number">318</span>            for pattern in exclude_patterns:
<span class="line-number">319</span>                if pattern.search(name):
<span class="line-number">320</span>                    should_exclude = True
<span class="line-number">321</span>                    break
<span class="line-number">322</span>            if should_exclude:
<span class="line-number">323</span>                continue
<span class="line-number">324</span>
<span class="line-number">325</span>            filtered_items[name] = item
<span class="line-number">326</span>
<span class="line-number">327</span>        return filtered_items
<span class="line-number">328</span>
<span class="line-number">329</span>    def _filter_list(self, items: list, filters: dict, key=None) -&gt; list:
<span class="line-number">330</span>        &quot;&quot;&quot;Filter list items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">331</span>        include_patterns = [
<span class="line-number">332</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">333</span>        ]
<span class="line-number">334</span>        exclude_patterns = [
<span class="line-number">335</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">336</span>        ]
<span class="line-number">337</span>
<span class="line-number">338</span>        filtered_items = []
<span class="line-number">339</span>
<span class="line-number">340</span>        for item in items:
<span class="line-number">341</span>            # Get the name to check against patterns
<span class="line-number">342</span>            if key:
<span class="line-number">343</span>                name = key(item)
<span class="line-number">344</span>            else:
<span class="line-number">345</span>                name = str(item)
<span class="line-number">346</span>
<span class="line-number">347</span>            # Check include patterns
<span class="line-number">348</span>            if include_patterns:
<span class="line-number">349</span>                should_include = False
<span class="line-number">350</span>                for pattern in include_patterns:
<span class="line-number">351</span>                    if pattern.search(name):
<span class="line-number">352</span>                        should_include = True
<span class="line-number">353</span>                        break
<span class="line-number">354</span>                if not should_include:
<span class="line-number">355</span>                    continue
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: __post_init__ (lines 102-405)</h4>
<pre>
<span class="line-number">102</span>    def __post_init__(self):
<span class="line-number">103</span>        &quot;&quot;&quot;Compile regex patterns after initialization&quot;&quot;&quot;
<span class="line-number">104</span><span class="uncovered">        self._compile_patterns()</span>
<span class="line-number">105</span>
<span class="line-number">106</span>    def _compile_patterns(self):
<span class="line-number">107</span>        &quot;&quot;&quot;Compile regex patterns for filtering&quot;&quot;&quot;
<span class="line-number">108</span>        # Compile file filter patterns with error handling
<span class="line-number">109</span>        self.file_include_patterns = []
<span class="line-number">110</span>        for pattern in self.file_filters.get(&quot;include&quot;, []):
<span class="line-number">111</span>            try:
<span class="line-number">112</span>                self.file_include_patterns.append(re.compile(pattern))
<span class="line-number">113</span>            except re.error as e:
<span class="line-number">114</span>                self.logger.warning(&quot;Invalid include pattern &#x27;%s&#x27;: %s&quot;, pattern, e)
<span class="line-number">115</span>                # Skip invalid patterns
<span class="line-number">116</span>
<span class="line-number">117</span>        self.file_exclude_patterns = []
<span class="line-number">118</span>        for pattern in self.file_filters.get(&quot;exclude&quot;, []):
<span class="line-number">119</span>            try:
<span class="line-number">120</span>                self.file_exclude_patterns.append(re.compile(pattern))
<span class="line-number">121</span>            except re.error as e:
<span class="line-number">122</span>                self.logger.warning(&quot;Invalid exclude pattern &#x27;%s&#x27;: %s&quot;, pattern, e)
<span class="line-number">123</span>                # Skip invalid patterns
<span class="line-number">124</span>
<span class="line-number">125</span>        # Compile element filter patterns with error handling
<span class="line-number">126</span>        self.element_include_patterns = {}
<span class="line-number">127</span>        self.element_exclude_patterns = {}
<span class="line-number">128</span>
<span class="line-number">129</span>        for element_type, filters in self.element_filters.items():
<span class="line-number">130</span>            self.element_include_patterns[element_type] = []
<span class="line-number">131</span>            for pattern in filters.get(&quot;include&quot;, []):
<span class="line-number">132</span>                try:
<span class="line-number">133</span>                    self.element_include_patterns[element_type].append(
<span class="line-number">134</span>                        re.compile(pattern)
<span class="line-number">135</span>                    )
<span class="line-number">136</span>                except re.error as e:
<span class="line-number">137</span>                    self.logger.warning(
<span class="line-number">138</span>                        &quot;Invalid %s include pattern &#x27;%s&#x27;: %s&quot;, element_type, pattern, e
<span class="line-number">139</span>                    )
<span class="line-number">140</span>                    # Skip invalid patterns
<span class="line-number">141</span>
<span class="line-number">142</span>            self.element_exclude_patterns[element_type] = []
<span class="line-number">143</span>            for pattern in filters.get(&quot;exclude&quot;, []):
<span class="line-number">144</span>                try:
<span class="line-number">145</span>                    self.element_exclude_patterns[element_type].append(
<span class="line-number">146</span>                        re.compile(pattern)
<span class="line-number">147</span>                    )
<span class="line-number">148</span><span class="uncovered">                except re.error as e:</span>
<span class="line-number">149</span><span class="uncovered">                    self.logger.warning(</span>
<span class="line-number">150</span>                        &quot;Invalid %s exclude pattern &#x27;%s&#x27;: %s&quot;, element_type, pattern, e
<span class="line-number">151</span>                    )
<span class="line-number">152</span>                    # Skip invalid patterns
<span class="line-number">153</span>
<span class="line-number">154</span>    @classmethod
<span class="line-number">155</span>    def load(cls, config_file: str) -&gt; &quot;Config&quot;:
<span class="line-number">156</span>        &quot;&quot;&quot;Load configuration from JSON file&quot;&quot;&quot;
<span class="line-number">157</span>        if not Path(config_file).exists():
<span class="line-number">158</span><span class="uncovered">            raise FileNotFoundError(f&quot;Configuration file not found: {config_file}&quot;)</span>
<span class="line-number">159</span>
<span class="line-number">160</span>        try:
<span class="line-number">161</span>            with open(config_file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">162</span>                data = json.load(f)
<span class="line-number">163</span>
<span class="line-number">164</span>            # Handle backward compatibility: project_roots -&gt; source_folders
<span class="line-number">165</span>            if &quot;project_roots&quot; in data and &quot;source_folders&quot; not in data:
<span class="line-number">166</span><span class="uncovered">                data[&quot;source_folders&quot;] = data.pop(&quot;project_roots&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>            # Validate required fields
<span class="line-number">169</span>            if &quot;source_folders&quot; not in data:
<span class="line-number">170</span><span class="uncovered">                raise ValueError(&quot;Configuration must contain &#x27;source_folders&#x27; field&quot;)</span>
<span class="line-number">171</span>
<span class="line-number">172</span>            if not isinstance(data[&quot;source_folders&quot;], list):
<span class="line-number">173</span>                raise ValueError(&quot;&#x27;source_folders&#x27; must be a list&quot;)
<span class="line-number">174</span>
<span class="line-number">175</span>            return cls(**data)
<span class="line-number">176</span>
<span class="line-number">177</span>        except Exception as e:
<span class="line-number">178</span>            raise ValueError(
<span class="line-number">179</span>                f&quot;Failed to load configuration from {config_file}: {e}&quot;
<span class="line-number">180</span>            ) from e
<span class="line-number">181</span>
<span class="line-number">182</span>    def save(self, config_file: str) -&gt; None:
<span class="line-number">183</span>        &quot;&quot;&quot;Save configuration to JSON file&quot;&quot;&quot;
<span class="line-number">184</span>        data = {
<span class="line-number">185</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">186</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">187</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">188</span>            &quot;model_output_path&quot;: self.model_output_path,
<span class="line-number">189</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">190</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">191</span>            &quot;file_filters&quot;: self.file_filters,
<span class="line-number">192</span>            &quot;element_filters&quot;: self.element_filters,
<span class="line-number">193</span>            &quot;transformations&quot;: self.transformations,
<span class="line-number">194</span>        }
<span class="line-number">195</span>
<span class="line-number">196</span>        try:
<span class="line-number">197</span>            with open(config_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">198</span>                json.dump(data, f, indent=2, ensure_ascii=False)
<span class="line-number">199</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">200</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number">201</span>                f&quot;Failed to save configuration to {config_file}: {e}&quot;
<span class="line-number">202</span>            ) from e
<span class="line-number">203</span>
<span class="line-number">204</span>    def has_filters(self) -&gt; bool:
<span class="line-number">205</span>        &quot;&quot;&quot;Check if configuration has any filters defined&quot;&quot;&quot;
<span class="line-number">206</span>        return bool(self.file_filters or self.element_filters)
<span class="line-number">207</span>
<span class="line-number">208</span>    def _should_include_file(self, file_path: str) -&gt; bool:
<span class="line-number">209</span>        &quot;&quot;&quot;Check if a file should be included based on filters&quot;&quot;&quot;
<span class="line-number">210</span>        # Check exclude patterns first
<span class="line-number">211</span>        for pattern in self.file_exclude_patterns:
<span class="line-number">212</span>            if pattern.search(file_path):
<span class="line-number">213</span>                return False
<span class="line-number">214</span>
<span class="line-number">215</span>        # If no include patterns, include all files (after exclusions)
<span class="line-number">216</span>        if not self.file_include_patterns:
<span class="line-number">217</span>            return True
<span class="line-number">218</span>
<span class="line-number">219</span>        # Check include patterns - file must match at least one
<span class="line-number">220</span>        for pattern in self.file_include_patterns:
<span class="line-number">221</span>            if pattern.search(file_path):
<span class="line-number">222</span>                return True
<span class="line-number">223</span>
<span class="line-number">224</span>        return False
<span class="line-number">225</span>
<span class="line-number">226</span>    def _apply_element_filters(self, file_model) -&gt; Any:
<span class="line-number">227</span>        &quot;&quot;&quot;Apply element filters to a file model&quot;&quot;&quot;
<span class="line-number">228</span>
<span class="line-number">229</span>        # Create a copy of the file model to avoid modifying the original
<span class="line-number">230</span>        filtered_model = FileModel(
<span class="line-number">231</span>            file_path=file_model.file_path,
<span class="line-number">232</span>            relative_path=file_model.relative_path,
<span class="line-number">233</span>            project_root=file_model.project_root,
<span class="line-number">234</span>            encoding_used=file_model.encoding_used,
<span class="line-number">235</span>            structs=file_model.structs.copy(),
<span class="line-number">236</span>            enums=file_model.enums.copy(),
<span class="line-number">237</span>            unions=file_model.unions.copy(),
<span class="line-number">238</span>            functions=file_model.functions.copy(),
<span class="line-number">239</span>            globals=file_model.globals.copy(),
<span class="line-number">240</span>            includes=file_model.includes.copy(),
<span class="line-number">241</span>            macros=file_model.macros.copy(),
<span class="line-number">242</span>            aliases=file_model.aliases.copy(),
<span class="line-number">243</span>            # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">244</span>        )
<span class="line-number">245</span>
<span class="line-number">246</span>        # Filter structs
<span class="line-number">247</span>        if &quot;structs&quot; in self.element_filters:
<span class="line-number">248</span>            filtered_model.structs = self._filter_dict(
<span class="line-number">249</span>                filtered_model.structs, self.element_filters[&quot;structs&quot;]
<span class="line-number">250</span>            )
<span class="line-number">251</span>
<span class="line-number">252</span>        # Filter enums
<span class="line-number">253</span>        if &quot;enums&quot; in self.element_filters:
<span class="line-number">254</span>            filtered_model.enums = self._filter_dict(
<span class="line-number">255</span>                filtered_model.enums, self.element_filters[&quot;enums&quot;]
<span class="line-number">256</span>            )
<span class="line-number">257</span>
<span class="line-number">258</span>        # Filter unions
<span class="line-number">259</span>        if &quot;unions&quot; in self.element_filters:
<span class="line-number">260</span><span class="uncovered">            filtered_model.unions = self._filter_dict(</span>
<span class="line-number">261</span>                filtered_model.unions, self.element_filters[&quot;unions&quot;]
<span class="line-number">262</span>            )
<span class="line-number">263</span>
<span class="line-number">264</span>        # Filter functions
<span class="line-number">265</span>        if &quot;functions&quot; in self.element_filters:
<span class="line-number">266</span>            filtered_model.functions = self._filter_list(
<span class="line-number">267</span>                filtered_model.functions,
<span class="line-number">268</span>                self.element_filters[&quot;functions&quot;],
<span class="line-number">269</span>                key=lambda f: f.name,
<span class="line-number">270</span>            )
<span class="line-number">271</span>
<span class="line-number">272</span>        # Filter globals
<span class="line-number">273</span>        if &quot;globals&quot; in self.element_filters:
<span class="line-number">274</span>            filtered_model.globals = self._filter_list(
<span class="line-number">275</span>                filtered_model.globals,
<span class="line-number">276</span>                self.element_filters[&quot;globals&quot;],
<span class="line-number">277</span>                key=lambda g: g.name,
<span class="line-number">278</span>            )
<span class="line-number">279</span>
<span class="line-number">280</span>        # Filter macros
<span class="line-number">281</span>        if &quot;macros&quot; in self.element_filters:
<span class="line-number">282</span>            filtered_model.macros = self._filter_list(
<span class="line-number">283</span>                filtered_model.macros, self.element_filters[&quot;macros&quot;]
<span class="line-number">284</span>            )
<span class="line-number">285</span>
<span class="line-number">286</span>        # Filter aliases
<span class="line-number">287</span>        if &quot;aliases&quot; in self.element_filters:
<span class="line-number">288</span>            filtered_model.aliases = self._filter_dict(
<span class="line-number">289</span>                filtered_model.aliases, self.element_filters[&quot;aliases&quot;]
<span class="line-number">290</span>            )
<span class="line-number">291</span>
<span class="line-number">292</span>        return filtered_model
<span class="line-number">293</span>
<span class="line-number">294</span>    def _filter_dict(self, items: dict, filters: dict) -&gt; dict:
<span class="line-number">295</span>        &quot;&quot;&quot;Filter dictionary items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">296</span>        include_patterns = [
<span class="line-number">297</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">298</span>        ]
<span class="line-number">299</span>        exclude_patterns = [
<span class="line-number">300</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">301</span>        ]
<span class="line-number">302</span>
<span class="line-number">303</span>        filtered_items = {}
<span class="line-number">304</span>
<span class="line-number">305</span>        for name, item in items.items():
<span class="line-number">306</span>            # Check include patterns
<span class="line-number">307</span>            if include_patterns:
<span class="line-number">308</span>                should_include = False
<span class="line-number">309</span>                for pattern in include_patterns:
<span class="line-number">310</span>                    if pattern.search(name):
<span class="line-number">311</span>                        should_include = True
<span class="line-number">312</span>                        break
<span class="line-number">313</span>                if not should_include:
<span class="line-number">314</span>                    continue
<span class="line-number">315</span>
<span class="line-number">316</span>            # Check exclude patterns
<span class="line-number">317</span>            should_exclude = False
<span class="line-number">318</span>            for pattern in exclude_patterns:
<span class="line-number">319</span>                if pattern.search(name):
<span class="line-number">320</span>                    should_exclude = True
<span class="line-number">321</span>                    break
<span class="line-number">322</span>            if should_exclude:
<span class="line-number">323</span>                continue
<span class="line-number">324</span>
<span class="line-number">325</span>            filtered_items[name] = item
<span class="line-number">326</span>
<span class="line-number">327</span>        return filtered_items
<span class="line-number">328</span>
<span class="line-number">329</span>    def _filter_list(self, items: list, filters: dict, key=None) -&gt; list:
<span class="line-number">330</span>        &quot;&quot;&quot;Filter list items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">331</span>        include_patterns = [
<span class="line-number">332</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">333</span>        ]
<span class="line-number">334</span>        exclude_patterns = [
<span class="line-number">335</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">336</span>        ]
<span class="line-number">337</span>
<span class="line-number">338</span>        filtered_items = []
<span class="line-number">339</span>
<span class="line-number">340</span>        for item in items:
<span class="line-number">341</span>            # Get the name to check against patterns
<span class="line-number">342</span>            if key:
<span class="line-number">343</span>                name = key(item)
<span class="line-number">344</span>            else:
<span class="line-number">345</span>                name = str(item)
<span class="line-number">346</span>
<span class="line-number">347</span>            # Check include patterns
<span class="line-number">348</span>            if include_patterns:
<span class="line-number">349</span>                should_include = False
<span class="line-number">350</span>                for pattern in include_patterns:
<span class="line-number">351</span>                    if pattern.search(name):
<span class="line-number">352</span>                        should_include = True
<span class="line-number">353</span>                        break
<span class="line-number">354</span>                if not should_include:
<span class="line-number">355</span>                    continue
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: _compile_patterns (lines 106-153)</h4>
<pre>
<span class="line-number">106</span>    def _compile_patterns(self):
<span class="line-number">107</span>        &quot;&quot;&quot;Compile regex patterns for filtering&quot;&quot;&quot;
<span class="line-number">108</span>        # Compile file filter patterns with error handling
<span class="line-number">109</span>        self.file_include_patterns = []
<span class="line-number">110</span>        for pattern in self.file_filters.get(&quot;include&quot;, []):
<span class="line-number">111</span>            try:
<span class="line-number">112</span>                self.file_include_patterns.append(re.compile(pattern))
<span class="line-number">113</span>            except re.error as e:
<span class="line-number">114</span>                self.logger.warning(&quot;Invalid include pattern &#x27;%s&#x27;: %s&quot;, pattern, e)
<span class="line-number">115</span>                # Skip invalid patterns
<span class="line-number">116</span>
<span class="line-number">117</span>        self.file_exclude_patterns = []
<span class="line-number">118</span>        for pattern in self.file_filters.get(&quot;exclude&quot;, []):
<span class="line-number">119</span>            try:
<span class="line-number">120</span>                self.file_exclude_patterns.append(re.compile(pattern))
<span class="line-number">121</span>            except re.error as e:
<span class="line-number">122</span>                self.logger.warning(&quot;Invalid exclude pattern &#x27;%s&#x27;: %s&quot;, pattern, e)
<span class="line-number">123</span>                # Skip invalid patterns
<span class="line-number">124</span>
<span class="line-number">125</span>        # Compile element filter patterns with error handling
<span class="line-number">126</span>        self.element_include_patterns = {}
<span class="line-number">127</span>        self.element_exclude_patterns = {}
<span class="line-number">128</span>
<span class="line-number">129</span>        for element_type, filters in self.element_filters.items():
<span class="line-number">130</span>            self.element_include_patterns[element_type] = []
<span class="line-number">131</span>            for pattern in filters.get(&quot;include&quot;, []):
<span class="line-number">132</span>                try:
<span class="line-number">133</span>                    self.element_include_patterns[element_type].append(
<span class="line-number">134</span>                        re.compile(pattern)
<span class="line-number">135</span>                    )
<span class="line-number">136</span>                except re.error as e:
<span class="line-number">137</span>                    self.logger.warning(
<span class="line-number">138</span>                        &quot;Invalid %s include pattern &#x27;%s&#x27;: %s&quot;, element_type, pattern, e
<span class="line-number">139</span>                    )
<span class="line-number">140</span>                    # Skip invalid patterns
<span class="line-number">141</span>
<span class="line-number">142</span>            self.element_exclude_patterns[element_type] = []
<span class="line-number">143</span>            for pattern in filters.get(&quot;exclude&quot;, []):
<span class="line-number">144</span>                try:
<span class="line-number">145</span>                    self.element_exclude_patterns[element_type].append(
<span class="line-number">146</span>                        re.compile(pattern)
<span class="line-number">147</span>                    )
<span class="line-number">148</span><span class="uncovered">                except re.error as e:</span>
<span class="line-number">149</span><span class="uncovered">                    self.logger.warning(</span>
<span class="line-number">150</span>                        &quot;Invalid %s exclude pattern &#x27;%s&#x27;: %s&quot;, element_type, pattern, e
<span class="line-number">151</span>                    )
<span class="line-number">152</span>                    # Skip invalid patterns
<span class="line-number">153</span>
</pre>
<h4>Function: load (lines 155-405)</h4>
<pre>
<span class="line-number">155</span>    def load(cls, config_file: str) -&gt; &quot;Config&quot;:
<span class="line-number">156</span>        &quot;&quot;&quot;Load configuration from JSON file&quot;&quot;&quot;
<span class="line-number">157</span>        if not Path(config_file).exists():
<span class="line-number">158</span><span class="uncovered">            raise FileNotFoundError(f&quot;Configuration file not found: {config_file}&quot;)</span>
<span class="line-number">159</span>
<span class="line-number">160</span>        try:
<span class="line-number">161</span>            with open(config_file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">162</span>                data = json.load(f)
<span class="line-number">163</span>
<span class="line-number">164</span>            # Handle backward compatibility: project_roots -&gt; source_folders
<span class="line-number">165</span>            if &quot;project_roots&quot; in data and &quot;source_folders&quot; not in data:
<span class="line-number">166</span><span class="uncovered">                data[&quot;source_folders&quot;] = data.pop(&quot;project_roots&quot;)</span>
<span class="line-number">167</span>
<span class="line-number">168</span>            # Validate required fields
<span class="line-number">169</span>            if &quot;source_folders&quot; not in data:
<span class="line-number">170</span><span class="uncovered">                raise ValueError(&quot;Configuration must contain &#x27;source_folders&#x27; field&quot;)</span>
<span class="line-number">171</span>
<span class="line-number">172</span>            if not isinstance(data[&quot;source_folders&quot;], list):
<span class="line-number">173</span>                raise ValueError(&quot;&#x27;source_folders&#x27; must be a list&quot;)
<span class="line-number">174</span>
<span class="line-number">175</span>            return cls(**data)
<span class="line-number">176</span>
<span class="line-number">177</span>        except Exception as e:
<span class="line-number">178</span>            raise ValueError(
<span class="line-number">179</span>                f&quot;Failed to load configuration from {config_file}: {e}&quot;
<span class="line-number">180</span>            ) from e
<span class="line-number">181</span>
<span class="line-number">182</span>    def save(self, config_file: str) -&gt; None:
<span class="line-number">183</span>        &quot;&quot;&quot;Save configuration to JSON file&quot;&quot;&quot;
<span class="line-number">184</span>        data = {
<span class="line-number">185</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">186</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">187</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">188</span>            &quot;model_output_path&quot;: self.model_output_path,
<span class="line-number">189</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">190</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">191</span>            &quot;file_filters&quot;: self.file_filters,
<span class="line-number">192</span>            &quot;element_filters&quot;: self.element_filters,
<span class="line-number">193</span>            &quot;transformations&quot;: self.transformations,
<span class="line-number">194</span>        }
<span class="line-number">195</span>
<span class="line-number">196</span>        try:
<span class="line-number">197</span>            with open(config_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">198</span>                json.dump(data, f, indent=2, ensure_ascii=False)
<span class="line-number">199</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">200</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number">201</span>                f&quot;Failed to save configuration to {config_file}: {e}&quot;
<span class="line-number">202</span>            ) from e
<span class="line-number">203</span>
<span class="line-number">204</span>    def has_filters(self) -&gt; bool:
<span class="line-number">205</span>        &quot;&quot;&quot;Check if configuration has any filters defined&quot;&quot;&quot;
<span class="line-number">206</span>        return bool(self.file_filters or self.element_filters)
<span class="line-number">207</span>
<span class="line-number">208</span>    def _should_include_file(self, file_path: str) -&gt; bool:
<span class="line-number">209</span>        &quot;&quot;&quot;Check if a file should be included based on filters&quot;&quot;&quot;
<span class="line-number">210</span>        # Check exclude patterns first
<span class="line-number">211</span>        for pattern in self.file_exclude_patterns:
<span class="line-number">212</span>            if pattern.search(file_path):
<span class="line-number">213</span>                return False
<span class="line-number">214</span>
<span class="line-number">215</span>        # If no include patterns, include all files (after exclusions)
<span class="line-number">216</span>        if not self.file_include_patterns:
<span class="line-number">217</span>            return True
<span class="line-number">218</span>
<span class="line-number">219</span>        # Check include patterns - file must match at least one
<span class="line-number">220</span>        for pattern in self.file_include_patterns:
<span class="line-number">221</span>            if pattern.search(file_path):
<span class="line-number">222</span>                return True
<span class="line-number">223</span>
<span class="line-number">224</span>        return False
<span class="line-number">225</span>
<span class="line-number">226</span>    def _apply_element_filters(self, file_model) -&gt; Any:
<span class="line-number">227</span>        &quot;&quot;&quot;Apply element filters to a file model&quot;&quot;&quot;
<span class="line-number">228</span>
<span class="line-number">229</span>        # Create a copy of the file model to avoid modifying the original
<span class="line-number">230</span>        filtered_model = FileModel(
<span class="line-number">231</span>            file_path=file_model.file_path,
<span class="line-number">232</span>            relative_path=file_model.relative_path,
<span class="line-number">233</span>            project_root=file_model.project_root,
<span class="line-number">234</span>            encoding_used=file_model.encoding_used,
<span class="line-number">235</span>            structs=file_model.structs.copy(),
<span class="line-number">236</span>            enums=file_model.enums.copy(),
<span class="line-number">237</span>            unions=file_model.unions.copy(),
<span class="line-number">238</span>            functions=file_model.functions.copy(),
<span class="line-number">239</span>            globals=file_model.globals.copy(),
<span class="line-number">240</span>            includes=file_model.includes.copy(),
<span class="line-number">241</span>            macros=file_model.macros.copy(),
<span class="line-number">242</span>            aliases=file_model.aliases.copy(),
<span class="line-number">243</span>            # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">244</span>        )
<span class="line-number">245</span>
<span class="line-number">246</span>        # Filter structs
<span class="line-number">247</span>        if &quot;structs&quot; in self.element_filters:
<span class="line-number">248</span>            filtered_model.structs = self._filter_dict(
<span class="line-number">249</span>                filtered_model.structs, self.element_filters[&quot;structs&quot;]
<span class="line-number">250</span>            )
<span class="line-number">251</span>
<span class="line-number">252</span>        # Filter enums
<span class="line-number">253</span>        if &quot;enums&quot; in self.element_filters:
<span class="line-number">254</span>            filtered_model.enums = self._filter_dict(
<span class="line-number">255</span>                filtered_model.enums, self.element_filters[&quot;enums&quot;]
<span class="line-number">256</span>            )
<span class="line-number">257</span>
<span class="line-number">258</span>        # Filter unions
<span class="line-number">259</span>        if &quot;unions&quot; in self.element_filters:
<span class="line-number">260</span><span class="uncovered">            filtered_model.unions = self._filter_dict(</span>
<span class="line-number">261</span>                filtered_model.unions, self.element_filters[&quot;unions&quot;]
<span class="line-number">262</span>            )
<span class="line-number">263</span>
<span class="line-number">264</span>        # Filter functions
<span class="line-number">265</span>        if &quot;functions&quot; in self.element_filters:
<span class="line-number">266</span>            filtered_model.functions = self._filter_list(
<span class="line-number">267</span>                filtered_model.functions,
<span class="line-number">268</span>                self.element_filters[&quot;functions&quot;],
<span class="line-number">269</span>                key=lambda f: f.name,
<span class="line-number">270</span>            )
<span class="line-number">271</span>
<span class="line-number">272</span>        # Filter globals
<span class="line-number">273</span>        if &quot;globals&quot; in self.element_filters:
<span class="line-number">274</span>            filtered_model.globals = self._filter_list(
<span class="line-number">275</span>                filtered_model.globals,
<span class="line-number">276</span>                self.element_filters[&quot;globals&quot;],
<span class="line-number">277</span>                key=lambda g: g.name,
<span class="line-number">278</span>            )
<span class="line-number">279</span>
<span class="line-number">280</span>        # Filter macros
<span class="line-number">281</span>        if &quot;macros&quot; in self.element_filters:
<span class="line-number">282</span>            filtered_model.macros = self._filter_list(
<span class="line-number">283</span>                filtered_model.macros, self.element_filters[&quot;macros&quot;]
<span class="line-number">284</span>            )
<span class="line-number">285</span>
<span class="line-number">286</span>        # Filter aliases
<span class="line-number">287</span>        if &quot;aliases&quot; in self.element_filters:
<span class="line-number">288</span>            filtered_model.aliases = self._filter_dict(
<span class="line-number">289</span>                filtered_model.aliases, self.element_filters[&quot;aliases&quot;]
<span class="line-number">290</span>            )
<span class="line-number">291</span>
<span class="line-number">292</span>        return filtered_model
<span class="line-number">293</span>
<span class="line-number">294</span>    def _filter_dict(self, items: dict, filters: dict) -&gt; dict:
<span class="line-number">295</span>        &quot;&quot;&quot;Filter dictionary items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">296</span>        include_patterns = [
<span class="line-number">297</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">298</span>        ]
<span class="line-number">299</span>        exclude_patterns = [
<span class="line-number">300</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">301</span>        ]
<span class="line-number">302</span>
<span class="line-number">303</span>        filtered_items = {}
<span class="line-number">304</span>
<span class="line-number">305</span>        for name, item in items.items():
<span class="line-number">306</span>            # Check include patterns
<span class="line-number">307</span>            if include_patterns:
<span class="line-number">308</span>                should_include = False
<span class="line-number">309</span>                for pattern in include_patterns:
<span class="line-number">310</span>                    if pattern.search(name):
<span class="line-number">311</span>                        should_include = True
<span class="line-number">312</span>                        break
<span class="line-number">313</span>                if not should_include:
<span class="line-number">314</span>                    continue
<span class="line-number">315</span>
<span class="line-number">316</span>            # Check exclude patterns
<span class="line-number">317</span>            should_exclude = False
<span class="line-number">318</span>            for pattern in exclude_patterns:
<span class="line-number">319</span>                if pattern.search(name):
<span class="line-number">320</span>                    should_exclude = True
<span class="line-number">321</span>                    break
<span class="line-number">322</span>            if should_exclude:
<span class="line-number">323</span>                continue
<span class="line-number">324</span>
<span class="line-number">325</span>            filtered_items[name] = item
<span class="line-number">326</span>
<span class="line-number">327</span>        return filtered_items
<span class="line-number">328</span>
<span class="line-number">329</span>    def _filter_list(self, items: list, filters: dict, key=None) -&gt; list:
<span class="line-number">330</span>        &quot;&quot;&quot;Filter list items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">331</span>        include_patterns = [
<span class="line-number">332</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">333</span>        ]
<span class="line-number">334</span>        exclude_patterns = [
<span class="line-number">335</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">336</span>        ]
<span class="line-number">337</span>
<span class="line-number">338</span>        filtered_items = []
<span class="line-number">339</span>
<span class="line-number">340</span>        for item in items:
<span class="line-number">341</span>            # Get the name to check against patterns
<span class="line-number">342</span>            if key:
<span class="line-number">343</span>                name = key(item)
<span class="line-number">344</span>            else:
<span class="line-number">345</span>                name = str(item)
<span class="line-number">346</span>
<span class="line-number">347</span>            # Check include patterns
<span class="line-number">348</span>            if include_patterns:
<span class="line-number">349</span>                should_include = False
<span class="line-number">350</span>                for pattern in include_patterns:
<span class="line-number">351</span>                    if pattern.search(name):
<span class="line-number">352</span>                        should_include = True
<span class="line-number">353</span>                        break
<span class="line-number">354</span>                if not should_include:
<span class="line-number">355</span>                    continue
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: save (lines 182-405)</h4>
<pre>
<span class="line-number">182</span>    def save(self, config_file: str) -&gt; None:
<span class="line-number">183</span>        &quot;&quot;&quot;Save configuration to JSON file&quot;&quot;&quot;
<span class="line-number">184</span>        data = {
<span class="line-number">185</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">186</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">187</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">188</span>            &quot;model_output_path&quot;: self.model_output_path,
<span class="line-number">189</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">190</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">191</span>            &quot;file_filters&quot;: self.file_filters,
<span class="line-number">192</span>            &quot;element_filters&quot;: self.element_filters,
<span class="line-number">193</span>            &quot;transformations&quot;: self.transformations,
<span class="line-number">194</span>        }
<span class="line-number">195</span>
<span class="line-number">196</span>        try:
<span class="line-number">197</span>            with open(config_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">198</span>                json.dump(data, f, indent=2, ensure_ascii=False)
<span class="line-number">199</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">200</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number">201</span>                f&quot;Failed to save configuration to {config_file}: {e}&quot;
<span class="line-number">202</span>            ) from e
<span class="line-number">203</span>
<span class="line-number">204</span>    def has_filters(self) -&gt; bool:
<span class="line-number">205</span>        &quot;&quot;&quot;Check if configuration has any filters defined&quot;&quot;&quot;
<span class="line-number">206</span>        return bool(self.file_filters or self.element_filters)
<span class="line-number">207</span>
<span class="line-number">208</span>    def _should_include_file(self, file_path: str) -&gt; bool:
<span class="line-number">209</span>        &quot;&quot;&quot;Check if a file should be included based on filters&quot;&quot;&quot;
<span class="line-number">210</span>        # Check exclude patterns first
<span class="line-number">211</span>        for pattern in self.file_exclude_patterns:
<span class="line-number">212</span>            if pattern.search(file_path):
<span class="line-number">213</span>                return False
<span class="line-number">214</span>
<span class="line-number">215</span>        # If no include patterns, include all files (after exclusions)
<span class="line-number">216</span>        if not self.file_include_patterns:
<span class="line-number">217</span>            return True
<span class="line-number">218</span>
<span class="line-number">219</span>        # Check include patterns - file must match at least one
<span class="line-number">220</span>        for pattern in self.file_include_patterns:
<span class="line-number">221</span>            if pattern.search(file_path):
<span class="line-number">222</span>                return True
<span class="line-number">223</span>
<span class="line-number">224</span>        return False
<span class="line-number">225</span>
<span class="line-number">226</span>    def _apply_element_filters(self, file_model) -&gt; Any:
<span class="line-number">227</span>        &quot;&quot;&quot;Apply element filters to a file model&quot;&quot;&quot;
<span class="line-number">228</span>
<span class="line-number">229</span>        # Create a copy of the file model to avoid modifying the original
<span class="line-number">230</span>        filtered_model = FileModel(
<span class="line-number">231</span>            file_path=file_model.file_path,
<span class="line-number">232</span>            relative_path=file_model.relative_path,
<span class="line-number">233</span>            project_root=file_model.project_root,
<span class="line-number">234</span>            encoding_used=file_model.encoding_used,
<span class="line-number">235</span>            structs=file_model.structs.copy(),
<span class="line-number">236</span>            enums=file_model.enums.copy(),
<span class="line-number">237</span>            unions=file_model.unions.copy(),
<span class="line-number">238</span>            functions=file_model.functions.copy(),
<span class="line-number">239</span>            globals=file_model.globals.copy(),
<span class="line-number">240</span>            includes=file_model.includes.copy(),
<span class="line-number">241</span>            macros=file_model.macros.copy(),
<span class="line-number">242</span>            aliases=file_model.aliases.copy(),
<span class="line-number">243</span>            # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">244</span>        )
<span class="line-number">245</span>
<span class="line-number">246</span>        # Filter structs
<span class="line-number">247</span>        if &quot;structs&quot; in self.element_filters:
<span class="line-number">248</span>            filtered_model.structs = self._filter_dict(
<span class="line-number">249</span>                filtered_model.structs, self.element_filters[&quot;structs&quot;]
<span class="line-number">250</span>            )
<span class="line-number">251</span>
<span class="line-number">252</span>        # Filter enums
<span class="line-number">253</span>        if &quot;enums&quot; in self.element_filters:
<span class="line-number">254</span>            filtered_model.enums = self._filter_dict(
<span class="line-number">255</span>                filtered_model.enums, self.element_filters[&quot;enums&quot;]
<span class="line-number">256</span>            )
<span class="line-number">257</span>
<span class="line-number">258</span>        # Filter unions
<span class="line-number">259</span>        if &quot;unions&quot; in self.element_filters:
<span class="line-number">260</span><span class="uncovered">            filtered_model.unions = self._filter_dict(</span>
<span class="line-number">261</span>                filtered_model.unions, self.element_filters[&quot;unions&quot;]
<span class="line-number">262</span>            )
<span class="line-number">263</span>
<span class="line-number">264</span>        # Filter functions
<span class="line-number">265</span>        if &quot;functions&quot; in self.element_filters:
<span class="line-number">266</span>            filtered_model.functions = self._filter_list(
<span class="line-number">267</span>                filtered_model.functions,
<span class="line-number">268</span>                self.element_filters[&quot;functions&quot;],
<span class="line-number">269</span>                key=lambda f: f.name,
<span class="line-number">270</span>            )
<span class="line-number">271</span>
<span class="line-number">272</span>        # Filter globals
<span class="line-number">273</span>        if &quot;globals&quot; in self.element_filters:
<span class="line-number">274</span>            filtered_model.globals = self._filter_list(
<span class="line-number">275</span>                filtered_model.globals,
<span class="line-number">276</span>                self.element_filters[&quot;globals&quot;],
<span class="line-number">277</span>                key=lambda g: g.name,
<span class="line-number">278</span>            )
<span class="line-number">279</span>
<span class="line-number">280</span>        # Filter macros
<span class="line-number">281</span>        if &quot;macros&quot; in self.element_filters:
<span class="line-number">282</span>            filtered_model.macros = self._filter_list(
<span class="line-number">283</span>                filtered_model.macros, self.element_filters[&quot;macros&quot;]
<span class="line-number">284</span>            )
<span class="line-number">285</span>
<span class="line-number">286</span>        # Filter aliases
<span class="line-number">287</span>        if &quot;aliases&quot; in self.element_filters:
<span class="line-number">288</span>            filtered_model.aliases = self._filter_dict(
<span class="line-number">289</span>                filtered_model.aliases, self.element_filters[&quot;aliases&quot;]
<span class="line-number">290</span>            )
<span class="line-number">291</span>
<span class="line-number">292</span>        return filtered_model
<span class="line-number">293</span>
<span class="line-number">294</span>    def _filter_dict(self, items: dict, filters: dict) -&gt; dict:
<span class="line-number">295</span>        &quot;&quot;&quot;Filter dictionary items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">296</span>        include_patterns = [
<span class="line-number">297</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">298</span>        ]
<span class="line-number">299</span>        exclude_patterns = [
<span class="line-number">300</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">301</span>        ]
<span class="line-number">302</span>
<span class="line-number">303</span>        filtered_items = {}
<span class="line-number">304</span>
<span class="line-number">305</span>        for name, item in items.items():
<span class="line-number">306</span>            # Check include patterns
<span class="line-number">307</span>            if include_patterns:
<span class="line-number">308</span>                should_include = False
<span class="line-number">309</span>                for pattern in include_patterns:
<span class="line-number">310</span>                    if pattern.search(name):
<span class="line-number">311</span>                        should_include = True
<span class="line-number">312</span>                        break
<span class="line-number">313</span>                if not should_include:
<span class="line-number">314</span>                    continue
<span class="line-number">315</span>
<span class="line-number">316</span>            # Check exclude patterns
<span class="line-number">317</span>            should_exclude = False
<span class="line-number">318</span>            for pattern in exclude_patterns:
<span class="line-number">319</span>                if pattern.search(name):
<span class="line-number">320</span>                    should_exclude = True
<span class="line-number">321</span>                    break
<span class="line-number">322</span>            if should_exclude:
<span class="line-number">323</span>                continue
<span class="line-number">324</span>
<span class="line-number">325</span>            filtered_items[name] = item
<span class="line-number">326</span>
<span class="line-number">327</span>        return filtered_items
<span class="line-number">328</span>
<span class="line-number">329</span>    def _filter_list(self, items: list, filters: dict, key=None) -&gt; list:
<span class="line-number">330</span>        &quot;&quot;&quot;Filter list items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">331</span>        include_patterns = [
<span class="line-number">332</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">333</span>        ]
<span class="line-number">334</span>        exclude_patterns = [
<span class="line-number">335</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">336</span>        ]
<span class="line-number">337</span>
<span class="line-number">338</span>        filtered_items = []
<span class="line-number">339</span>
<span class="line-number">340</span>        for item in items:
<span class="line-number">341</span>            # Get the name to check against patterns
<span class="line-number">342</span>            if key:
<span class="line-number">343</span>                name = key(item)
<span class="line-number">344</span>            else:
<span class="line-number">345</span>                name = str(item)
<span class="line-number">346</span>
<span class="line-number">347</span>            # Check include patterns
<span class="line-number">348</span>            if include_patterns:
<span class="line-number">349</span>                should_include = False
<span class="line-number">350</span>                for pattern in include_patterns:
<span class="line-number">351</span>                    if pattern.search(name):
<span class="line-number">352</span>                        should_include = True
<span class="line-number">353</span>                        break
<span class="line-number">354</span>                if not should_include:
<span class="line-number">355</span>                    continue
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: has_filters (lines 204-405)</h4>
<pre>
<span class="line-number">204</span>    def has_filters(self) -&gt; bool:
<span class="line-number">205</span>        &quot;&quot;&quot;Check if configuration has any filters defined&quot;&quot;&quot;
<span class="line-number">206</span>        return bool(self.file_filters or self.element_filters)
<span class="line-number">207</span>
<span class="line-number">208</span>    def _should_include_file(self, file_path: str) -&gt; bool:
<span class="line-number">209</span>        &quot;&quot;&quot;Check if a file should be included based on filters&quot;&quot;&quot;
<span class="line-number">210</span>        # Check exclude patterns first
<span class="line-number">211</span>        for pattern in self.file_exclude_patterns:
<span class="line-number">212</span>            if pattern.search(file_path):
<span class="line-number">213</span>                return False
<span class="line-number">214</span>
<span class="line-number">215</span>        # If no include patterns, include all files (after exclusions)
<span class="line-number">216</span>        if not self.file_include_patterns:
<span class="line-number">217</span>            return True
<span class="line-number">218</span>
<span class="line-number">219</span>        # Check include patterns - file must match at least one
<span class="line-number">220</span>        for pattern in self.file_include_patterns:
<span class="line-number">221</span>            if pattern.search(file_path):
<span class="line-number">222</span>                return True
<span class="line-number">223</span>
<span class="line-number">224</span>        return False
<span class="line-number">225</span>
<span class="line-number">226</span>    def _apply_element_filters(self, file_model) -&gt; Any:
<span class="line-number">227</span>        &quot;&quot;&quot;Apply element filters to a file model&quot;&quot;&quot;
<span class="line-number">228</span>
<span class="line-number">229</span>        # Create a copy of the file model to avoid modifying the original
<span class="line-number">230</span>        filtered_model = FileModel(
<span class="line-number">231</span>            file_path=file_model.file_path,
<span class="line-number">232</span>            relative_path=file_model.relative_path,
<span class="line-number">233</span>            project_root=file_model.project_root,
<span class="line-number">234</span>            encoding_used=file_model.encoding_used,
<span class="line-number">235</span>            structs=file_model.structs.copy(),
<span class="line-number">236</span>            enums=file_model.enums.copy(),
<span class="line-number">237</span>            unions=file_model.unions.copy(),
<span class="line-number">238</span>            functions=file_model.functions.copy(),
<span class="line-number">239</span>            globals=file_model.globals.copy(),
<span class="line-number">240</span>            includes=file_model.includes.copy(),
<span class="line-number">241</span>            macros=file_model.macros.copy(),
<span class="line-number">242</span>            aliases=file_model.aliases.copy(),
<span class="line-number">243</span>            # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">244</span>        )
<span class="line-number">245</span>
<span class="line-number">246</span>        # Filter structs
<span class="line-number">247</span>        if &quot;structs&quot; in self.element_filters:
<span class="line-number">248</span>            filtered_model.structs = self._filter_dict(
<span class="line-number">249</span>                filtered_model.structs, self.element_filters[&quot;structs&quot;]
<span class="line-number">250</span>            )
<span class="line-number">251</span>
<span class="line-number">252</span>        # Filter enums
<span class="line-number">253</span>        if &quot;enums&quot; in self.element_filters:
<span class="line-number">254</span>            filtered_model.enums = self._filter_dict(
<span class="line-number">255</span>                filtered_model.enums, self.element_filters[&quot;enums&quot;]
<span class="line-number">256</span>            )
<span class="line-number">257</span>
<span class="line-number">258</span>        # Filter unions
<span class="line-number">259</span>        if &quot;unions&quot; in self.element_filters:
<span class="line-number">260</span><span class="uncovered">            filtered_model.unions = self._filter_dict(</span>
<span class="line-number">261</span>                filtered_model.unions, self.element_filters[&quot;unions&quot;]
<span class="line-number">262</span>            )
<span class="line-number">263</span>
<span class="line-number">264</span>        # Filter functions
<span class="line-number">265</span>        if &quot;functions&quot; in self.element_filters:
<span class="line-number">266</span>            filtered_model.functions = self._filter_list(
<span class="line-number">267</span>                filtered_model.functions,
<span class="line-number">268</span>                self.element_filters[&quot;functions&quot;],
<span class="line-number">269</span>                key=lambda f: f.name,
<span class="line-number">270</span>            )
<span class="line-number">271</span>
<span class="line-number">272</span>        # Filter globals
<span class="line-number">273</span>        if &quot;globals&quot; in self.element_filters:
<span class="line-number">274</span>            filtered_model.globals = self._filter_list(
<span class="line-number">275</span>                filtered_model.globals,
<span class="line-number">276</span>                self.element_filters[&quot;globals&quot;],
<span class="line-number">277</span>                key=lambda g: g.name,
<span class="line-number">278</span>            )
<span class="line-number">279</span>
<span class="line-number">280</span>        # Filter macros
<span class="line-number">281</span>        if &quot;macros&quot; in self.element_filters:
<span class="line-number">282</span>            filtered_model.macros = self._filter_list(
<span class="line-number">283</span>                filtered_model.macros, self.element_filters[&quot;macros&quot;]
<span class="line-number">284</span>            )
<span class="line-number">285</span>
<span class="line-number">286</span>        # Filter aliases
<span class="line-number">287</span>        if &quot;aliases&quot; in self.element_filters:
<span class="line-number">288</span>            filtered_model.aliases = self._filter_dict(
<span class="line-number">289</span>                filtered_model.aliases, self.element_filters[&quot;aliases&quot;]
<span class="line-number">290</span>            )
<span class="line-number">291</span>
<span class="line-number">292</span>        return filtered_model
<span class="line-number">293</span>
<span class="line-number">294</span>    def _filter_dict(self, items: dict, filters: dict) -&gt; dict:
<span class="line-number">295</span>        &quot;&quot;&quot;Filter dictionary items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">296</span>        include_patterns = [
<span class="line-number">297</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">298</span>        ]
<span class="line-number">299</span>        exclude_patterns = [
<span class="line-number">300</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">301</span>        ]
<span class="line-number">302</span>
<span class="line-number">303</span>        filtered_items = {}
<span class="line-number">304</span>
<span class="line-number">305</span>        for name, item in items.items():
<span class="line-number">306</span>            # Check include patterns
<span class="line-number">307</span>            if include_patterns:
<span class="line-number">308</span>                should_include = False
<span class="line-number">309</span>                for pattern in include_patterns:
<span class="line-number">310</span>                    if pattern.search(name):
<span class="line-number">311</span>                        should_include = True
<span class="line-number">312</span>                        break
<span class="line-number">313</span>                if not should_include:
<span class="line-number">314</span>                    continue
<span class="line-number">315</span>
<span class="line-number">316</span>            # Check exclude patterns
<span class="line-number">317</span>            should_exclude = False
<span class="line-number">318</span>            for pattern in exclude_patterns:
<span class="line-number">319</span>                if pattern.search(name):
<span class="line-number">320</span>                    should_exclude = True
<span class="line-number">321</span>                    break
<span class="line-number">322</span>            if should_exclude:
<span class="line-number">323</span>                continue
<span class="line-number">324</span>
<span class="line-number">325</span>            filtered_items[name] = item
<span class="line-number">326</span>
<span class="line-number">327</span>        return filtered_items
<span class="line-number">328</span>
<span class="line-number">329</span>    def _filter_list(self, items: list, filters: dict, key=None) -&gt; list:
<span class="line-number">330</span>        &quot;&quot;&quot;Filter list items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">331</span>        include_patterns = [
<span class="line-number">332</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">333</span>        ]
<span class="line-number">334</span>        exclude_patterns = [
<span class="line-number">335</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">336</span>        ]
<span class="line-number">337</span>
<span class="line-number">338</span>        filtered_items = []
<span class="line-number">339</span>
<span class="line-number">340</span>        for item in items:
<span class="line-number">341</span>            # Get the name to check against patterns
<span class="line-number">342</span>            if key:
<span class="line-number">343</span>                name = key(item)
<span class="line-number">344</span>            else:
<span class="line-number">345</span>                name = str(item)
<span class="line-number">346</span>
<span class="line-number">347</span>            # Check include patterns
<span class="line-number">348</span>            if include_patterns:
<span class="line-number">349</span>                should_include = False
<span class="line-number">350</span>                for pattern in include_patterns:
<span class="line-number">351</span>                    if pattern.search(name):
<span class="line-number">352</span>                        should_include = True
<span class="line-number">353</span>                        break
<span class="line-number">354</span>                if not should_include:
<span class="line-number">355</span>                    continue
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: _should_include_file (lines 208-405)</h4>
<pre>
<span class="line-number">208</span>    def _should_include_file(self, file_path: str) -&gt; bool:
<span class="line-number">209</span>        &quot;&quot;&quot;Check if a file should be included based on filters&quot;&quot;&quot;
<span class="line-number">210</span>        # Check exclude patterns first
<span class="line-number">211</span>        for pattern in self.file_exclude_patterns:
<span class="line-number">212</span>            if pattern.search(file_path):
<span class="line-number">213</span>                return False
<span class="line-number">214</span>
<span class="line-number">215</span>        # If no include patterns, include all files (after exclusions)
<span class="line-number">216</span>        if not self.file_include_patterns:
<span class="line-number">217</span>            return True
<span class="line-number">218</span>
<span class="line-number">219</span>        # Check include patterns - file must match at least one
<span class="line-number">220</span>        for pattern in self.file_include_patterns:
<span class="line-number">221</span>            if pattern.search(file_path):
<span class="line-number">222</span>                return True
<span class="line-number">223</span>
<span class="line-number">224</span>        return False
<span class="line-number">225</span>
<span class="line-number">226</span>    def _apply_element_filters(self, file_model) -&gt; Any:
<span class="line-number">227</span>        &quot;&quot;&quot;Apply element filters to a file model&quot;&quot;&quot;
<span class="line-number">228</span>
<span class="line-number">229</span>        # Create a copy of the file model to avoid modifying the original
<span class="line-number">230</span>        filtered_model = FileModel(
<span class="line-number">231</span>            file_path=file_model.file_path,
<span class="line-number">232</span>            relative_path=file_model.relative_path,
<span class="line-number">233</span>            project_root=file_model.project_root,
<span class="line-number">234</span>            encoding_used=file_model.encoding_used,
<span class="line-number">235</span>            structs=file_model.structs.copy(),
<span class="line-number">236</span>            enums=file_model.enums.copy(),
<span class="line-number">237</span>            unions=file_model.unions.copy(),
<span class="line-number">238</span>            functions=file_model.functions.copy(),
<span class="line-number">239</span>            globals=file_model.globals.copy(),
<span class="line-number">240</span>            includes=file_model.includes.copy(),
<span class="line-number">241</span>            macros=file_model.macros.copy(),
<span class="line-number">242</span>            aliases=file_model.aliases.copy(),
<span class="line-number">243</span>            # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">244</span>        )
<span class="line-number">245</span>
<span class="line-number">246</span>        # Filter structs
<span class="line-number">247</span>        if &quot;structs&quot; in self.element_filters:
<span class="line-number">248</span>            filtered_model.structs = self._filter_dict(
<span class="line-number">249</span>                filtered_model.structs, self.element_filters[&quot;structs&quot;]
<span class="line-number">250</span>            )
<span class="line-number">251</span>
<span class="line-number">252</span>        # Filter enums
<span class="line-number">253</span>        if &quot;enums&quot; in self.element_filters:
<span class="line-number">254</span>            filtered_model.enums = self._filter_dict(
<span class="line-number">255</span>                filtered_model.enums, self.element_filters[&quot;enums&quot;]
<span class="line-number">256</span>            )
<span class="line-number">257</span>
<span class="line-number">258</span>        # Filter unions
<span class="line-number">259</span>        if &quot;unions&quot; in self.element_filters:
<span class="line-number">260</span><span class="uncovered">            filtered_model.unions = self._filter_dict(</span>
<span class="line-number">261</span>                filtered_model.unions, self.element_filters[&quot;unions&quot;]
<span class="line-number">262</span>            )
<span class="line-number">263</span>
<span class="line-number">264</span>        # Filter functions
<span class="line-number">265</span>        if &quot;functions&quot; in self.element_filters:
<span class="line-number">266</span>            filtered_model.functions = self._filter_list(
<span class="line-number">267</span>                filtered_model.functions,
<span class="line-number">268</span>                self.element_filters[&quot;functions&quot;],
<span class="line-number">269</span>                key=lambda f: f.name,
<span class="line-number">270</span>            )
<span class="line-number">271</span>
<span class="line-number">272</span>        # Filter globals
<span class="line-number">273</span>        if &quot;globals&quot; in self.element_filters:
<span class="line-number">274</span>            filtered_model.globals = self._filter_list(
<span class="line-number">275</span>                filtered_model.globals,
<span class="line-number">276</span>                self.element_filters[&quot;globals&quot;],
<span class="line-number">277</span>                key=lambda g: g.name,
<span class="line-number">278</span>            )
<span class="line-number">279</span>
<span class="line-number">280</span>        # Filter macros
<span class="line-number">281</span>        if &quot;macros&quot; in self.element_filters:
<span class="line-number">282</span>            filtered_model.macros = self._filter_list(
<span class="line-number">283</span>                filtered_model.macros, self.element_filters[&quot;macros&quot;]
<span class="line-number">284</span>            )
<span class="line-number">285</span>
<span class="line-number">286</span>        # Filter aliases
<span class="line-number">287</span>        if &quot;aliases&quot; in self.element_filters:
<span class="line-number">288</span>            filtered_model.aliases = self._filter_dict(
<span class="line-number">289</span>                filtered_model.aliases, self.element_filters[&quot;aliases&quot;]
<span class="line-number">290</span>            )
<span class="line-number">291</span>
<span class="line-number">292</span>        return filtered_model
<span class="line-number">293</span>
<span class="line-number">294</span>    def _filter_dict(self, items: dict, filters: dict) -&gt; dict:
<span class="line-number">295</span>        &quot;&quot;&quot;Filter dictionary items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">296</span>        include_patterns = [
<span class="line-number">297</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">298</span>        ]
<span class="line-number">299</span>        exclude_patterns = [
<span class="line-number">300</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">301</span>        ]
<span class="line-number">302</span>
<span class="line-number">303</span>        filtered_items = {}
<span class="line-number">304</span>
<span class="line-number">305</span>        for name, item in items.items():
<span class="line-number">306</span>            # Check include patterns
<span class="line-number">307</span>            if include_patterns:
<span class="line-number">308</span>                should_include = False
<span class="line-number">309</span>                for pattern in include_patterns:
<span class="line-number">310</span>                    if pattern.search(name):
<span class="line-number">311</span>                        should_include = True
<span class="line-number">312</span>                        break
<span class="line-number">313</span>                if not should_include:
<span class="line-number">314</span>                    continue
<span class="line-number">315</span>
<span class="line-number">316</span>            # Check exclude patterns
<span class="line-number">317</span>            should_exclude = False
<span class="line-number">318</span>            for pattern in exclude_patterns:
<span class="line-number">319</span>                if pattern.search(name):
<span class="line-number">320</span>                    should_exclude = True
<span class="line-number">321</span>                    break
<span class="line-number">322</span>            if should_exclude:
<span class="line-number">323</span>                continue
<span class="line-number">324</span>
<span class="line-number">325</span>            filtered_items[name] = item
<span class="line-number">326</span>
<span class="line-number">327</span>        return filtered_items
<span class="line-number">328</span>
<span class="line-number">329</span>    def _filter_list(self, items: list, filters: dict, key=None) -&gt; list:
<span class="line-number">330</span>        &quot;&quot;&quot;Filter list items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">331</span>        include_patterns = [
<span class="line-number">332</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">333</span>        ]
<span class="line-number">334</span>        exclude_patterns = [
<span class="line-number">335</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">336</span>        ]
<span class="line-number">337</span>
<span class="line-number">338</span>        filtered_items = []
<span class="line-number">339</span>
<span class="line-number">340</span>        for item in items:
<span class="line-number">341</span>            # Get the name to check against patterns
<span class="line-number">342</span>            if key:
<span class="line-number">343</span>                name = key(item)
<span class="line-number">344</span>            else:
<span class="line-number">345</span>                name = str(item)
<span class="line-number">346</span>
<span class="line-number">347</span>            # Check include patterns
<span class="line-number">348</span>            if include_patterns:
<span class="line-number">349</span>                should_include = False
<span class="line-number">350</span>                for pattern in include_patterns:
<span class="line-number">351</span>                    if pattern.search(name):
<span class="line-number">352</span>                        should_include = True
<span class="line-number">353</span>                        break
<span class="line-number">354</span>                if not should_include:
<span class="line-number">355</span>                    continue
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: _apply_element_filters (lines 226-405)</h4>
<pre>
<span class="line-number">226</span>    def _apply_element_filters(self, file_model) -&gt; Any:
<span class="line-number">227</span>        &quot;&quot;&quot;Apply element filters to a file model&quot;&quot;&quot;
<span class="line-number">228</span>
<span class="line-number">229</span>        # Create a copy of the file model to avoid modifying the original
<span class="line-number">230</span>        filtered_model = FileModel(
<span class="line-number">231</span>            file_path=file_model.file_path,
<span class="line-number">232</span>            relative_path=file_model.relative_path,
<span class="line-number">233</span>            project_root=file_model.project_root,
<span class="line-number">234</span>            encoding_used=file_model.encoding_used,
<span class="line-number">235</span>            structs=file_model.structs.copy(),
<span class="line-number">236</span>            enums=file_model.enums.copy(),
<span class="line-number">237</span>            unions=file_model.unions.copy(),
<span class="line-number">238</span>            functions=file_model.functions.copy(),
<span class="line-number">239</span>            globals=file_model.globals.copy(),
<span class="line-number">240</span>            includes=file_model.includes.copy(),
<span class="line-number">241</span>            macros=file_model.macros.copy(),
<span class="line-number">242</span>            aliases=file_model.aliases.copy(),
<span class="line-number">243</span>            # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">244</span>        )
<span class="line-number">245</span>
<span class="line-number">246</span>        # Filter structs
<span class="line-number">247</span>        if &quot;structs&quot; in self.element_filters:
<span class="line-number">248</span>            filtered_model.structs = self._filter_dict(
<span class="line-number">249</span>                filtered_model.structs, self.element_filters[&quot;structs&quot;]
<span class="line-number">250</span>            )
<span class="line-number">251</span>
<span class="line-number">252</span>        # Filter enums
<span class="line-number">253</span>        if &quot;enums&quot; in self.element_filters:
<span class="line-number">254</span>            filtered_model.enums = self._filter_dict(
<span class="line-number">255</span>                filtered_model.enums, self.element_filters[&quot;enums&quot;]
<span class="line-number">256</span>            )
<span class="line-number">257</span>
<span class="line-number">258</span>        # Filter unions
<span class="line-number">259</span>        if &quot;unions&quot; in self.element_filters:
<span class="line-number">260</span><span class="uncovered">            filtered_model.unions = self._filter_dict(</span>
<span class="line-number">261</span>                filtered_model.unions, self.element_filters[&quot;unions&quot;]
<span class="line-number">262</span>            )
<span class="line-number">263</span>
<span class="line-number">264</span>        # Filter functions
<span class="line-number">265</span>        if &quot;functions&quot; in self.element_filters:
<span class="line-number">266</span>            filtered_model.functions = self._filter_list(
<span class="line-number">267</span>                filtered_model.functions,
<span class="line-number">268</span>                self.element_filters[&quot;functions&quot;],
<span class="line-number">269</span>                key=lambda f: f.name,
<span class="line-number">270</span>            )
<span class="line-number">271</span>
<span class="line-number">272</span>        # Filter globals
<span class="line-number">273</span>        if &quot;globals&quot; in self.element_filters:
<span class="line-number">274</span>            filtered_model.globals = self._filter_list(
<span class="line-number">275</span>                filtered_model.globals,
<span class="line-number">276</span>                self.element_filters[&quot;globals&quot;],
<span class="line-number">277</span>                key=lambda g: g.name,
<span class="line-number">278</span>            )
<span class="line-number">279</span>
<span class="line-number">280</span>        # Filter macros
<span class="line-number">281</span>        if &quot;macros&quot; in self.element_filters:
<span class="line-number">282</span>            filtered_model.macros = self._filter_list(
<span class="line-number">283</span>                filtered_model.macros, self.element_filters[&quot;macros&quot;]
<span class="line-number">284</span>            )
<span class="line-number">285</span>
<span class="line-number">286</span>        # Filter aliases
<span class="line-number">287</span>        if &quot;aliases&quot; in self.element_filters:
<span class="line-number">288</span>            filtered_model.aliases = self._filter_dict(
<span class="line-number">289</span>                filtered_model.aliases, self.element_filters[&quot;aliases&quot;]
<span class="line-number">290</span>            )
<span class="line-number">291</span>
<span class="line-number">292</span>        return filtered_model
<span class="line-number">293</span>
<span class="line-number">294</span>    def _filter_dict(self, items: dict, filters: dict) -&gt; dict:
<span class="line-number">295</span>        &quot;&quot;&quot;Filter dictionary items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">296</span>        include_patterns = [
<span class="line-number">297</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">298</span>        ]
<span class="line-number">299</span>        exclude_patterns = [
<span class="line-number">300</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">301</span>        ]
<span class="line-number">302</span>
<span class="line-number">303</span>        filtered_items = {}
<span class="line-number">304</span>
<span class="line-number">305</span>        for name, item in items.items():
<span class="line-number">306</span>            # Check include patterns
<span class="line-number">307</span>            if include_patterns:
<span class="line-number">308</span>                should_include = False
<span class="line-number">309</span>                for pattern in include_patterns:
<span class="line-number">310</span>                    if pattern.search(name):
<span class="line-number">311</span>                        should_include = True
<span class="line-number">312</span>                        break
<span class="line-number">313</span>                if not should_include:
<span class="line-number">314</span>                    continue
<span class="line-number">315</span>
<span class="line-number">316</span>            # Check exclude patterns
<span class="line-number">317</span>            should_exclude = False
<span class="line-number">318</span>            for pattern in exclude_patterns:
<span class="line-number">319</span>                if pattern.search(name):
<span class="line-number">320</span>                    should_exclude = True
<span class="line-number">321</span>                    break
<span class="line-number">322</span>            if should_exclude:
<span class="line-number">323</span>                continue
<span class="line-number">324</span>
<span class="line-number">325</span>            filtered_items[name] = item
<span class="line-number">326</span>
<span class="line-number">327</span>        return filtered_items
<span class="line-number">328</span>
<span class="line-number">329</span>    def _filter_list(self, items: list, filters: dict, key=None) -&gt; list:
<span class="line-number">330</span>        &quot;&quot;&quot;Filter list items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">331</span>        include_patterns = [
<span class="line-number">332</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">333</span>        ]
<span class="line-number">334</span>        exclude_patterns = [
<span class="line-number">335</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">336</span>        ]
<span class="line-number">337</span>
<span class="line-number">338</span>        filtered_items = []
<span class="line-number">339</span>
<span class="line-number">340</span>        for item in items:
<span class="line-number">341</span>            # Get the name to check against patterns
<span class="line-number">342</span>            if key:
<span class="line-number">343</span>                name = key(item)
<span class="line-number">344</span>            else:
<span class="line-number">345</span>                name = str(item)
<span class="line-number">346</span>
<span class="line-number">347</span>            # Check include patterns
<span class="line-number">348</span>            if include_patterns:
<span class="line-number">349</span>                should_include = False
<span class="line-number">350</span>                for pattern in include_patterns:
<span class="line-number">351</span>                    if pattern.search(name):
<span class="line-number">352</span>                        should_include = True
<span class="line-number">353</span>                        break
<span class="line-number">354</span>                if not should_include:
<span class="line-number">355</span>                    continue
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: _filter_dict (lines 294-405)</h4>
<pre>
<span class="line-number">294</span>    def _filter_dict(self, items: dict, filters: dict) -&gt; dict:
<span class="line-number">295</span>        &quot;&quot;&quot;Filter dictionary items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">296</span>        include_patterns = [
<span class="line-number">297</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">298</span>        ]
<span class="line-number">299</span>        exclude_patterns = [
<span class="line-number">300</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">301</span>        ]
<span class="line-number">302</span>
<span class="line-number">303</span>        filtered_items = {}
<span class="line-number">304</span>
<span class="line-number">305</span>        for name, item in items.items():
<span class="line-number">306</span>            # Check include patterns
<span class="line-number">307</span>            if include_patterns:
<span class="line-number">308</span>                should_include = False
<span class="line-number">309</span>                for pattern in include_patterns:
<span class="line-number">310</span>                    if pattern.search(name):
<span class="line-number">311</span>                        should_include = True
<span class="line-number">312</span>                        break
<span class="line-number">313</span>                if not should_include:
<span class="line-number">314</span>                    continue
<span class="line-number">315</span>
<span class="line-number">316</span>            # Check exclude patterns
<span class="line-number">317</span>            should_exclude = False
<span class="line-number">318</span>            for pattern in exclude_patterns:
<span class="line-number">319</span>                if pattern.search(name):
<span class="line-number">320</span>                    should_exclude = True
<span class="line-number">321</span>                    break
<span class="line-number">322</span>            if should_exclude:
<span class="line-number">323</span>                continue
<span class="line-number">324</span>
<span class="line-number">325</span>            filtered_items[name] = item
<span class="line-number">326</span>
<span class="line-number">327</span>        return filtered_items
<span class="line-number">328</span>
<span class="line-number">329</span>    def _filter_list(self, items: list, filters: dict, key=None) -&gt; list:
<span class="line-number">330</span>        &quot;&quot;&quot;Filter list items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">331</span>        include_patterns = [
<span class="line-number">332</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">333</span>        ]
<span class="line-number">334</span>        exclude_patterns = [
<span class="line-number">335</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">336</span>        ]
<span class="line-number">337</span>
<span class="line-number">338</span>        filtered_items = []
<span class="line-number">339</span>
<span class="line-number">340</span>        for item in items:
<span class="line-number">341</span>            # Get the name to check against patterns
<span class="line-number">342</span>            if key:
<span class="line-number">343</span>                name = key(item)
<span class="line-number">344</span>            else:
<span class="line-number">345</span>                name = str(item)
<span class="line-number">346</span>
<span class="line-number">347</span>            # Check include patterns
<span class="line-number">348</span>            if include_patterns:
<span class="line-number">349</span>                should_include = False
<span class="line-number">350</span>                for pattern in include_patterns:
<span class="line-number">351</span>                    if pattern.search(name):
<span class="line-number">352</span>                        should_include = True
<span class="line-number">353</span>                        break
<span class="line-number">354</span>                if not should_include:
<span class="line-number">355</span>                    continue
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: _filter_list (lines 329-405)</h4>
<pre>
<span class="line-number">329</span>    def _filter_list(self, items: list, filters: dict, key=None) -&gt; list:
<span class="line-number">330</span>        &quot;&quot;&quot;Filter list items based on include/exclude patterns&quot;&quot;&quot;
<span class="line-number">331</span>        include_patterns = [
<span class="line-number">332</span>            re.compile(pattern) for pattern in filters.get(&quot;include&quot;, [])
<span class="line-number">333</span>        ]
<span class="line-number">334</span>        exclude_patterns = [
<span class="line-number">335</span>            re.compile(pattern) for pattern in filters.get(&quot;exclude&quot;, [])
<span class="line-number">336</span>        ]
<span class="line-number">337</span>
<span class="line-number">338</span>        filtered_items = []
<span class="line-number">339</span>
<span class="line-number">340</span>        for item in items:
<span class="line-number">341</span>            # Get the name to check against patterns
<span class="line-number">342</span>            if key:
<span class="line-number">343</span>                name = key(item)
<span class="line-number">344</span>            else:
<span class="line-number">345</span>                name = str(item)
<span class="line-number">346</span>
<span class="line-number">347</span>            # Check include patterns
<span class="line-number">348</span>            if include_patterns:
<span class="line-number">349</span>                should_include = False
<span class="line-number">350</span>                for pattern in include_patterns:
<span class="line-number">351</span>                    if pattern.search(name):
<span class="line-number">352</span>                        should_include = True
<span class="line-number">353</span>                        break
<span class="line-number">354</span>                if not should_include:
<span class="line-number">355</span>                    continue
<span class="line-number">356</span>
<span class="line-number">357</span>            # Check exclude patterns
<span class="line-number">358</span>            should_exclude = False
<span class="line-number">359</span>            for pattern in exclude_patterns:
<span class="line-number">360</span>                if pattern.search(name):
<span class="line-number">361</span><span class="uncovered">                    should_exclude = True</span>
<span class="line-number">362</span><span class="uncovered">                    break</span>
<span class="line-number">363</span>            if should_exclude:
<span class="line-number">364</span><span class="uncovered">                continue</span>
<span class="line-number">365</span>
<span class="line-number">366</span>            filtered_items.append(item)
<span class="line-number">367</span>
<span class="line-number">368</span>        return filtered_items
<span class="line-number">369</span>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: get_summary (lines 370-405)</h4>
<pre>
<span class="line-number">370</span>    def get_summary(self) -&gt; Dict[str, Any]:
<span class="line-number">371</span>        &quot;&quot;&quot;Get a summary of the configuration&quot;&quot;&quot;
<span class="line-number">372</span>        return {
<span class="line-number">373</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">374</span>            &quot;source_folders&quot;: self.source_folders,
<span class="line-number">375</span>            &quot;output_dir&quot;: self.output_dir,
<span class="line-number">376</span>            &quot;recursive_search&quot;: self.recursive_search,
<span class="line-number">377</span>            &quot;include_depth&quot;: self.include_depth,
<span class="line-number">378</span>            &quot;has_file_filters&quot;: bool(self.file_filters),
<span class="line-number">379</span>            &quot;has_element_filters&quot;: bool(self.element_filters),
<span class="line-number">380</span>            &quot;has_transformations&quot;: bool(self.transformations),
<span class="line-number">381</span>        }
<span class="line-number">382</span>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
<h4>Function: __eq__ (lines 383-405)</h4>
<pre>
<span class="line-number">383</span>    def __eq__(self, other: Any) -&gt; bool:
<span class="line-number">384</span>        &quot;&quot;&quot;Check if two configurations are equal&quot;&quot;&quot;
<span class="line-number">385</span>        if not isinstance(other, Config):
<span class="line-number">386</span><span class="uncovered">            return False</span>
<span class="line-number">387</span>
<span class="line-number">388</span>        return (
<span class="line-number">389</span>            self.project_name == other.project_name
<span class="line-number">390</span>            and self.source_folders == other.source_folders
<span class="line-number">391</span>            and self.output_dir == other.output_dir
<span class="line-number">392</span>            and self.model_output_path == other.model_output_path
<span class="line-number">393</span>            and self.recursive_search == other.recursive_search
<span class="line-number">394</span>            and self.include_depth == other.include_depth
<span class="line-number">395</span>            and self.file_filters == other.file_filters
<span class="line-number">396</span>            and self.element_filters == other.element_filters
<span class="line-number">397</span>            and self.transformations == other.transformations
<span class="line-number">398</span>        )
<span class="line-number">399</span>
<span class="line-number">400</span>    def __repr__(self) -&gt; str:
<span class="line-number">401</span>        &quot;&quot;&quot;String representation of the configuration&quot;&quot;&quot;
<span class="line-number">402</span>        return (
<span class="line-number">403</span>            f&quot;Config(project_name=&#x27;{self.project_name}&#x27;, &quot;
<span class="line-number">404</span>            f&quot;source_folders={self.source_folders})&quot;
<span class="line-number">405</span>        )
</pre>
</div>
<div class="file-section">
<div class="file-header">
/home/runner/work/generator_project/generator_project/c_to_plantuml/main.py - 53.61% coverage (52/97 lines)
</div>
<h4>Function: setup_logging (lines 24-207)</h4>
<pre>
<span class="line-number"> 24</span>def setup_logging(verbose: bool = False) -&gt; None:
<span class="line-number"> 25</span>    level = logging.DEBUG if verbose else logging.INFO
<span class="line-number"> 26</span>    logging.basicConfig(
<span class="line-number"> 27</span>        level=level,
<span class="line-number"> 28</span>        format=&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;,
<span class="line-number"> 29</span>        handlers=[logging.StreamHandler(sys.stdout)],
<span class="line-number"> 30</span>    )
<span class="line-number"> 31</span>
<span class="line-number"> 32</span>
<span class="line-number"> 33</span>def load_config_from_path(config_path: str) -&gt; dict:
<span class="line-number"> 34</span>    path = Path(config_path)
<span class="line-number"> 35</span>    if path.is_file():
<span class="line-number"> 36</span>        with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number"> 37</span>            return json.load(f)
<span class="line-number"> 38</span><span class="uncovered">    elif path.is_dir():</span>
<span class="line-number"> 39</span>        # Merge all .json files in the folder
<span class="line-number"> 40</span><span class="uncovered">        config = {}</span>
<span class="line-number"> 41</span><span class="uncovered">        for file in path.glob(&quot;*.json&quot;):</span>
<span class="line-number"> 42</span><span class="uncovered">            with open(file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:</span>
<span class="line-number"> 43</span><span class="uncovered">                data = json.load(f)</span>
<span class="line-number"> 44</span><span class="uncovered">                config.update(data)</span>
<span class="line-number"> 45</span><span class="uncovered">        return config</span>
<span class="line-number"> 46</span>    else:
<span class="line-number"> 47</span><span class="uncovered">        raise FileNotFoundError(f&quot;Config path not found: {config_path}&quot;)</span>
<span class="line-number"> 48</span>
<span class="line-number"> 49</span>
<span class="line-number"> 50</span>def main() -&gt; int:
<span class="line-number"> 51</span>    parser = argparse.ArgumentParser(
<span class="line-number"> 52</span>        description=&quot;C to PlantUML Converter (Simplified CLI)&quot;,
<span class="line-number"> 53</span>        formatter_class=argparse.RawDescriptionHelpFormatter,
<span class="line-number"> 54</span>        epilog=&quot;&quot;&quot;
<span class="line-number"> 55</span>Usage:
<span class="line-number"> 56</span>  %(prog)s --config config.json [parse|transform|generate]
<span class="line-number"> 57</span>  %(prog)s config_folder [parse|transform|generate]
<span class="line-number"> 58</span>  %(prog)s [parse|transform|generate]  # Uses current directory as config folder
<span class="line-number"> 59</span>  %(prog)s              # Full workflow (parse, transform, generate)
<span class="line-number"> 60</span>        &quot;&quot;&quot;,
<span class="line-number"> 61</span>    )
<span class="line-number"> 62</span>    parser.add_argument(
<span class="line-number"> 63</span>        &quot;--config&quot;,
<span class="line-number"> 64</span>        &quot;-c&quot;,
<span class="line-number"> 65</span>        type=str,
<span class="line-number"> 66</span>        default=None,
<span class="line-number"> 67</span>        help=&quot;Path to config.json or config folder (optional, default: current directory)&quot;,
<span class="line-number"> 68</span>    )
<span class="line-number"> 69</span>    parser.add_argument(
<span class="line-number"> 70</span>        &quot;command&quot;,
<span class="line-number"> 71</span>        nargs=&quot;?&quot;,
<span class="line-number"> 72</span>        choices=[&quot;parse&quot;, &quot;transform&quot;, &quot;generate&quot;],
<span class="line-number"> 73</span>        help=&quot;Which step to run: parse, transform, or generate. If omitted, runs full workflow.&quot;,
<span class="line-number"> 74</span>    )
<span class="line-number"> 75</span>    parser.add_argument(
<span class="line-number"> 76</span>        &quot;--verbose&quot;, &quot;-v&quot;, action=&quot;store_true&quot;, help=&quot;Enable verbose output&quot;
<span class="line-number"> 77</span>    )
<span class="line-number"> 78</span>    args = parser.parse_args()
<span class="line-number"> 79</span>
<span class="line-number"> 80</span>    setup_logging(args.verbose)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>    # Determine config path
<span class="line-number"> 83</span>    config_path = args.config
<span class="line-number"> 84</span>    if config_path is None:
<span class="line-number"> 85</span><span class="uncovered">        config_path = os.getcwd()</span>
<span class="line-number"> 86</span>
<span class="line-number"> 87</span>    logging.info(&quot;Using config: %s&quot;, config_path)
<span class="line-number"> 88</span>
<span class="line-number"> 89</span>    # Load config
<span class="line-number"> 90</span>    try:
<span class="line-number"> 91</span>        config_data = load_config_from_path(config_path)
<span class="line-number"> 92</span>        config = Config(**config_data)
<span class="line-number"> 93</span><span class="uncovered">    except Exception as e:</span>
<span class="line-number"> 94</span><span class="uncovered">        logging.error(&quot;Failed to load configuration: %s&quot;, e)</span>
<span class="line-number"> 95</span><span class="uncovered">        return 1</span>
<span class="line-number"> 96</span>
<span class="line-number"> 97</span>    # Determine output folder from config, default to ./output
<span class="line-number"> 98</span>    output_folder = getattr(config, &quot;output_dir&quot;, None) or os.path.join(
<span class="line-number"> 99</span>        os.getcwd(), &quot;output&quot;
<span class="line-number">100</span>    )
<span class="line-number">101</span>    output_folder = os.path.abspath(output_folder)
<span class="line-number">102</span>    os.makedirs(output_folder, exist_ok=True)
<span class="line-number">103</span>    logging.info(&quot;Output folder: %s&quot;, output_folder)
<span class="line-number">104</span>
<span class="line-number">105</span>    model_file = os.path.join(output_folder, &quot;model.json&quot;)
<span class="line-number">106</span>    transformed_model_file = os.path.join(output_folder, &quot;model_transformed.json&quot;)
<span class="line-number">107</span>
<span class="line-number">108</span>    # Parse command
<span class="line-number">109</span>    if args.command == &quot;parse&quot;:
<span class="line-number">110</span><span class="uncovered">        try:</span>
<span class="line-number">111</span><span class="uncovered">            parser_obj = Parser()</span>
<span class="line-number">112</span>            # Use the refactored parse function that handles both single and multiple source folders
<span class="line-number">113</span><span class="uncovered">            parser_obj.parse(</span>
<span class="line-number">114</span>                project_root=config.source_folders,
<span class="line-number">115</span>                output_file=model_file,
<span class="line-number">116</span>                recursive_search=getattr(config, &quot;recursive_search&quot;, True),
<span class="line-number">117</span>                config=config,
<span class="line-number">118</span>            )
<span class="line-number">119</span><span class="uncovered">            logging.info(&quot;Model saved to: %s&quot;, model_file)</span>
<span class="line-number">120</span><span class="uncovered">            return 0</span>
<span class="line-number">121</span><span class="uncovered">        except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">122</span><span class="uncovered">            logging.error(&quot;Error during parsing: %s&quot;, e)</span>
<span class="line-number">123</span><span class="uncovered">            return 1</span>
<span class="line-number">124</span>
<span class="line-number">125</span>    # Transform command
<span class="line-number">126</span>    if args.command == &quot;transform&quot;:
<span class="line-number">127</span><span class="uncovered">        try:</span>
<span class="line-number">128</span><span class="uncovered">            transformer = Transformer()</span>
<span class="line-number">129</span><span class="uncovered">            transformer.transform(</span>
<span class="line-number">130</span>                model_file=model_file,
<span class="line-number">131</span>                config_file=(
<span class="line-number">132</span>                    config_path
<span class="line-number">133</span>                    if Path(config_path).is_file()
<span class="line-number">134</span>                    else str(list(Path(config_path).glob(&quot;*.json&quot;))[0])
<span class="line-number">135</span>                ),
<span class="line-number">136</span>                output_file=transformed_model_file,
<span class="line-number">137</span>            )
<span class="line-number">138</span><span class="uncovered">            logging.info(&quot;Transformed model saved to: %s&quot;, transformed_model_file)</span>
<span class="line-number">139</span><span class="uncovered">            return 0</span>
<span class="line-number">140</span><span class="uncovered">        except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">141</span><span class="uncovered">            logging.error(&quot;Error during transformation: %s&quot;, e)</span>
<span class="line-number">142</span><span class="uncovered">            return 1</span>
<span class="line-number">143</span>
<span class="line-number">144</span>    # Generate command
<span class="line-number">145</span>    if args.command == &quot;generate&quot;:
<span class="line-number">146</span><span class="uncovered">        try:</span>
<span class="line-number">147</span><span class="uncovered">            generator = Generator()</span>
<span class="line-number">148</span>            # Prefer transformed model, else fallback to model.json
<span class="line-number">149</span><span class="uncovered">            if os.path.exists(transformed_model_file):</span>
<span class="line-number">150</span><span class="uncovered">                model_to_use = transformed_model_file</span>
<span class="line-number">151</span><span class="uncovered">            elif os.path.exists(model_file):</span>
<span class="line-number">152</span><span class="uncovered">                model_to_use = model_file</span>
<span class="line-number">153</span>            else:
<span class="line-number">154</span><span class="uncovered">                logging.error(&quot;No model file found for generation.&quot;)</span>
<span class="line-number">155</span><span class="uncovered">                return 1</span>
<span class="line-number">156</span><span class="uncovered">            generator.generate(</span>
<span class="line-number">157</span>                model_file=model_to_use,
<span class="line-number">158</span>                output_dir=output_folder,
<span class="line-number">159</span>                include_depth=getattr(config, &quot;include_depth&quot;, 1),
<span class="line-number">160</span>            )
<span class="line-number">161</span><span class="uncovered">            logging.info(&quot;PlantUML generation complete! Output in: %s&quot;, output_folder)</span>
<span class="line-number">162</span><span class="uncovered">            return 0</span>
<span class="line-number">163</span><span class="uncovered">        except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">164</span><span class="uncovered">            logging.error(&quot;Error generating PlantUML: %s&quot;, e)</span>
<span class="line-number">165</span><span class="uncovered">            return 1</span>
<span class="line-number">166</span>
<span class="line-number">167</span>    # Default: full workflow
<span class="line-number">168</span>    try:
<span class="line-number">169</span>        # Step 1: Parse
<span class="line-number">170</span>        parser_obj = Parser()
<span class="line-number">171</span>        # Use the refactored parse function that handles both single and multiple source folders
<span class="line-number">172</span>        parser_obj.parse(
<span class="line-number">173</span>            project_root=config.source_folders,
<span class="line-number">174</span>            output_file=model_file,
<span class="line-number">175</span>            recursive_search=getattr(config, &quot;recursive_search&quot;, True),
<span class="line-number">176</span>            config=config,
<span class="line-number">177</span>        )
<span class="line-number">178</span>        logging.info(&quot;Model saved to: %s&quot;, model_file)
<span class="line-number">179</span>        # Step 2: Transform
<span class="line-number">180</span>        transformer = Transformer()
<span class="line-number">181</span>        transformer.transform(
<span class="line-number">182</span>            model_file=model_file,
<span class="line-number">183</span>            config_file=(
<span class="line-number">184</span>                config_path
<span class="line-number">185</span>                if Path(config_path).is_file()
<span class="line-number">186</span>                else str(list(Path(config_path).glob(&quot;*.json&quot;))[0])
<span class="line-number">187</span>            ),
<span class="line-number">188</span>            output_file=transformed_model_file,
<span class="line-number">189</span>        )
<span class="line-number">190</span>        logging.info(&quot;Transformed model saved to: %s&quot;, transformed_model_file)
<span class="line-number">191</span>        # Step 3: Generate
<span class="line-number">192</span>        generator = Generator()
<span class="line-number">193</span>        generator.generate(
<span class="line-number">194</span>            model_file=transformed_model_file,
<span class="line-number">195</span>            output_dir=output_folder,
<span class="line-number">196</span>            include_depth=getattr(config, &quot;include_depth&quot;, 1),
<span class="line-number">197</span>        )
<span class="line-number">198</span>        logging.info(&quot;PlantUML generation complete! Output in: %s&quot;, output_folder)
<span class="line-number">199</span>        logging.info(&quot;Complete workflow finished successfully!&quot;)
<span class="line-number">200</span>        return 0
<span class="line-number">201</span><span class="uncovered">    except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">202</span><span class="uncovered">        logging.error(&quot;Error in workflow: %s&quot;, e)</span>
<span class="line-number">203</span><span class="uncovered">        return 1</span>
<span class="line-number">204</span>
<span class="line-number">205</span>
<span class="line-number">206</span>if __name__ == &quot;__main__&quot;:
<span class="line-number">207</span>    sys.exit(main())
</pre>
<h4>Function: load_config_from_path (lines 33-205)</h4>
<pre>
<span class="line-number"> 33</span>def load_config_from_path(config_path: str) -&gt; dict:
<span class="line-number"> 34</span>    path = Path(config_path)
<span class="line-number"> 35</span>    if path.is_file():
<span class="line-number"> 36</span>        with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number"> 37</span>            return json.load(f)
<span class="line-number"> 38</span><span class="uncovered">    elif path.is_dir():</span>
<span class="line-number"> 39</span>        # Merge all .json files in the folder
<span class="line-number"> 40</span><span class="uncovered">        config = {}</span>
<span class="line-number"> 41</span><span class="uncovered">        for file in path.glob(&quot;*.json&quot;):</span>
<span class="line-number"> 42</span><span class="uncovered">            with open(file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:</span>
<span class="line-number"> 43</span><span class="uncovered">                data = json.load(f)</span>
<span class="line-number"> 44</span><span class="uncovered">                config.update(data)</span>
<span class="line-number"> 45</span><span class="uncovered">        return config</span>
<span class="line-number"> 46</span>    else:
<span class="line-number"> 47</span><span class="uncovered">        raise FileNotFoundError(f&quot;Config path not found: {config_path}&quot;)</span>
<span class="line-number"> 48</span>
<span class="line-number"> 49</span>
<span class="line-number"> 50</span>def main() -&gt; int:
<span class="line-number"> 51</span>    parser = argparse.ArgumentParser(
<span class="line-number"> 52</span>        description=&quot;C to PlantUML Converter (Simplified CLI)&quot;,
<span class="line-number"> 53</span>        formatter_class=argparse.RawDescriptionHelpFormatter,
<span class="line-number"> 54</span>        epilog=&quot;&quot;&quot;
<span class="line-number"> 55</span>Usage:
<span class="line-number"> 56</span>  %(prog)s --config config.json [parse|transform|generate]
<span class="line-number"> 57</span>  %(prog)s config_folder [parse|transform|generate]
<span class="line-number"> 58</span>  %(prog)s [parse|transform|generate]  # Uses current directory as config folder
<span class="line-number"> 59</span>  %(prog)s              # Full workflow (parse, transform, generate)
<span class="line-number"> 60</span>        &quot;&quot;&quot;,
<span class="line-number"> 61</span>    )
<span class="line-number"> 62</span>    parser.add_argument(
<span class="line-number"> 63</span>        &quot;--config&quot;,
<span class="line-number"> 64</span>        &quot;-c&quot;,
<span class="line-number"> 65</span>        type=str,
<span class="line-number"> 66</span>        default=None,
<span class="line-number"> 67</span>        help=&quot;Path to config.json or config folder (optional, default: current directory)&quot;,
<span class="line-number"> 68</span>    )
<span class="line-number"> 69</span>    parser.add_argument(
<span class="line-number"> 70</span>        &quot;command&quot;,
<span class="line-number"> 71</span>        nargs=&quot;?&quot;,
<span class="line-number"> 72</span>        choices=[&quot;parse&quot;, &quot;transform&quot;, &quot;generate&quot;],
<span class="line-number"> 73</span>        help=&quot;Which step to run: parse, transform, or generate. If omitted, runs full workflow.&quot;,
<span class="line-number"> 74</span>    )
<span class="line-number"> 75</span>    parser.add_argument(
<span class="line-number"> 76</span>        &quot;--verbose&quot;, &quot;-v&quot;, action=&quot;store_true&quot;, help=&quot;Enable verbose output&quot;
<span class="line-number"> 77</span>    )
<span class="line-number"> 78</span>    args = parser.parse_args()
<span class="line-number"> 79</span>
<span class="line-number"> 80</span>    setup_logging(args.verbose)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>    # Determine config path
<span class="line-number"> 83</span>    config_path = args.config
<span class="line-number"> 84</span>    if config_path is None:
<span class="line-number"> 85</span><span class="uncovered">        config_path = os.getcwd()</span>
<span class="line-number"> 86</span>
<span class="line-number"> 87</span>    logging.info(&quot;Using config: %s&quot;, config_path)
<span class="line-number"> 88</span>
<span class="line-number"> 89</span>    # Load config
<span class="line-number"> 90</span>    try:
<span class="line-number"> 91</span>        config_data = load_config_from_path(config_path)
<span class="line-number"> 92</span>        config = Config(**config_data)
<span class="line-number"> 93</span><span class="uncovered">    except Exception as e:</span>
<span class="line-number"> 94</span><span class="uncovered">        logging.error(&quot;Failed to load configuration: %s&quot;, e)</span>
<span class="line-number"> 95</span><span class="uncovered">        return 1</span>
<span class="line-number"> 96</span>
<span class="line-number"> 97</span>    # Determine output folder from config, default to ./output
<span class="line-number"> 98</span>    output_folder = getattr(config, &quot;output_dir&quot;, None) or os.path.join(
<span class="line-number"> 99</span>        os.getcwd(), &quot;output&quot;
<span class="line-number">100</span>    )
<span class="line-number">101</span>    output_folder = os.path.abspath(output_folder)
<span class="line-number">102</span>    os.makedirs(output_folder, exist_ok=True)
<span class="line-number">103</span>    logging.info(&quot;Output folder: %s&quot;, output_folder)
<span class="line-number">104</span>
<span class="line-number">105</span>    model_file = os.path.join(output_folder, &quot;model.json&quot;)
<span class="line-number">106</span>    transformed_model_file = os.path.join(output_folder, &quot;model_transformed.json&quot;)
<span class="line-number">107</span>
<span class="line-number">108</span>    # Parse command
<span class="line-number">109</span>    if args.command == &quot;parse&quot;:
<span class="line-number">110</span><span class="uncovered">        try:</span>
<span class="line-number">111</span><span class="uncovered">            parser_obj = Parser()</span>
<span class="line-number">112</span>            # Use the refactored parse function that handles both single and multiple source folders
<span class="line-number">113</span><span class="uncovered">            parser_obj.parse(</span>
<span class="line-number">114</span>                project_root=config.source_folders,
<span class="line-number">115</span>                output_file=model_file,
<span class="line-number">116</span>                recursive_search=getattr(config, &quot;recursive_search&quot;, True),
<span class="line-number">117</span>                config=config,
<span class="line-number">118</span>            )
<span class="line-number">119</span><span class="uncovered">            logging.info(&quot;Model saved to: %s&quot;, model_file)</span>
<span class="line-number">120</span><span class="uncovered">            return 0</span>
<span class="line-number">121</span><span class="uncovered">        except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">122</span><span class="uncovered">            logging.error(&quot;Error during parsing: %s&quot;, e)</span>
<span class="line-number">123</span><span class="uncovered">            return 1</span>
<span class="line-number">124</span>
<span class="line-number">125</span>    # Transform command
<span class="line-number">126</span>    if args.command == &quot;transform&quot;:
<span class="line-number">127</span><span class="uncovered">        try:</span>
<span class="line-number">128</span><span class="uncovered">            transformer = Transformer()</span>
<span class="line-number">129</span><span class="uncovered">            transformer.transform(</span>
<span class="line-number">130</span>                model_file=model_file,
<span class="line-number">131</span>                config_file=(
<span class="line-number">132</span>                    config_path
<span class="line-number">133</span>                    if Path(config_path).is_file()
<span class="line-number">134</span>                    else str(list(Path(config_path).glob(&quot;*.json&quot;))[0])
<span class="line-number">135</span>                ),
<span class="line-number">136</span>                output_file=transformed_model_file,
<span class="line-number">137</span>            )
<span class="line-number">138</span><span class="uncovered">            logging.info(&quot;Transformed model saved to: %s&quot;, transformed_model_file)</span>
<span class="line-number">139</span><span class="uncovered">            return 0</span>
<span class="line-number">140</span><span class="uncovered">        except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">141</span><span class="uncovered">            logging.error(&quot;Error during transformation: %s&quot;, e)</span>
<span class="line-number">142</span><span class="uncovered">            return 1</span>
<span class="line-number">143</span>
<span class="line-number">144</span>    # Generate command
<span class="line-number">145</span>    if args.command == &quot;generate&quot;:
<span class="line-number">146</span><span class="uncovered">        try:</span>
<span class="line-number">147</span><span class="uncovered">            generator = Generator()</span>
<span class="line-number">148</span>            # Prefer transformed model, else fallback to model.json
<span class="line-number">149</span><span class="uncovered">            if os.path.exists(transformed_model_file):</span>
<span class="line-number">150</span><span class="uncovered">                model_to_use = transformed_model_file</span>
<span class="line-number">151</span><span class="uncovered">            elif os.path.exists(model_file):</span>
<span class="line-number">152</span><span class="uncovered">                model_to_use = model_file</span>
<span class="line-number">153</span>            else:
<span class="line-number">154</span><span class="uncovered">                logging.error(&quot;No model file found for generation.&quot;)</span>
<span class="line-number">155</span><span class="uncovered">                return 1</span>
<span class="line-number">156</span><span class="uncovered">            generator.generate(</span>
<span class="line-number">157</span>                model_file=model_to_use,
<span class="line-number">158</span>                output_dir=output_folder,
<span class="line-number">159</span>                include_depth=getattr(config, &quot;include_depth&quot;, 1),
<span class="line-number">160</span>            )
<span class="line-number">161</span><span class="uncovered">            logging.info(&quot;PlantUML generation complete! Output in: %s&quot;, output_folder)</span>
<span class="line-number">162</span><span class="uncovered">            return 0</span>
<span class="line-number">163</span><span class="uncovered">        except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">164</span><span class="uncovered">            logging.error(&quot;Error generating PlantUML: %s&quot;, e)</span>
<span class="line-number">165</span><span class="uncovered">            return 1</span>
<span class="line-number">166</span>
<span class="line-number">167</span>    # Default: full workflow
<span class="line-number">168</span>    try:
<span class="line-number">169</span>        # Step 1: Parse
<span class="line-number">170</span>        parser_obj = Parser()
<span class="line-number">171</span>        # Use the refactored parse function that handles both single and multiple source folders
<span class="line-number">172</span>        parser_obj.parse(
<span class="line-number">173</span>            project_root=config.source_folders,
<span class="line-number">174</span>            output_file=model_file,
<span class="line-number">175</span>            recursive_search=getattr(config, &quot;recursive_search&quot;, True),
<span class="line-number">176</span>            config=config,
<span class="line-number">177</span>        )
<span class="line-number">178</span>        logging.info(&quot;Model saved to: %s&quot;, model_file)
<span class="line-number">179</span>        # Step 2: Transform
<span class="line-number">180</span>        transformer = Transformer()
<span class="line-number">181</span>        transformer.transform(
<span class="line-number">182</span>            model_file=model_file,
<span class="line-number">183</span>            config_file=(
<span class="line-number">184</span>                config_path
<span class="line-number">185</span>                if Path(config_path).is_file()
<span class="line-number">186</span>                else str(list(Path(config_path).glob(&quot;*.json&quot;))[0])
<span class="line-number">187</span>            ),
<span class="line-number">188</span>            output_file=transformed_model_file,
<span class="line-number">189</span>        )
<span class="line-number">190</span>        logging.info(&quot;Transformed model saved to: %s&quot;, transformed_model_file)
<span class="line-number">191</span>        # Step 3: Generate
<span class="line-number">192</span>        generator = Generator()
<span class="line-number">193</span>        generator.generate(
<span class="line-number">194</span>            model_file=transformed_model_file,
<span class="line-number">195</span>            output_dir=output_folder,
<span class="line-number">196</span>            include_depth=getattr(config, &quot;include_depth&quot;, 1),
<span class="line-number">197</span>        )
<span class="line-number">198</span>        logging.info(&quot;PlantUML generation complete! Output in: %s&quot;, output_folder)
<span class="line-number">199</span>        logging.info(&quot;Complete workflow finished successfully!&quot;)
<span class="line-number">200</span>        return 0
<span class="line-number">201</span><span class="uncovered">    except (OSError, ValueError, RuntimeError) as e:</span>
<span class="line-number">202</span><span class="uncovered">        logging.error(&quot;Error in workflow: %s&quot;, e)</span>
<span class="line-number">203</span><span class="uncovered">        return 1</span>
<span class="line-number">204</span>
<span class="line-number">205</span>
</pre>
</div>
<div class="file-section">
<div class="file-header">
/home/runner/work/generator_project/generator_project/c_to_plantuml/generator.py - 85.91% coverage (250/291 lines)
</div>
<h4>Function: __init__ (lines 17-466)</h4>
<pre>
<span class="line-number"> 17</span>    def __init__(self):
<span class="line-number"> 18</span>        pass
<span class="line-number"> 19</span>
<span class="line-number"> 20</span>    def generate_diagram(
<span class="line-number"> 21</span>        self, file_model: FileModel, project_model: ProjectModel, include_depth: int = 1
<span class="line-number"> 22</span>    ) -&gt; str:
<span class="line-number"> 23</span>        &quot;&quot;&quot;Generate a PlantUML diagram for a file following the template format&quot;&quot;&quot;
<span class="line-number"> 24</span>        basename = Path(file_model.file_path).stem
<span class="line-number"> 25</span>
<span class="line-number"> 26</span>        # Build include tree for this file
<span class="line-number"> 27</span>        include_tree = self._build_include_tree(
<span class="line-number"> 28</span>            file_model, project_model, include_depth
<span class="line-number"> 29</span>        )
<span class="line-number"> 30</span>
<span class="line-number"> 31</span>        # Get UML IDs for all elements in the include tree
<span class="line-number"> 32</span>        uml_ids = self._generate_uml_ids(include_tree, project_model)
<span class="line-number"> 33</span>
<span class="line-number"> 34</span>        # Generate PlantUML content
<span class="line-number"> 35</span>        lines = []
<span class="line-number"> 36</span>        lines.append(f&quot;@startuml {basename}&quot;)
<span class="line-number"> 37</span>        lines.append(&quot;&quot;)
<span class="line-number"> 38</span>
<span class="line-number"> 39</span>        # Generate classes for C files in include tree
<span class="line-number"> 40</span>        for file_path, file_data in sorted(include_tree.items()):
<span class="line-number"> 41</span>            if file_path.endswith(&quot;.c&quot;):
<span class="line-number"> 42</span>                self._generate_c_file_class(lines, file_data, uml_ids)
<span class="line-number"> 43</span>
<span class="line-number"> 44</span>        # Generate classes for H files in include tree
<span class="line-number"> 45</span>        for file_path, file_data in sorted(include_tree.items()):
<span class="line-number"> 46</span>            if file_path.endswith(&quot;.h&quot;):
<span class="line-number"> 47</span>                self._generate_header_class(lines, file_data, uml_ids)
<span class="line-number"> 48</span>
<span class="line-number"> 49</span>        # Generate typedef classes
<span class="line-number"> 50</span>        for file_path, file_data in sorted(include_tree.items()):
<span class="line-number"> 51</span>            self._generate_typedef_classes(lines, file_data, uml_ids)
<span class="line-number"> 52</span>
<span class="line-number"> 53</span>        lines.append(&quot;&quot;)
<span class="line-number"> 54</span>
<span class="line-number"> 55</span>        # Generate relationships
<span class="line-number"> 56</span>        self._generate_relationships(lines, include_tree, uml_ids, project_model)
<span class="line-number"> 57</span>
<span class="line-number"> 58</span>        lines.append(&quot;&quot;)
<span class="line-number"> 59</span>        lines.append(&quot;@enduml&quot;)
<span class="line-number"> 60</span>
<span class="line-number"> 61</span>        return &quot;\n&quot;.join(lines)
<span class="line-number"> 62</span>
<span class="line-number"> 63</span>    def _build_include_tree(
<span class="line-number"> 64</span>        self, root_file: FileModel, project_model: ProjectModel, include_depth: int
<span class="line-number"> 65</span>    ) -&gt; Dict[str, FileModel]:
<span class="line-number"> 66</span>        &quot;&quot;&quot;Build include tree starting from root file&quot;&quot;&quot;
<span class="line-number"> 67</span>        include_tree = {}
<span class="line-number"> 68</span>        visited = set()
<span class="line-number"> 69</span>
<span class="line-number"> 70</span>        def find_file_key(file_name: str) -&gt; str:
<span class="line-number"> 71</span>            &quot;&quot;&quot;Find the correct key for a file in project_model.files using path matching&quot;&quot;&quot;
<span class="line-number"> 72</span>            # First try exact match
<span class="line-number"> 73</span>            if file_name in project_model.files:
<span class="line-number"> 74</span>                return file_name
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>            # Try matching by filename
<span class="line-number"> 77</span>            filename = Path(file_name).name
<span class="line-number"> 78</span>            if filename in project_model.files:
<span class="line-number"> 79</span><span class="uncovered">                return filename</span>
<span class="line-number"> 80</span>
<span class="line-number"> 81</span>            # Try matching by relative path
<span class="line-number"> 82</span>            for key in project_model.files.keys():
<span class="line-number"> 83</span>                if Path(key).name == filename:
<span class="line-number"> 84</span>                    return key
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>            # If not found, return the filename (will be handled gracefully)
<span class="line-number"> 87</span>            return filename
<span class="line-number"> 88</span>
<span class="line-number"> 89</span>        def add_file_to_tree(file_name: str, depth: int):
<span class="line-number"> 90</span>            if depth &gt; include_depth or file_name in visited:
<span class="line-number"> 91</span><span class="uncovered">                return</span>
<span class="line-number"> 92</span>
<span class="line-number"> 93</span>            visited.add(file_name)
<span class="line-number"> 94</span>            file_key = find_file_key(file_name)
<span class="line-number"> 95</span>
<span class="line-number"> 96</span>            if file_key in project_model.files:
<span class="line-number"> 97</span>                include_tree[file_key] = project_model.files[file_key]
<span class="line-number"> 98</span>
<span class="line-number"> 99</span>                # Add included files
<span class="line-number">100</span>                if depth &lt; include_depth:
<span class="line-number">101</span>                    for include in project_model.files[file_key].includes:
<span class="line-number">102</span>                        # Clean the include name (remove quotes/angle brackets)
<span class="line-number">103</span>                        clean_include = include.strip(&#x27;&lt;&gt;&quot;&#x27;)
<span class="line-number">104</span>                        add_file_to_tree(clean_include, depth + 1)
<span class="line-number">105</span>
<span class="line-number">106</span>        # Start with the root file - find the correct key
<span class="line-number">107</span>        root_key = find_file_key(root_file.relative_path)
<span class="line-number">108</span>        add_file_to_tree(root_key, 0)
<span class="line-number">109</span>
<span class="line-number">110</span>        return include_tree
<span class="line-number">111</span>
<span class="line-number">112</span>    def _generate_uml_ids(
<span class="line-number">113</span>        self, include_tree: Dict[str, FileModel], project_model: ProjectModel
<span class="line-number">114</span>    ) -&gt; Dict[str, str]:
<span class="line-number">115</span>        &quot;&quot;&quot;Generate UML IDs for all elements in the include tree using filename-based keys&quot;&quot;&quot;
<span class="line-number">116</span>        uml_ids = {}
<span class="line-number">117</span>
<span class="line-number">118</span>        for filename, file_model in include_tree.items():
<span class="line-number">119</span>            basename = Path(filename).stem.upper()
<span class="line-number">120</span>            file_key = Path(filename).name  # Use just the filename as key
<span class="line-number">121</span>
<span class="line-number">122</span>            if filename.endswith(&quot;.c&quot;):
<span class="line-number">123</span>                # C files: no prefix
<span class="line-number">124</span>                uml_ids[file_key] = basename
<span class="line-number">125</span>            elif filename.endswith(&quot;.h&quot;):
<span class="line-number">126</span>                # H files: HEADER_ prefix
<span class="line-number">127</span>                uml_ids[file_key] = f&quot;HEADER_{basename}&quot;
<span class="line-number">128</span>
<span class="line-number">129</span>            # Generate typedef UML IDs
<span class="line-number">130</span>            for typedef_name in file_model.structs:
<span class="line-number">131</span>                uml_ids[f&quot;typedef_{typedef_name}&quot;] = f&quot;TYPEDEF_{typedef_name.upper()}&quot;
<span class="line-number">132</span>            for typedef_name in file_model.enums:
<span class="line-number">133</span>                uml_ids[f&quot;typedef_{typedef_name}&quot;] = f&quot;TYPEDEF_{typedef_name.upper()}&quot;
<span class="line-number">134</span>            for typedef_name in file_model.aliases:
<span class="line-number">135</span>                uml_ids[f&quot;typedef_{typedef_name}&quot;] = f&quot;TYPEDEF_{typedef_name.upper()}&quot;
<span class="line-number">136</span>            for typedef_name in file_model.unions:
<span class="line-number">137</span>                uml_ids[f&quot;typedef_{typedef_name}&quot;] = f&quot;TYPEDEF_{typedef_name.upper()}&quot;
<span class="line-number">138</span>
<span class="line-number">139</span>        return uml_ids
<span class="line-number">140</span>
<span class="line-number">141</span>    def _generate_c_file_class(
<span class="line-number">142</span>        self, lines: List[str], file_model: FileModel, uml_ids: Dict[str, str]
<span class="line-number">143</span>    ):
<span class="line-number">144</span>        &quot;&quot;&quot;Generate class for C file using filename-based keys&quot;&quot;&quot;
<span class="line-number">145</span>        basename = Path(file_model.relative_path).stem
<span class="line-number">146</span>
<span class="line-number">147</span>        # Find the UML ID for this file using filename
<span class="line-number">148</span>        filename = Path(file_model.relative_path).name
<span class="line-number">149</span>        uml_id = uml_ids.get(filename)
<span class="line-number">150</span>
<span class="line-number">151</span>        if not uml_id:
<span class="line-number">152</span><span class="uncovered">            return  # Skip if no UML ID found</span>
<span class="line-number">153</span>
<span class="line-number">154</span>        lines.append(f&#x27;class &quot;{basename}&quot; as {uml_id} &lt;&lt;source&gt;&gt; #LightBlue&#x27;)
<span class="line-number">155</span>        lines.append(&quot;{&quot;)
<span class="line-number">156</span>
<span class="line-number">157</span>        # Add macros
<span class="line-number">158</span>        if file_model.macros:
<span class="line-number">159</span>            lines.append(&quot;    -- Macros --&quot;)
<span class="line-number">160</span>            for macro in sorted(file_model.macros):
<span class="line-number">161</span>                if &quot;(&quot; in macro and &quot;)&quot; in macro:
<span class="line-number">162</span>                    # Function-like macro
<span class="line-number">163</span><span class="uncovered">                    macro_name = macro.split(&quot;(&quot;)[0].replace(&quot;#define &quot;, &quot;&quot;)</span>
<span class="line-number">164</span><span class="uncovered">                    params = macro.split(&quot;(&quot;)[1].split(&quot;)&quot;)[0]</span>
<span class="line-number">165</span><span class="uncovered">                    lines.append(f&quot;    - #define {macro_name}({params})&quot;)</span>
<span class="line-number">166</span>                else:
<span class="line-number">167</span>                    # Simple macro
<span class="line-number">168</span>                    macro_name = macro.replace(&quot;#define &quot;, &quot;&quot;)
<span class="line-number">169</span>                    lines.append(f&quot;    - #define {macro_name}&quot;)
<span class="line-number">170</span>
<span class="line-number">171</span>        # Add global variables
<span class="line-number">172</span>        if file_model.globals:
<span class="line-number">173</span>            lines.append(&quot;    -- Global Variables --&quot;)
<span class="line-number">174</span>            for global_var in sorted(file_model.globals, key=lambda x: x.name):
<span class="line-number">175</span>                lines.append(f&quot;    {global_var.type} {global_var.name}&quot;)
<span class="line-number">176</span>
<span class="line-number">177</span>        # Add functions
<span class="line-number">178</span>        if file_model.functions:
<span class="line-number">179</span>            lines.append(&quot;    -- Functions --&quot;)
<span class="line-number">180</span>            for func in sorted(file_model.functions, key=lambda x: x.name):
<span class="line-number">181</span>                if not func.is_declaration:  # Only implementation, not declarations
<span class="line-number">182</span>                    params = []
<span class="line-number">183</span>                    for p in func.parameters:
<span class="line-number">184</span>                        if p.name == &quot;...&quot; and p.type == &quot;...&quot;:
<span class="line-number">185</span><span class="uncovered">                            params.append(&quot;...&quot;)</span>
<span class="line-number">186</span>                        else:
<span class="line-number">187</span>                            params.append(f&quot;{p.type} {p.name}&quot;)
<span class="line-number">188</span>                    param_str = &quot;, &quot;.join(params)
<span class="line-number">189</span>                    lines.append(f&quot;    {func.return_type} {func.name}({param_str})&quot;)
<span class="line-number">190</span>
<span class="line-number">191</span>        lines.append(&quot;}&quot;)
<span class="line-number">192</span>        lines.append(&quot;&quot;)
<span class="line-number">193</span>
<span class="line-number">194</span>    def _generate_header_class(
<span class="line-number">195</span>        self, lines: List[str], file_model: FileModel, uml_ids: Dict[str, str]
<span class="line-number">196</span>    ):
<span class="line-number">197</span>        &quot;&quot;&quot;Generate class for header file using filename-based keys&quot;&quot;&quot;
<span class="line-number">198</span>        basename = Path(file_model.relative_path).stem
<span class="line-number">199</span>
<span class="line-number">200</span>        # Find the UML ID for this file using filename
<span class="line-number">201</span>        filename = Path(file_model.relative_path).name
<span class="line-number">202</span>        uml_id = uml_ids.get(filename)
<span class="line-number">203</span>
<span class="line-number">204</span>        if not uml_id:
<span class="line-number">205</span><span class="uncovered">            return  # Skip if no UML ID found</span>
<span class="line-number">206</span>
<span class="line-number">207</span>        lines.append(f&#x27;class &quot;{basename}&quot; as {uml_id} &lt;&lt;header&gt;&gt; #LightGreen&#x27;)
<span class="line-number">208</span>        lines.append(&quot;{&quot;)
<span class="line-number">209</span>
<span class="line-number">210</span>        # Add macros
<span class="line-number">211</span>        if file_model.macros:
<span class="line-number">212</span>            lines.append(&quot;    -- Macros --&quot;)
<span class="line-number">213</span>            for macro in sorted(file_model.macros):
<span class="line-number">214</span>                if &quot;(&quot; in macro and &quot;)&quot; in macro:
<span class="line-number">215</span>                    # Function-like macro
<span class="line-number">216</span><span class="uncovered">                    macro_name = macro.split(&quot;(&quot;)[0].replace(&quot;#define &quot;, &quot;&quot;)</span>
<span class="line-number">217</span><span class="uncovered">                    params = macro.split(&quot;(&quot;)[1].split(&quot;)&quot;)[0]</span>
<span class="line-number">218</span><span class="uncovered">                    lines.append(f&quot;    + #define {macro_name}({params})&quot;)</span>
<span class="line-number">219</span>                else:
<span class="line-number">220</span>                    # Simple macro
<span class="line-number">221</span>                    macro_name = macro.replace(&quot;#define &quot;, &quot;&quot;)
<span class="line-number">222</span>                    lines.append(f&quot;    + #define {macro_name}&quot;)
<span class="line-number">223</span>
<span class="line-number">224</span>        # Add global variables
<span class="line-number">225</span>        if file_model.globals:
<span class="line-number">226</span>            lines.append(&quot;    -- Global Variables --&quot;)
<span class="line-number">227</span>            for global_var in sorted(file_model.globals, key=lambda x: x.name):
<span class="line-number">228</span>                lines.append(f&quot;    + {global_var.type} {global_var.name}&quot;)
<span class="line-number">229</span>
<span class="line-number">230</span>        # Add functions (only declarations)
<span class="line-number">231</span>        if file_model.functions:
<span class="line-number">232</span>            lines.append(&quot;    -- Functions --&quot;)
<span class="line-number">233</span>            for func in sorted(file_model.functions, key=lambda x: x.name):
<span class="line-number">234</span>                if func.is_declaration:  # Only declarations
<span class="line-number">235</span>                    params = []
<span class="line-number">236</span>                    for p in func.parameters:
<span class="line-number">237</span>                        if p.name == &quot;...&quot; and p.type == &quot;...&quot;:
<span class="line-number">238</span>                            params.append(&quot;...&quot;)
<span class="line-number">239</span>                        else:
<span class="line-number">240</span>                            params.append(f&quot;{p.type} {p.name}&quot;)
<span class="line-number">241</span>                    param_str = &quot;, &quot;.join(params)
<span class="line-number">242</span>                    lines.append(f&quot;    + {func.return_type} {func.name}({param_str})&quot;)
<span class="line-number">243</span>
<span class="line-number">244</span>        lines.append(&quot;}&quot;)
<span class="line-number">245</span>        lines.append(&quot;&quot;)
<span class="line-number">246</span>
<span class="line-number">247</span>    def _generate_typedef_classes(
<span class="line-number">248</span>        self, lines: List[str], file_model: FileModel, uml_ids: Dict[str, str]
<span class="line-number">249</span>    ):
<span class="line-number">250</span>        &quot;&quot;&quot;Generate classes for typedefs&quot;&quot;&quot;
<span class="line-number">251</span>        # Structs
<span class="line-number">252</span>        for struct_name, struct_data in sorted(file_model.structs.items()):
<span class="line-number">253</span>            uml_id = uml_ids.get(f&quot;typedef_{struct_name}&quot;)
<span class="line-number">254</span>            if uml_id:
<span class="line-number">255</span>                lines.append(
<span class="line-number">256</span>                    f&#x27;class &quot;{struct_name}&quot; as {uml_id} &lt;&lt;typedef&gt;&gt; #LightYellow&#x27;
<span class="line-number">257</span>                )
<span class="line-number">258</span>                lines.append(&quot;{&quot;)
<span class="line-number">259</span>                for field in sorted(struct_data.fields, key=lambda x: x.name):
<span class="line-number">260</span>                    self._generate_field_with_nested_structs(lines, field, &quot;    &quot;)
<span class="line-number">261</span>                lines.append(&quot;}&quot;)
<span class="line-number">262</span>                lines.append(&quot;&quot;)
<span class="line-number">263</span>
<span class="line-number">264</span>        # Enums
<span class="line-number">265</span>        for enum_name, enum_data in sorted(file_model.enums.items()):
<span class="line-number">266</span>            uml_id = uml_ids.get(f&quot;typedef_{enum_name}&quot;)
<span class="line-number">267</span>            if uml_id:
<span class="line-number">268</span>                lines.append(
<span class="line-number">269</span>                    f&#x27;class &quot;{enum_name}&quot; as {uml_id} &lt;&lt;typedef&gt;&gt; #LightYellow&#x27;
<span class="line-number">270</span>                )
<span class="line-number">271</span>                lines.append(&quot;{&quot;)
<span class="line-number">272</span>                for value in sorted(enum_data.values, key=lambda x: x.name):
<span class="line-number">273</span>                    if value.value:
<span class="line-number">274</span><span class="uncovered">                        lines.append(f&quot;    + {value.name} = {value.value}&quot;)</span>
<span class="line-number">275</span>                    else:
<span class="line-number">276</span>                        lines.append(f&quot;    + {value.name}&quot;)
<span class="line-number">277</span>                lines.append(&quot;}&quot;)
<span class="line-number">278</span>                lines.append(&quot;&quot;)
<span class="line-number">279</span>
<span class="line-number">280</span>        # Aliases (simple typedefs)
<span class="line-number">281</span>        for alias_name, alias_data in sorted(file_model.aliases.items()):
<span class="line-number">282</span>            uml_id = uml_ids.get(f&quot;typedef_{alias_name}&quot;)
<span class="line-number">283</span>            if uml_id:
<span class="line-number">284</span>                lines.append(
<span class="line-number">285</span>                    f&#x27;class &quot;{alias_name}&quot; as {uml_id} &lt;&lt;typedef&gt;&gt; #LightYellow&#x27;
<span class="line-number">286</span>                )
<span class="line-number">287</span>                lines.append(&quot;{&quot;)
<span class="line-number">288</span>                # Handle multi-line alias types with proper nested struct indentation
<span class="line-number">289</span>                alias_lines = alias_data.original_type.split(&#x27;\n&#x27;)
<span class="line-number">290</span>                inside_struct = False
<span class="line-number">291</span>                nested_content = []
<span class="line-number">292</span>
<span class="line-number">293</span>                for i, line in enumerate(alias_lines):
<span class="line-number">294</span>                    line = line.strip()
<span class="line-number">295</span>
<span class="line-number">296</span>                    if i == 0:
<span class="line-number">297</span>                        lines.append(f&quot;    + {line}&quot;)
<span class="line-number">298</span><span class="uncovered">                    elif line.startswith(&quot;struct {&quot;):</span>
<span class="line-number">299</span>                        # Start collecting nested struct content
<span class="line-number">300</span><span class="uncovered">                        inside_struct = True</span>
<span class="line-number">301</span><span class="uncovered">                        nested_content = []</span>
<span class="line-number">302</span><span class="uncovered">                    elif line == &quot;}&quot;:</span>
<span class="line-number">303</span><span class="uncovered">                        if inside_struct:</span>
<span class="line-number">304</span>                            # Close nested struct with flattened content
<span class="line-number">305</span><span class="uncovered">                            if nested_content:</span>
<span class="line-number">306</span><span class="uncovered">                                content_str = &quot;; &quot;.join(nested_content)</span>
<span class="line-number">307</span><span class="uncovered">                                lines.append(f&quot;    + struct {{ {content_str} }}&quot;)</span>
<span class="line-number">308</span>                            else:
<span class="line-number">309</span><span class="uncovered">                                lines.append(f&quot;    + struct {{ }}&quot;)</span>
<span class="line-number">310</span><span class="uncovered">                            inside_struct = False</span>
<span class="line-number">311</span><span class="uncovered">                            nested_content = []</span>
<span class="line-number">312</span>                        else:
<span class="line-number">313</span><span class="uncovered">                            lines.append(f&quot;    }}&quot;)</span>
<span class="line-number">314</span><span class="uncovered">                    elif line and line != &quot;}&quot;:</span>
<span class="line-number">315</span><span class="uncovered">                        if inside_struct:</span>
<span class="line-number">316</span><span class="uncovered">                            nested_content.append(line)  # Collect nested content</span>
<span class="line-number">317</span>                        else:
<span class="line-number">318</span><span class="uncovered">                            lines.append(f&quot;+ {line}&quot;)</span>
<span class="line-number">319</span>
<span class="line-number">320</span>                # If we were inside a struct but didn&#x27;t find a closing brace, add one
<span class="line-number">321</span>                if inside_struct and nested_content:
<span class="line-number">322</span><span class="uncovered">                    content_str = &quot;; &quot;.join(nested_content)</span>
<span class="line-number">323</span><span class="uncovered">                    lines.append(f&quot;    + struct {{ {content_str} }}&quot;)</span>
<span class="line-number">324</span>                lines.append(&quot;}&quot;)
<span class="line-number">325</span>                lines.append(&quot;&quot;)
<span class="line-number">326</span>
<span class="line-number">327</span>        # Unions
<span class="line-number">328</span>        for union_name, union_data in sorted(file_model.unions.items()):
<span class="line-number">329</span>            uml_id = uml_ids.get(f&quot;typedef_{union_name}&quot;)
<span class="line-number">330</span>            if uml_id:
<span class="line-number">331</span>                lines.append(
<span class="line-number">332</span>                    f&#x27;class &quot;{union_name}&quot; as {uml_id} &lt;&lt;typedef&gt;&gt; #LightYellow&#x27;
<span class="line-number">333</span>                )
<span class="line-number">334</span>                lines.append(&quot;{&quot;)
<span class="line-number">335</span>                for field in sorted(union_data.fields, key=lambda x: x.name):
<span class="line-number">336</span>                    self._generate_field_with_nested_structs(lines, field, &quot;    &quot;)
<span class="line-number">337</span>                lines.append(&quot;}&quot;)
<span class="line-number">338</span>                lines.append(&quot;&quot;)
<span class="line-number">339</span>
<span class="line-number">340</span>    def _generate_field_with_nested_structs(self, lines: List[str], field, base_indent: str):
<span class="line-number">341</span>        &quot;&quot;&quot;Generate field with proper handling of nested structures&quot;&quot;&quot;
<span class="line-number">342</span>        field_text = f&quot;{field.type} {field.name}&quot;
<span class="line-number">343</span>
<span class="line-number">344</span>        # Check if this is a nested struct field
<span class="line-number">345</span>        if field.type.startswith(&quot;struct {&quot;) and &#x27;\n&#x27; in field.type:
<span class="line-number">346</span>            # Parse the nested struct content and flatten it
<span class="line-number">347</span><span class="uncovered">            struct_parts = field.type.split(&#x27;\n&#x27;)</span>
<span class="line-number">348</span>
<span class="line-number">349</span>            # For nested structs, flatten them to avoid PlantUML parsing issues
<span class="line-number">350</span>            # Format as: + struct { field_type field_name }
<span class="line-number">351</span><span class="uncovered">            nested_content = []</span>
<span class="line-number">352</span><span class="uncovered">            for part in struct_parts[1:]:</span>
<span class="line-number">353</span><span class="uncovered">                part = part.strip()</span>
<span class="line-number">354</span><span class="uncovered">                if part and part != &quot;}&quot;:</span>
<span class="line-number">355</span><span class="uncovered">                    nested_content.append(part)</span>
<span class="line-number">356</span>
<span class="line-number">357</span><span class="uncovered">            if nested_content:</span>
<span class="line-number">358</span>                # Create a flattened representation
<span class="line-number">359</span><span class="uncovered">                content_str = &quot;; &quot;.join(nested_content)</span>
<span class="line-number">360</span><span class="uncovered">                lines.append(f&quot;{base_indent}+ struct {{ {content_str} }} {field.name}&quot;)</span>
<span class="line-number">361</span>            else:
<span class="line-number">362</span><span class="uncovered">                lines.append(f&quot;{base_indent}+ struct {{ }} {field.name}&quot;)</span>
<span class="line-number">363</span>        else:
<span class="line-number">364</span>            # Handle regular multi-line field types
<span class="line-number">365</span>            field_lines = field_text.split(&#x27;\n&#x27;)
<span class="line-number">366</span>            for i, line in enumerate(field_lines):
<span class="line-number">367</span>                if i == 0:
<span class="line-number">368</span>                    lines.append(f&quot;{base_indent}+ {line}&quot;)
<span class="line-number">369</span>                else:
<span class="line-number">370</span><span class="uncovered">                    lines.append(f&quot;+ {line}&quot;)</span>
<span class="line-number">371</span>
<span class="line-number">372</span>    def _generate_relationships(
<span class="line-number">373</span>        self,
<span class="line-number">374</span>        lines: List[str],
<span class="line-number">375</span>        include_tree: Dict[str, FileModel],
<span class="line-number">376</span>        uml_ids: Dict[str, str],
<span class="line-number">377</span>        project_model: ProjectModel,
<span class="line-number">378</span>    ):
<span class="line-number">379</span>        &quot;&quot;&quot;Generate relationships between elements&quot;&quot;&quot;
<span class="line-number">380</span>        # 1. Include relationships
<span class="line-number">381</span>        lines.append(&quot;&#x27; Include relationships&quot;)
<span class="line-number">382</span>        for file_name, file_model in sorted(include_tree.items()):
<span class="line-number">383</span>            # Use filename for file UML ID lookup
<span class="line-number">384</span>            file_key = Path(file_name).name
<span class="line-number">385</span>            file_uml_id = uml_ids.get(file_key)
<span class="line-number">386</span>            if file_uml_id:
<span class="line-number">387</span>                for include in sorted(file_model.includes):
<span class="line-number">388</span>                    # Clean the include name (remove quotes/angle brackets)
<span class="line-number">389</span>                    clean_include = include.strip(&#x27;&lt;&gt;&quot;&#x27;)
<span class="line-number">390</span>
<span class="line-number">391</span>                    # Find the included file&#x27;s UML ID using filename
<span class="line-number">392</span>                    include_filename = Path(clean_include).name
<span class="line-number">393</span>                    include_uml_id = uml_ids.get(include_filename)
<span class="line-number">394</span>
<span class="line-number">395</span>                    # If found, create the relationship
<span class="line-number">396</span>                    if include_uml_id:
<span class="line-number">397</span>                        lines.append(
<span class="line-number">398</span>                            f&quot;{file_uml_id} --&gt; {include_uml_id} : &lt;&lt;include&gt;&gt;&quot;
<span class="line-number">399</span>                        )
<span class="line-number">400</span>
<span class="line-number">401</span>        lines.append(&quot;&quot;)
<span class="line-number">402</span>
<span class="line-number">403</span>        # 2. Declaration relationships
<span class="line-number">404</span>        lines.append(&quot;&#x27; Declaration relationships&quot;)
<span class="line-number">405</span>        for file_name, file_model in sorted(include_tree.items()):
<span class="line-number">406</span>            # Use filename for file UML ID lookup
<span class="line-number">407</span>            file_key = Path(file_name).name
<span class="line-number">408</span>            file_uml_id = uml_ids.get(file_key)
<span class="line-number">409</span>            if file_uml_id:
<span class="line-number">410</span>                # Find all typedefs declared in this file
<span class="line-number">411</span>                for typedef_name in sorted(file_model.structs.keys()):
<span class="line-number">412</span>                    typedef_uml_id = uml_ids.get(f&quot;typedef_{typedef_name}&quot;)
<span class="line-number">413</span>                    if typedef_uml_id:
<span class="line-number">414</span>                        lines.append(
<span class="line-number">415</span>                            f&quot;{file_uml_id} ..&gt; {typedef_uml_id} : &lt;&lt;declares&gt;&gt;&quot;
<span class="line-number">416</span>                        )
<span class="line-number">417</span>
<span class="line-number">418</span>                for typedef_name in sorted(file_model.enums.keys()):
<span class="line-number">419</span>                    typedef_uml_id = uml_ids.get(f&quot;typedef_{typedef_name}&quot;)
<span class="line-number">420</span>                    if typedef_uml_id:
<span class="line-number">421</span>                        lines.append(
<span class="line-number">422</span>                            f&quot;{file_uml_id} ..&gt; {typedef_uml_id} : &lt;&lt;declares&gt;&gt;&quot;
<span class="line-number">423</span>                        )
<span class="line-number">424</span>
<span class="line-number">425</span>                for typedef_name in sorted(file_model.aliases.keys()):
<span class="line-number">426</span>                    typedef_uml_id = uml_ids.get(f&quot;typedef_{typedef_name}&quot;)
<span class="line-number">427</span>                    if typedef_uml_id:
<span class="line-number">428</span>                        lines.append(
<span class="line-number">429</span>                            f&quot;{file_uml_id} ..&gt; {typedef_uml_id} : &lt;&lt;declares&gt;&gt;&quot;
<span class="line-number">430</span>                        )
<span class="line-number">431</span>
<span class="line-number">432</span>                for typedef_name in sorted(file_model.unions.keys()):
<span class="line-number">433</span>                    typedef_uml_id = uml_ids.get(f&quot;typedef_{typedef_name}&quot;)
<span class="line-number">434</span>                    if typedef_uml_id:
<span class="line-number">435</span>                        lines.append(
<span class="line-number">436</span>                            f&quot;{file_uml_id} ..&gt; {typedef_uml_id} : &lt;&lt;declares&gt;&gt;&quot;
<span class="line-number">437</span>                        )
<span class="line-number">438</span>
<span class="line-number">439</span>        lines.append(&quot;&quot;)
<span class="line-number">440</span>
<span class="line-number">441</span>        # 3. Uses relationships
<span class="line-number">442</span>        lines.append(&quot;&#x27; Uses relationships&quot;)
<span class="line-number">443</span>        for file_name, file_model in sorted(include_tree.items()):
<span class="line-number">444</span>            # Note: file_uml_id not needed for uses relationships, only typedef UML IDs are used
<span class="line-number">445</span>            # Struct uses relationships
<span class="line-number">446</span>            for struct_name, struct_data in sorted(file_model.structs.items()):
<span class="line-number">447</span>                struct_uml_id = uml_ids.get(f&quot;typedef_{struct_name}&quot;)
<span class="line-number">448</span>                if struct_uml_id and hasattr(struct_data, &quot;uses&quot;):
<span class="line-number">449</span>                    for used_type in sorted(struct_data.uses):
<span class="line-number">450</span>                        used_uml_id = uml_ids.get(f&quot;typedef_{used_type}&quot;)
<span class="line-number">451</span>                        if used_uml_id:
<span class="line-number">452</span>                            lines.append(
<span class="line-number">453</span>                                f&quot;{struct_uml_id} ..&gt; {used_uml_id} : &lt;&lt;uses&gt;&gt;&quot;
<span class="line-number">454</span>                            )
<span class="line-number">455</span>
<span class="line-number">456</span>            # Alias uses relationships
<span class="line-number">457</span>            for alias_name, alias_data in sorted(file_model.aliases.items()):
<span class="line-number">458</span>                alias_uml_id = uml_ids.get(f&quot;typedef_{alias_name}&quot;)
<span class="line-number">459</span>                if alias_uml_id and hasattr(alias_data, &quot;uses&quot;):
<span class="line-number">460</span>                    for used_type in sorted(alias_data.uses):
<span class="line-number">461</span>                        used_uml_id = uml_ids.get(f&quot;typedef_{used_type}&quot;)
<span class="line-number">462</span>                        if used_uml_id:
<span class="line-number">463</span>                            lines.append(f&quot;{alias_uml_id} ..&gt; {used_uml_id} : &lt;&lt;uses&gt;&gt;&quot;)
<span class="line-number">464</span>
<span class="line-number">465</span>
<span class="line-number">466</span>class Generator:
</pre>
<h4>Function: find_file_key (lines 70-107)</h4>
<pre>
<span class="line-number"> 70</span>        def find_file_key(file_name: str) -&gt; str:
<span class="line-number"> 71</span>            &quot;&quot;&quot;Find the correct key for a file in project_model.files using path matching&quot;&quot;&quot;
<span class="line-number"> 72</span>            # First try exact match
<span class="line-number"> 73</span>            if file_name in project_model.files:
<span class="line-number"> 74</span>                return file_name
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>            # Try matching by filename
<span class="line-number"> 77</span>            filename = Path(file_name).name
<span class="line-number"> 78</span>            if filename in project_model.files:
<span class="line-number"> 79</span><span class="uncovered">                return filename</span>
<span class="line-number"> 80</span>
<span class="line-number"> 81</span>            # Try matching by relative path
<span class="line-number"> 82</span>            for key in project_model.files.keys():
<span class="line-number"> 83</span>                if Path(key).name == filename:
<span class="line-number"> 84</span>                    return key
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>            # If not found, return the filename (will be handled gracefully)
<span class="line-number"> 87</span>            return filename
<span class="line-number"> 88</span>
<span class="line-number"> 89</span>        def add_file_to_tree(file_name: str, depth: int):
<span class="line-number"> 90</span>            if depth &gt; include_depth or file_name in visited:
<span class="line-number"> 91</span><span class="uncovered">                return</span>
<span class="line-number"> 92</span>
<span class="line-number"> 93</span>            visited.add(file_name)
<span class="line-number"> 94</span>            file_key = find_file_key(file_name)
<span class="line-number"> 95</span>
<span class="line-number"> 96</span>            if file_key in project_model.files:
<span class="line-number"> 97</span>                include_tree[file_key] = project_model.files[file_key]
<span class="line-number"> 98</span>
<span class="line-number"> 99</span>                # Add included files
<span class="line-number">100</span>                if depth &lt; include_depth:
<span class="line-number">101</span>                    for include in project_model.files[file_key].includes:
<span class="line-number">102</span>                        # Clean the include name (remove quotes/angle brackets)
<span class="line-number">103</span>                        clean_include = include.strip(&#x27;&lt;&gt;&quot;&#x27;)
<span class="line-number">104</span>                        add_file_to_tree(clean_include, depth + 1)
<span class="line-number">105</span>
<span class="line-number">106</span>        # Start with the root file - find the correct key
<span class="line-number">107</span>        root_key = find_file_key(root_file.relative_path)
</pre>
<h4>Function: add_file_to_tree (lines 89-106)</h4>
<pre>
<span class="line-number"> 89</span>        def add_file_to_tree(file_name: str, depth: int):
<span class="line-number"> 90</span>            if depth &gt; include_depth or file_name in visited:
<span class="line-number"> 91</span><span class="uncovered">                return</span>
<span class="line-number"> 92</span>
<span class="line-number"> 93</span>            visited.add(file_name)
<span class="line-number"> 94</span>            file_key = find_file_key(file_name)
<span class="line-number"> 95</span>
<span class="line-number"> 96</span>            if file_key in project_model.files:
<span class="line-number"> 97</span>                include_tree[file_key] = project_model.files[file_key]
<span class="line-number"> 98</span>
<span class="line-number"> 99</span>                # Add included files
<span class="line-number">100</span>                if depth &lt; include_depth:
<span class="line-number">101</span>                    for include in project_model.files[file_key].includes:
<span class="line-number">102</span>                        # Clean the include name (remove quotes/angle brackets)
<span class="line-number">103</span>                        clean_include = include.strip(&#x27;&lt;&gt;&quot;&#x27;)
<span class="line-number">104</span>                        add_file_to_tree(clean_include, depth + 1)
<span class="line-number">105</span>
<span class="line-number">106</span>        # Start with the root file - find the correct key
</pre>
<h4>Function: _generate_field_with_nested_structs (lines 340-465)</h4>
<pre>
<span class="line-number">340</span>    def _generate_field_with_nested_structs(self, lines: List[str], field, base_indent: str):
<span class="line-number">341</span>        &quot;&quot;&quot;Generate field with proper handling of nested structures&quot;&quot;&quot;
<span class="line-number">342</span>        field_text = f&quot;{field.type} {field.name}&quot;
<span class="line-number">343</span>
<span class="line-number">344</span>        # Check if this is a nested struct field
<span class="line-number">345</span>        if field.type.startswith(&quot;struct {&quot;) and &#x27;\n&#x27; in field.type:
<span class="line-number">346</span>            # Parse the nested struct content and flatten it
<span class="line-number">347</span><span class="uncovered">            struct_parts = field.type.split(&#x27;\n&#x27;)</span>
<span class="line-number">348</span>
<span class="line-number">349</span>            # For nested structs, flatten them to avoid PlantUML parsing issues
<span class="line-number">350</span>            # Format as: + struct { field_type field_name }
<span class="line-number">351</span><span class="uncovered">            nested_content = []</span>
<span class="line-number">352</span><span class="uncovered">            for part in struct_parts[1:]:</span>
<span class="line-number">353</span><span class="uncovered">                part = part.strip()</span>
<span class="line-number">354</span><span class="uncovered">                if part and part != &quot;}&quot;:</span>
<span class="line-number">355</span><span class="uncovered">                    nested_content.append(part)</span>
<span class="line-number">356</span>
<span class="line-number">357</span><span class="uncovered">            if nested_content:</span>
<span class="line-number">358</span>                # Create a flattened representation
<span class="line-number">359</span><span class="uncovered">                content_str = &quot;; &quot;.join(nested_content)</span>
<span class="line-number">360</span><span class="uncovered">                lines.append(f&quot;{base_indent}+ struct {{ {content_str} }} {field.name}&quot;)</span>
<span class="line-number">361</span>            else:
<span class="line-number">362</span><span class="uncovered">                lines.append(f&quot;{base_indent}+ struct {{ }} {field.name}&quot;)</span>
<span class="line-number">363</span>        else:
<span class="line-number">364</span>            # Handle regular multi-line field types
<span class="line-number">365</span>            field_lines = field_text.split(&#x27;\n&#x27;)
<span class="line-number">366</span>            for i, line in enumerate(field_lines):
<span class="line-number">367</span>                if i == 0:
<span class="line-number">368</span>                    lines.append(f&quot;{base_indent}+ {line}&quot;)
<span class="line-number">369</span>                else:
<span class="line-number">370</span><span class="uncovered">                    lines.append(f&quot;+ {line}&quot;)</span>
<span class="line-number">371</span>
<span class="line-number">372</span>    def _generate_relationships(
<span class="line-number">373</span>        self,
<span class="line-number">374</span>        lines: List[str],
<span class="line-number">375</span>        include_tree: Dict[str, FileModel],
<span class="line-number">376</span>        uml_ids: Dict[str, str],
<span class="line-number">377</span>        project_model: ProjectModel,
<span class="line-number">378</span>    ):
<span class="line-number">379</span>        &quot;&quot;&quot;Generate relationships between elements&quot;&quot;&quot;
<span class="line-number">380</span>        # 1. Include relationships
<span class="line-number">381</span>        lines.append(&quot;&#x27; Include relationships&quot;)
<span class="line-number">382</span>        for file_name, file_model in sorted(include_tree.items()):
<span class="line-number">383</span>            # Use filename for file UML ID lookup
<span class="line-number">384</span>            file_key = Path(file_name).name
<span class="line-number">385</span>            file_uml_id = uml_ids.get(file_key)
<span class="line-number">386</span>            if file_uml_id:
<span class="line-number">387</span>                for include in sorted(file_model.includes):
<span class="line-number">388</span>                    # Clean the include name (remove quotes/angle brackets)
<span class="line-number">389</span>                    clean_include = include.strip(&#x27;&lt;&gt;&quot;&#x27;)
<span class="line-number">390</span>
<span class="line-number">391</span>                    # Find the included file&#x27;s UML ID using filename
<span class="line-number">392</span>                    include_filename = Path(clean_include).name
<span class="line-number">393</span>                    include_uml_id = uml_ids.get(include_filename)
<span class="line-number">394</span>
<span class="line-number">395</span>                    # If found, create the relationship
<span class="line-number">396</span>                    if include_uml_id:
<span class="line-number">397</span>                        lines.append(
<span class="line-number">398</span>                            f&quot;{file_uml_id} --&gt; {include_uml_id} : &lt;&lt;include&gt;&gt;&quot;
<span class="line-number">399</span>                        )
<span class="line-number">400</span>
<span class="line-number">401</span>        lines.append(&quot;&quot;)
<span class="line-number">402</span>
<span class="line-number">403</span>        # 2. Declaration relationships
<span class="line-number">404</span>        lines.append(&quot;&#x27; Declaration relationships&quot;)
<span class="line-number">405</span>        for file_name, file_model in sorted(include_tree.items()):
<span class="line-number">406</span>            # Use filename for file UML ID lookup
<span class="line-number">407</span>            file_key = Path(file_name).name
<span class="line-number">408</span>            file_uml_id = uml_ids.get(file_key)
<span class="line-number">409</span>            if file_uml_id:
<span class="line-number">410</span>                # Find all typedefs declared in this file
<span class="line-number">411</span>                for typedef_name in sorted(file_model.structs.keys()):
<span class="line-number">412</span>                    typedef_uml_id = uml_ids.get(f&quot;typedef_{typedef_name}&quot;)
<span class="line-number">413</span>                    if typedef_uml_id:
<span class="line-number">414</span>                        lines.append(
<span class="line-number">415</span>                            f&quot;{file_uml_id} ..&gt; {typedef_uml_id} : &lt;&lt;declares&gt;&gt;&quot;
<span class="line-number">416</span>                        )
<span class="line-number">417</span>
<span class="line-number">418</span>                for typedef_name in sorted(file_model.enums.keys()):
<span class="line-number">419</span>                    typedef_uml_id = uml_ids.get(f&quot;typedef_{typedef_name}&quot;)
<span class="line-number">420</span>                    if typedef_uml_id:
<span class="line-number">421</span>                        lines.append(
<span class="line-number">422</span>                            f&quot;{file_uml_id} ..&gt; {typedef_uml_id} : &lt;&lt;declares&gt;&gt;&quot;
<span class="line-number">423</span>                        )
<span class="line-number">424</span>
<span class="line-number">425</span>                for typedef_name in sorted(file_model.aliases.keys()):
<span class="line-number">426</span>                    typedef_uml_id = uml_ids.get(f&quot;typedef_{typedef_name}&quot;)
<span class="line-number">427</span>                    if typedef_uml_id:
<span class="line-number">428</span>                        lines.append(
<span class="line-number">429</span>                            f&quot;{file_uml_id} ..&gt; {typedef_uml_id} : &lt;&lt;declares&gt;&gt;&quot;
<span class="line-number">430</span>                        )
<span class="line-number">431</span>
<span class="line-number">432</span>                for typedef_name in sorted(file_model.unions.keys()):
<span class="line-number">433</span>                    typedef_uml_id = uml_ids.get(f&quot;typedef_{typedef_name}&quot;)
<span class="line-number">434</span>                    if typedef_uml_id:
<span class="line-number">435</span>                        lines.append(
<span class="line-number">436</span>                            f&quot;{file_uml_id} ..&gt; {typedef_uml_id} : &lt;&lt;declares&gt;&gt;&quot;
<span class="line-number">437</span>                        )
<span class="line-number">438</span>
<span class="line-number">439</span>        lines.append(&quot;&quot;)
<span class="line-number">440</span>
<span class="line-number">441</span>        # 3. Uses relationships
<span class="line-number">442</span>        lines.append(&quot;&#x27; Uses relationships&quot;)
<span class="line-number">443</span>        for file_name, file_model in sorted(include_tree.items()):
<span class="line-number">444</span>            # Note: file_uml_id not needed for uses relationships, only typedef UML IDs are used
<span class="line-number">445</span>            # Struct uses relationships
<span class="line-number">446</span>            for struct_name, struct_data in sorted(file_model.structs.items()):
<span class="line-number">447</span>                struct_uml_id = uml_ids.get(f&quot;typedef_{struct_name}&quot;)
<span class="line-number">448</span>                if struct_uml_id and hasattr(struct_data, &quot;uses&quot;):
<span class="line-number">449</span>                    for used_type in sorted(struct_data.uses):
<span class="line-number">450</span>                        used_uml_id = uml_ids.get(f&quot;typedef_{used_type}&quot;)
<span class="line-number">451</span>                        if used_uml_id:
<span class="line-number">452</span>                            lines.append(
<span class="line-number">453</span>                                f&quot;{struct_uml_id} ..&gt; {used_uml_id} : &lt;&lt;uses&gt;&gt;&quot;
<span class="line-number">454</span>                            )
<span class="line-number">455</span>
<span class="line-number">456</span>            # Alias uses relationships
<span class="line-number">457</span>            for alias_name, alias_data in sorted(file_model.aliases.items()):
<span class="line-number">458</span>                alias_uml_id = uml_ids.get(f&quot;typedef_{alias_name}&quot;)
<span class="line-number">459</span>                if alias_uml_id and hasattr(alias_data, &quot;uses&quot;):
<span class="line-number">460</span>                    for used_type in sorted(alias_data.uses):
<span class="line-number">461</span>                        used_uml_id = uml_ids.get(f&quot;typedef_{used_type}&quot;)
<span class="line-number">462</span>                        if used_uml_id:
<span class="line-number">463</span>                            lines.append(f&quot;{alias_uml_id} ..&gt; {used_uml_id} : &lt;&lt;uses&gt;&gt;&quot;)
<span class="line-number">464</span>
<span class="line-number">465</span>
</pre>
</div>
<div class="file-section">
<div class="file-header">
/home/runner/work/generator_project/generator_project/c_to_plantuml/parser.py - 87.39% coverage (617/706 lines)
</div>
<h4>Function: __init__ (lines 28-1493)</h4>
<pre>
<span class="line-number"> 28</span>    def __init__(self):
<span class="line-number"> 29</span>        self.logger = logging.getLogger(__name__)
<span class="line-number"> 30</span>        self.tokenizer = CTokenizer()
<span class="line-number"> 31</span>        self.preprocessor = PreprocessorManager()
<span class="line-number"> 32</span>        # Cache for failed include searches to avoid repeated lookups
<span class="line-number"> 33</span>        self._failed_includes_cache = set()
<span class="line-number"> 34</span>
<span class="line-number"> 35</span>    def parse_project(
<span class="line-number"> 36</span>        self, project_root: str, recursive_search: bool = True, config: &quot;Config&quot; = None
<span class="line-number"> 37</span>    ) -&gt; ProjectModel:
<span class="line-number"> 38</span>        &quot;&quot;&quot;Parse a C/C++ project and return a model&quot;&quot;&quot;
<span class="line-number"> 39</span>        project_root = Path(project_root).resolve()
<span class="line-number"> 40</span>
<span class="line-number"> 41</span>        if not project_root.exists():
<span class="line-number"> 42</span>            raise ValueError(f&quot;Project root not found: {project_root}&quot;)
<span class="line-number"> 43</span>
<span class="line-number"> 44</span>        if not project_root.is_dir():
<span class="line-number"> 45</span><span class="uncovered">            raise ValueError(f&quot;Project root must be a directory: {project_root}&quot;)</span>
<span class="line-number"> 46</span>
<span class="line-number"> 47</span>        # Clear the failed includes cache for this new project
<span class="line-number"> 48</span>        cache_size_before = len(self._failed_includes_cache)
<span class="line-number"> 49</span>        self._failed_includes_cache.clear()
<span class="line-number"> 50</span>        if cache_size_before &gt; 0:
<span class="line-number"> 51</span><span class="uncovered">            self.logger.debug(</span>
<span class="line-number"> 52</span>                &quot;Cleared failed includes cache (%d entries)&quot;, cache_size_before
<span class="line-number"> 53</span>            )
<span class="line-number"> 54</span>
<span class="line-number"> 55</span>        self.logger.info(&quot;Parsing project: %s&quot;, project_root)
<span class="line-number"> 56</span>
<span class="line-number"> 57</span>        # Find C/C++ files based on configuration and include dependencies
<span class="line-number"> 58</span>        if config:
<span class="line-number"> 59</span>            c_files = self._find_files_with_include_dependencies(
<span class="line-number"> 60</span>                project_root, recursive_search, config
<span class="line-number"> 61</span>            )
<span class="line-number"> 62</span>        else:
<span class="line-number"> 63</span>            c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number"> 64</span>
<span class="line-number"> 65</span>        self.logger.info(&quot;Found %d C/C++ files&quot;, len(c_files))
<span class="line-number"> 66</span>
<span class="line-number"> 67</span>        # Parse each file using filename as key for simplified tracking
<span class="line-number"> 68</span>        files = {}
<span class="line-number"> 69</span>        failed_files = []
<span class="line-number"> 70</span>
<span class="line-number"> 71</span>        for file_path in c_files:
<span class="line-number"> 72</span>            try:
<span class="line-number"> 73</span>                # Use relative path as key for better tracking of subdirectories
<span class="line-number"> 74</span>                relative_path = str(file_path.relative_to(project_root))
<span class="line-number"> 75</span>                file_model = self.parse_file(
<span class="line-number"> 76</span>                    file_path, relative_path, str(project_root)
<span class="line-number"> 77</span>                )
<span class="line-number"> 78</span>                files[relative_path] = file_model
<span class="line-number"> 79</span>
<span class="line-number"> 80</span>                self.logger.debug(&quot;Successfully parsed: %s&quot;, relative_path)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span><span class="uncovered">            except (OSError, ValueError) as e:</span>
<span class="line-number"> 83</span><span class="uncovered">                self.logger.warning(&quot;Failed to parse %s: %s&quot;, file_path, e)</span>
<span class="line-number"> 84</span><span class="uncovered">                failed_files.append(str(file_path))</span>
<span class="line-number"> 85</span>
<span class="line-number"> 86</span>        if failed_files:
<span class="line-number"> 87</span><span class="uncovered">            error_msg = (</span>
<span class="line-number"> 88</span>                f&quot;Failed to parse {len(failed_files)} files: {failed_files}. &quot;
<span class="line-number"> 89</span>                &quot;Stopping model processing.&quot;
<span class="line-number"> 90</span>            )
<span class="line-number"> 91</span><span class="uncovered">            self.logger.error(error_msg)</span>
<span class="line-number"> 92</span><span class="uncovered">            raise RuntimeError(error_msg)</span>
<span class="line-number"> 93</span>
<span class="line-number"> 94</span>        model = ProjectModel(
<span class="line-number"> 95</span>            project_name=project_root.name,
<span class="line-number"> 96</span>            project_root=str(project_root),
<span class="line-number"> 97</span>            files=files,
<span class="line-number"> 98</span>        )
<span class="line-number"> 99</span>
<span class="line-number">100</span>        # Update all uses fields across the entire project
<span class="line-number">101</span>        model.update_uses_fields()
<span class="line-number">102</span>
<span class="line-number">103</span>        # Log cache statistics
<span class="line-number">104</span>        if self._failed_includes_cache:
<span class="line-number">105</span>            self.logger.info(
<span class="line-number">106</span>                &quot;Failed includes cache contains %d entries&quot;,
<span class="line-number">107</span>                len(self._failed_includes_cache),
<span class="line-number">108</span>            )
<span class="line-number">109</span>            self.logger.debug(
<span class="line-number">110</span>                &quot;Failed includes: %s%s&quot;,
<span class="line-number">111</span>                list(self._failed_includes_cache)[:10],
<span class="line-number">112</span>                &quot;...&quot; if len(self._failed_includes_cache) &gt; 10 else &quot;&quot;,
<span class="line-number">113</span>            )
<span class="line-number">114</span>
<span class="line-number">115</span>        self.logger.info(&quot;Parsing complete. Parsed %d files successfully.&quot;, len(files))
<span class="line-number">116</span>        return model
<span class="line-number">117</span>
<span class="line-number">118</span>    def parse_file(
<span class="line-number">119</span>        self, file_path: Path, relative_path: str, project_root: str
<span class="line-number">120</span>    ) -&gt; FileModel:
<span class="line-number">121</span>        &quot;&quot;&quot;Parse a single C/C++ file and return a file model using tokenization&quot;&quot;&quot;
<span class="line-number">122</span>        self.logger.debug(&quot;Parsing file: %s&quot;, file_path)
<span class="line-number">123</span>
<span class="line-number">124</span>        # Detect encoding
<span class="line-number">125</span>        encoding = self._detect_encoding(file_path)
<span class="line-number">126</span>
<span class="line-number">127</span>        # Read file content
<span class="line-number">128</span>        with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">129</span>            content = f.read()
<span class="line-number">130</span>
<span class="line-number">131</span>        # Tokenize the content
<span class="line-number">132</span>        tokens = self.tokenizer.tokenize(content)
<span class="line-number">133</span>        self.logger.debug(&quot;Tokenized file into %d tokens&quot;, len(tokens))
<span class="line-number">134</span>
<span class="line-number">135</span>        # Process preprocessor directives
<span class="line-number">136</span>        self.preprocessor.add_defines_from_content(tokens)
<span class="line-number">137</span>        processed_tokens = self.preprocessor.process_file(tokens)
<span class="line-number">138</span>        self.logger.debug(
<span class="line-number">139</span>            &quot;Preprocessor processed %d tokens -&gt; %d tokens&quot;,
<span class="line-number">140</span>            len(tokens),
<span class="line-number">141</span>            len(processed_tokens),
<span class="line-number">142</span>        )
<span class="line-number">143</span>
<span class="line-number">144</span>        # Filter out whitespace and comments for structure finding
<span class="line-number">145</span>        filtered_tokens = self.tokenizer.filter_tokens(processed_tokens)
<span class="line-number">146</span>        structure_finder = StructureFinder(filtered_tokens)
<span class="line-number">147</span>
<span class="line-number">148</span>        # Parse different structures using tokenizer
<span class="line-number">149</span>        structs = self._parse_structs_with_tokenizer(processed_tokens, structure_finder)
<span class="line-number">150</span>        enums = self._parse_enums_with_tokenizer(processed_tokens, structure_finder)
<span class="line-number">151</span>        unions = self._parse_unions_with_tokenizer(processed_tokens, structure_finder)
<span class="line-number">152</span>        functions = self._parse_functions_with_tokenizer(
<span class="line-number">153</span>            processed_tokens, structure_finder
<span class="line-number">154</span>        )
<span class="line-number">155</span>        aliases = self._parse_aliases_with_tokenizer(processed_tokens)
<span class="line-number">156</span>
<span class="line-number">157</span>        # Note: We&#x27;ll update &quot;uses&quot; fields later when we have the full project model
<span class="line-number">158</span>        # For now, just create the structures with empty uses
<span class="line-number">159</span>
<span class="line-number">160</span>        # Map typedef names to anonymous structs/enums/unions if needed
<span class="line-number">161</span>        # This logic will be handled by typedef_relations instead
<span class="line-number">162</span>
<span class="line-number">163</span>        return FileModel(
<span class="line-number">164</span>            file_path=str(file_path),
<span class="line-number">165</span>            relative_path=relative_path,  # Use relative path for better tracking
<span class="line-number">166</span>            project_root=project_root,
<span class="line-number">167</span>            encoding_used=encoding,
<span class="line-number">168</span>            structs=structs,
<span class="line-number">169</span>            enums=enums,
<span class="line-number">170</span>            unions=unions,
<span class="line-number">171</span>            functions=functions,
<span class="line-number">172</span>            globals=self._parse_globals_with_tokenizer(processed_tokens),
<span class="line-number">173</span>            includes=self._parse_includes_with_tokenizer(processed_tokens),
<span class="line-number">174</span>            macros=self._parse_macros_with_tokenizer(processed_tokens),
<span class="line-number">175</span>            aliases=aliases,
<span class="line-number">176</span>            # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">177</span>        )
<span class="line-number">178</span>
<span class="line-number">179</span>    def _parse_structs_with_tokenizer(
<span class="line-number">180</span>        self, tokens, structure_finder
<span class="line-number">181</span>    ) -&gt; Dict[str, &quot;Struct&quot;]:
<span class="line-number">182</span>        &quot;&quot;&quot;Parse struct definitions using tokenizer&quot;&quot;&quot;
<span class="line-number">183</span>
<span class="line-number">184</span>        structs = {}
<span class="line-number">185</span>        struct_infos = structure_finder.find_structs()
<span class="line-number">186</span>
<span class="line-number">187</span>        for start_pos, end_pos, struct_name in struct_infos:
<span class="line-number">188</span>            # Need to map back to original token positions
<span class="line-number">189</span>            # Find the original token positions by looking at line/column info
<span class="line-number">190</span>            original_start = self._find_original_token_pos(
<span class="line-number">191</span>                tokens, structure_finder.tokens, start_pos
<span class="line-number">192</span>            )
<span class="line-number">193</span>            original_end = self._find_original_token_pos(
<span class="line-number">194</span>                tokens, structure_finder.tokens, end_pos
<span class="line-number">195</span>            )
<span class="line-number">196</span>
<span class="line-number">197</span>            if original_start is not None and original_end is not None:
<span class="line-number">198</span>                # Extract field information from original token range
<span class="line-number">199</span>                field_tuples = find_struct_fields(tokens, original_start, original_end)
<span class="line-number">200</span>
<span class="line-number">201</span>                # Convert to Field objects
<span class="line-number">202</span>                fields = []
<span class="line-number">203</span>                for field_name, field_type in field_tuples:
<span class="line-number">204</span>                    try:
<span class="line-number">205</span>                        fields.append(Field(field_name, field_type))
<span class="line-number">206</span><span class="uncovered">                    except ValueError as e:</span>
<span class="line-number">207</span><span class="uncovered">                        self.logger.warning(</span>
<span class="line-number">208</span>                            &quot;Error creating field %s: %s&quot;, field_name, e
<span class="line-number">209</span>                        )
<span class="line-number">210</span>
<span class="line-number">211</span>                # For anonymous structs, use a special key that can be mapped later
<span class="line-number">212</span>                if not struct_name:
<span class="line-number">213</span>                    struct_name = &quot;__anonymous_struct__&quot;
<span class="line-number">214</span>
<span class="line-number">215</span>                # Extract tag name if this is a typedef struct
<span class="line-number">216</span>                tag_name = &quot;&quot;
<span class="line-number">217</span>                if struct_name and not struct_name.startswith(&quot;__anonymous&quot;):
<span class="line-number">218</span>                    # Check if this struct has a typedef
<span class="line-number">219</span>                    tag_name = self._extract_tag_name_for_struct(tokens, struct_name)
<span class="line-number">220</span>
<span class="line-number">221</span>                structs[struct_name] = Struct(
<span class="line-number">222</span>                    struct_name, fields, tag_name=tag_name, uses=[]
<span class="line-number">223</span>                )
<span class="line-number">224</span>                self.logger.debug(
<span class="line-number">225</span>                    &quot;Parsed struct: %s with %d fields&quot;, struct_name, len(fields)
<span class="line-number">226</span>                )
<span class="line-number">227</span>
<span class="line-number">228</span>        return structs
<span class="line-number">229</span>
<span class="line-number">230</span>    def _parse_enums_with_tokenizer(
<span class="line-number">231</span>        self, tokens, structure_finder
<span class="line-number">232</span>    ) -&gt; Dict[str, &quot;Enum&quot;]:
<span class="line-number">233</span>        &quot;&quot;&quot;Parse enum definitions using tokenizer&quot;&quot;&quot;
<span class="line-number">234</span>        enums = {}
<span class="line-number">235</span>        enum_infos = structure_finder.find_enums()
<span class="line-number">236</span>
<span class="line-number">237</span>        for start_pos, end_pos, enum_name in enum_infos:
<span class="line-number">238</span>            # Need to map back to original token positions
<span class="line-number">239</span>            original_start = self._find_original_token_pos(
<span class="line-number">240</span>                tokens, structure_finder.tokens, start_pos
<span class="line-number">241</span>            )
<span class="line-number">242</span>            original_end = self._find_original_token_pos(
<span class="line-number">243</span>                tokens, structure_finder.tokens, end_pos
<span class="line-number">244</span>            )
<span class="line-number">245</span>
<span class="line-number">246</span>            if original_start is not None and original_end is not None:
<span class="line-number">247</span>                # Extract enum values from original token range
<span class="line-number">248</span>                value_strs = find_enum_values(tokens, original_start, original_end)
<span class="line-number">249</span>                values = []
<span class="line-number">250</span>                for v in value_strs:
<span class="line-number">251</span>                    if &quot;=&quot; in v:
<span class="line-number">252</span>                        name, val = v.split(&quot;=&quot;, 1)
<span class="line-number">253</span>                        name = name.strip()
<span class="line-number">254</span>                        val = val.strip()
<span class="line-number">255</span>                        if name:  # Only add if name is not empty
<span class="line-number">256</span>                            values.append(EnumValue(name=name, value=val))
<span class="line-number">257</span>                    else:
<span class="line-number">258</span>                        name = v.strip()
<span class="line-number">259</span>                        if name:  # Only add if name is not empty
<span class="line-number">260</span>                            values.append(EnumValue(name=name))
<span class="line-number">261</span>
<span class="line-number">262</span>                # For anonymous enums, use a special key that can be mapped later
<span class="line-number">263</span>                if not enum_name:
<span class="line-number">264</span>                    enum_name = &quot;__anonymous_enum__&quot;
<span class="line-number">265</span>
<span class="line-number">266</span>                # Extract tag name if this is a typedef enum
<span class="line-number">267</span>                tag_name = &quot;&quot;
<span class="line-number">268</span>                if enum_name and not enum_name.startswith(&quot;__anonymous&quot;):
<span class="line-number">269</span>                    # Check if this enum has a typedef
<span class="line-number">270</span>                    tag_name = self._extract_tag_name_for_enum(tokens, enum_name)
<span class="line-number">271</span>
<span class="line-number">272</span>                enums[enum_name] = Enum(enum_name, values, tag_name=tag_name)
<span class="line-number">273</span>                self.logger.debug(
<span class="line-number">274</span>                    &quot;Parsed enum: %s with %d values&quot;, enum_name, len(values)
<span class="line-number">275</span>                )
<span class="line-number">276</span>
<span class="line-number">277</span>        return enums
<span class="line-number">278</span>
<span class="line-number">279</span>    def _parse_unions_with_tokenizer(
<span class="line-number">280</span>        self, tokens, structure_finder
<span class="line-number">281</span>    ) -&gt; Dict[str, &quot;Union&quot;]:
<span class="line-number">282</span>        &quot;&quot;&quot;Parse union definitions using tokenizer&quot;&quot;&quot;
<span class="line-number">283</span>        from .models import Field, Union
<span class="line-number">284</span>
<span class="line-number">285</span>        unions = {}
<span class="line-number">286</span>        union_infos = structure_finder.find_unions()
<span class="line-number">287</span>
<span class="line-number">288</span>        for start_pos, end_pos, union_name in union_infos:
<span class="line-number">289</span>            # Need to map back to original token positions
<span class="line-number">290</span>            original_start = self._find_original_token_pos(
<span class="line-number">291</span>                tokens, structure_finder.tokens, start_pos
<span class="line-number">292</span>            )
<span class="line-number">293</span>            original_end = self._find_original_token_pos(
<span class="line-number">294</span>                tokens, structure_finder.tokens, end_pos
<span class="line-number">295</span>            )
<span class="line-number">296</span>
<span class="line-number">297</span>            if original_start is not None and original_end is not None:
<span class="line-number">298</span>                # Extract field information from original token range
<span class="line-number">299</span>                field_tuples = find_struct_fields(tokens, original_start, original_end)
<span class="line-number">300</span>
<span class="line-number">301</span>                # Convert to Field objects
<span class="line-number">302</span>                fields = []
<span class="line-number">303</span>                for field_name, field_type in field_tuples:
<span class="line-number">304</span>                    try:
<span class="line-number">305</span>                        fields.append(Field(field_name, field_type))
<span class="line-number">306</span><span class="uncovered">                    except ValueError as e:</span>
<span class="line-number">307</span><span class="uncovered">                        self.logger.warning(</span>
<span class="line-number">308</span>                            &quot;Error creating union field %s: %s&quot;, field_name, e
<span class="line-number">309</span>                        )
<span class="line-number">310</span>
<span class="line-number">311</span>                # For anonymous unions, use a special key that can be mapped later
<span class="line-number">312</span>                if not union_name:
<span class="line-number">313</span><span class="uncovered">                    union_name = &quot;__anonymous_union__&quot;</span>
<span class="line-number">314</span>
<span class="line-number">315</span>                # Extract tag name if this is a typedef union
<span class="line-number">316</span>                tag_name = &quot;&quot;
<span class="line-number">317</span>                if union_name and not union_name.startswith(&quot;__anonymous&quot;):
<span class="line-number">318</span>                    # Check if this union has a typedef
<span class="line-number">319</span>                    tag_name = self._extract_tag_name_for_union(tokens, union_name)
<span class="line-number">320</span>
<span class="line-number">321</span>                unions[union_name] = Union(
<span class="line-number">322</span>                    union_name, fields, tag_name=tag_name, uses=[]
<span class="line-number">323</span>                )
<span class="line-number">324</span>                self.logger.debug(
<span class="line-number">325</span>                    &quot;Parsed union: %s with %d fields&quot;, union_name, len(fields)
<span class="line-number">326</span>                )
<span class="line-number">327</span>
<span class="line-number">328</span>        return unions
<span class="line-number">329</span>
<span class="line-number">330</span>    def _parse_functions_with_tokenizer(
<span class="line-number">331</span>        self, tokens, structure_finder
<span class="line-number">332</span>    ) -&gt; List[&quot;Function&quot;]:
<span class="line-number">333</span>        &quot;&quot;&quot;Parse function declarations/definitions using tokenizer&quot;&quot;&quot;
<span class="line-number">334</span>        from .models import Function
<span class="line-number">335</span>
<span class="line-number">336</span>        functions = []
<span class="line-number">337</span>        function_infos = structure_finder.find_functions()
<span class="line-number">338</span>
<span class="line-number">339</span>        for (
<span class="line-number">340</span>            start_pos,
<span class="line-number">341</span>            end_pos,
<span class="line-number">342</span>            func_name,
<span class="line-number">343</span>            return_type,
<span class="line-number">344</span>            is_declaration,
<span class="line-number">345</span>        ) in function_infos:
<span class="line-number">346</span>            # Map back to original token positions to parse parameters
<span class="line-number">347</span>            original_start = self._find_original_token_pos(
<span class="line-number">348</span>                tokens, structure_finder.tokens, start_pos
<span class="line-number">349</span>            )
<span class="line-number">350</span>            original_end = self._find_original_token_pos(
<span class="line-number">351</span>                tokens, structure_finder.tokens, end_pos
<span class="line-number">352</span>            )
<span class="line-number">353</span>
<span class="line-number">354</span>            parameters = []
<span class="line-number">355</span>            if original_start is not None and original_end is not None:
<span class="line-number">356</span>                # Parse parameters from the token range
<span class="line-number">357</span>                parameters = self._parse_function_parameters(
<span class="line-number">358</span>                    tokens, original_start, original_end, func_name
<span class="line-number">359</span>                )
<span class="line-number">360</span>
<span class="line-number">361</span>            try:
<span class="line-number">362</span>                # Create function with declaration flag
<span class="line-number">363</span>                function = Function(func_name, return_type, parameters)
<span class="line-number">364</span>                # Add a custom attribute to track if this is a declaration
<span class="line-number">365</span>                function.is_declaration = is_declaration
<span class="line-number">366</span>                functions.append(function)
<span class="line-number">367</span>                self.logger.debug(
<span class="line-number">368</span>                    f&quot;Parsed function: {func_name} with {len(parameters)} parameters (declaration: {is_declaration})&quot;
<span class="line-number">369</span>                )
<span class="line-number">370</span><span class="uncovered">            except Exception as e:</span>
<span class="line-number">371</span><span class="uncovered">                self.logger.warning(&quot;Error creating function %s: %s&quot;, func_name, e)</span>
<span class="line-number">372</span>
<span class="line-number">373</span>        return functions
<span class="line-number">374</span>
<span class="line-number">375</span>    def _parse_globals_with_tokenizer(self, tokens) -&gt; List[&quot;Field&quot;]:
<span class="line-number">376</span>        &quot;&quot;&quot;Parse global variables using tokenizer&quot;&quot;&quot;
<span class="line-number">377</span>        from .models import Field
<span class="line-number">378</span>
<span class="line-number">379</span>        globals_list = []
<span class="line-number">380</span>
<span class="line-number">381</span>        i = 0
<span class="line-number">382</span>        while i &lt; len(tokens):
<span class="line-number">383</span>            # Skip preprocessor directives, comments, etc.
<span class="line-number">384</span>            if tokens[i].type in [
<span class="line-number">385</span>                TokenType.INCLUDE,
<span class="line-number">386</span>                TokenType.DEFINE,
<span class="line-number">387</span>                TokenType.COMMENT,
<span class="line-number">388</span>                TokenType.WHITESPACE,
<span class="line-number">389</span>                TokenType.NEWLINE,
<span class="line-number">390</span>            ]:
<span class="line-number">391</span>                i += 1
<span class="line-number">392</span>                continue
<span class="line-number">393</span>
<span class="line-number">394</span>            # Skip preprocessor directives but keep their content
<span class="line-number">395</span>            if tokens[i].type == TokenType.PREPROCESSOR:
<span class="line-number">396</span><span class="uncovered">                i = self._skip_preprocessor_directives(tokens, i)</span>
<span class="line-number">397</span><span class="uncovered">                continue</span>
<span class="line-number">398</span>
<span class="line-number">399</span>            # Skip function definitions (look for parentheses)
<span class="line-number">400</span>            if self._looks_like_function(tokens, i):
<span class="line-number">401</span>                i = self._skip_function(tokens, i)
<span class="line-number">402</span>                continue
<span class="line-number">403</span>
<span class="line-number">404</span>            # Skip struct/enum/union definitions
<span class="line-number">405</span>            if tokens[i].type in [
<span class="line-number">406</span>                TokenType.STRUCT,
<span class="line-number">407</span>                TokenType.ENUM,
<span class="line-number">408</span>                TokenType.UNION,
<span class="line-number">409</span>                TokenType.TYPEDEF,
<span class="line-number">410</span>            ]:
<span class="line-number">411</span>                i = self._skip_structure_definition(tokens, i)
<span class="line-number">412</span>                continue
<span class="line-number">413</span>
<span class="line-number">414</span>            # Skip if we&#x27;re inside a struct definition (look for opening brace)
<span class="line-number">415</span>            if i &gt; 0 and tokens[i - 1].type == TokenType.LBRACE:
<span class="line-number">416</span>                # We&#x27;re inside a struct, skip until closing brace
<span class="line-number">417</span><span class="uncovered">                brace_count = 1</span>
<span class="line-number">418</span><span class="uncovered">                j = i</span>
<span class="line-number">419</span><span class="uncovered">                while j &lt; len(tokens) and brace_count &gt; 0:</span>
<span class="line-number">420</span><span class="uncovered">                    if tokens[j].type == TokenType.LBRACE:</span>
<span class="line-number">421</span><span class="uncovered">                        brace_count += 1</span>
<span class="line-number">422</span><span class="uncovered">                    elif tokens[j].type == TokenType.RBRACE:</span>
<span class="line-number">423</span><span class="uncovered">                        brace_count -= 1</span>
<span class="line-number">424</span><span class="uncovered">                    j += 1</span>
<span class="line-number">425</span><span class="uncovered">                i = j</span>
<span class="line-number">426</span><span class="uncovered">                continue</span>
<span class="line-number">427</span>
<span class="line-number">428</span>            # Skip macros and other preprocessor content
<span class="line-number">429</span>            if tokens[i].type == TokenType.DEFINE:
<span class="line-number">430</span>                # Skip the entire macro content (multi-line macros are now merged)
<span class="line-number">431</span><span class="uncovered">                i += 1</span>
<span class="line-number">432</span><span class="uncovered">                continue</span>
<span class="line-number">433</span>
<span class="line-number">434</span>            # Additional check: skip if we&#x27;re inside any brace block (struct, function, etc.)
<span class="line-number">435</span>            brace_count = 0
<span class="line-number">436</span>            j = i - 1
<span class="line-number">437</span>            while j &gt;= 0:
<span class="line-number">438</span>                if tokens[j].type == TokenType.RBRACE:
<span class="line-number">439</span>                    brace_count += 1
<span class="line-number">440</span>                elif tokens[j].type == TokenType.LBRACE:
<span class="line-number">441</span>                    brace_count -= 1
<span class="line-number">442</span>                    if brace_count &lt; 0:
<span class="line-number">443</span>                        # We&#x27;re inside a brace block, skip this token
<span class="line-number">444</span>                        i += 1
<span class="line-number">445</span>                        break
<span class="line-number">446</span>                j -= 1
<span class="line-number">447</span>            else:
<span class="line-number">448</span>                # Not inside a brace block, proceed with global variable parsing
<span class="line-number">449</span>                global_info = self._parse_global_variable(tokens, i)
<span class="line-number">450</span>                if global_info:
<span class="line-number">451</span>                    var_name, var_type, var_value = global_info
<span class="line-number">452</span>                    # Only add if it looks like a real global variable (not a fragment)
<span class="line-number">453</span>                    if (
<span class="line-number">454</span>                        var_name
<span class="line-number">455</span>                        and var_name.strip()
<span class="line-number">456</span>                        and var_type
<span class="line-number">457</span>                        and var_type.strip()
<span class="line-number">458</span>                        and not var_name.startswith(&quot;#&quot;)
<span class="line-number">459</span>                        and len(var_type) &lt; 200
<span class="line-number">460</span>                        and not var_type.startswith(&quot;\\&quot;)
<span class="line-number">461</span>                        and not var_name.startswith(&quot;\\&quot;)
<span class="line-number">462</span>                        and &quot;\\&quot; not in var_type
<span class="line-number">463</span>                        and &quot;\\&quot; not in var_name
<span class="line-number">464</span>                    ):
<span class="line-number">465</span>                        try:
<span class="line-number">466</span>                            # Additional validation before creating Field
<span class="line-number">467</span>                            stripped_name = var_name.strip()
<span class="line-number">468</span>                            stripped_type = var_type.strip()
<span class="line-number">469</span>                            if stripped_name and stripped_type:
<span class="line-number">470</span>                                globals_list.append(
<span class="line-number">471</span>                                    Field(
<span class="line-number">472</span>                                        name=stripped_name,
<span class="line-number">473</span>                                        type=stripped_type,
<span class="line-number">474</span>                                        value=var_value,
<span class="line-number">475</span>                                    )
<span class="line-number">476</span>                                )
<span class="line-number">477</span>                                self.logger.debug(
<span class="line-number">478</span>                                    f&quot;Parsed global: {stripped_name} : {stripped_type}&quot;
<span class="line-number">479</span>                                )
<span class="line-number">480</span><span class="uncovered">                        except Exception as e:</span>
<span class="line-number">481</span><span class="uncovered">                            self.logger.warning(</span>
<span class="line-number">482</span>                                f&quot;Error creating global field {var_name}: {e}&quot;
<span class="line-number">483</span>                            )
<span class="line-number">484</span>                    i = self._skip_to_semicolon(tokens, i)
<span class="line-number">485</span>                else:
<span class="line-number">486</span>                    i += 1
<span class="line-number">487</span>
<span class="line-number">488</span>        return globals_list
<span class="line-number">489</span>
<span class="line-number">490</span>    def _parse_includes_with_tokenizer(self, tokens) -&gt; List[str]:
<span class="line-number">491</span>        &quot;&quot;&quot;Parse #include directives using tokenizer&quot;&quot;&quot;
<span class="line-number">492</span>        includes = []
<span class="line-number">493</span>
<span class="line-number">494</span>        for token in tokens:
<span class="line-number">495</span>            if token.type == TokenType.INCLUDE:
<span class="line-number">496</span>                # Extract include filename from the token value
<span class="line-number">497</span>                # e.g., &quot;#include &lt;stdio.h&gt;&quot; -&gt; &quot;stdio.h&quot;
<span class="line-number">498</span>                # e.g., &#x27;#include &quot;header.h&quot;&#x27; -&gt; &quot;header.h&quot;
<span class="line-number">499</span>                # e.g., &quot;#include &#x27;header.h&#x27;&quot; -&gt; &quot;header.h&quot;
<span class="line-number">500</span>                import re
<span class="line-number">501</span>
<span class="line-number">502</span>                match = re.search(r&#x27;[&lt;&quot;\&#x27;]([^&gt;\&#x27;&quot;]+)[&gt;\&#x27;&quot;]&#x27;, token.value)
<span class="line-number">503</span>                if match:
<span class="line-number">504</span>                    # Return just the filename without quotes or angle brackets
<span class="line-number">505</span>                    includes.append(match.group(1))
<span class="line-number">506</span>
<span class="line-number">507</span>        return includes
<span class="line-number">508</span>
<span class="line-number">509</span>    def _parse_macros_with_tokenizer(self, tokens) -&gt; List[str]:
<span class="line-number">510</span>        &quot;&quot;&quot;Parse macro definitions using tokenizer&quot;&quot;&quot;
<span class="line-number">511</span>        macros = []
<span class="line-number">512</span>
<span class="line-number">513</span>        for token in tokens:
<span class="line-number">514</span>            if token.type == TokenType.DEFINE:
<span class="line-number">515</span>                # Extract macro name and parameters only, not the full value
<span class="line-number">516</span>                # e.g., &quot;#define PI 3.14159&quot; -&gt; &quot;PI&quot;
<span class="line-number">517</span>                # e.g., &quot;#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))&quot; -&gt; &quot;MIN(a, b)&quot;
<span class="line-number">518</span>                import re
<span class="line-number">519</span>
<span class="line-number">520</span>                # For function-like macros: extract name and parameters
<span class="line-number">521</span>                func_match = re.search(
<span class="line-number">522</span>                    r&quot;#define\s+([A-Za-z_][A-Za-z0-9_]*\s*\([^)]*\))&quot;, token.value
<span class="line-number">523</span>                )
<span class="line-number">524</span>                if func_match:
<span class="line-number">525</span>                    macros.append(func_match.group(1))
<span class="line-number">526</span>                else:
<span class="line-number">527</span>                    # For simple defines: extract only the name
<span class="line-number">528</span>                    simple_match = re.search(
<span class="line-number">529</span>                        r&quot;#define\s+([A-Za-z_][A-Za-z0-9_]*)&quot;, token.value
<span class="line-number">530</span>                    )
<span class="line-number">531</span>                    if simple_match:
<span class="line-number">532</span>                        macros.append(simple_match.group(1))
<span class="line-number">533</span>
<span class="line-number">534</span>        return macros
<span class="line-number">535</span>
<span class="line-number">536</span>    def _parse_aliases_with_tokenizer(self, tokens) -&gt; Dict[str, &quot;Alias&quot;]:
<span class="line-number">537</span>        &quot;&quot;&quot;Parse type aliases (primitive or derived typedefs) using tokenizer&quot;&quot;&quot;
<span class="line-number">538</span>        from .models import Alias
<span class="line-number">539</span>
<span class="line-number">540</span>        aliases = {}
<span class="line-number">541</span>
<span class="line-number">542</span>        i = 0
<span class="line-number">543</span>        while i &lt; len(tokens):
<span class="line-number">544</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">545</span>                # Found typedef, parse it
<span class="line-number">546</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">547</span>                if typedef_info:
<span class="line-number">548</span>                    typedef_name, original_type = typedef_info
<span class="line-number">549</span>
<span class="line-number">550</span>                    # Only include if it&#x27;s NOT a struct/enum/union typedef
<span class="line-number">551</span>                    if original_type not in [&quot;struct&quot;, &quot;enum&quot;, &quot;union&quot;]:
<span class="line-number">552</span>                        aliases[typedef_name] = Alias(
<span class="line-number">553</span>                            name=typedef_name, original_type=original_type, uses=[]
<span class="line-number">554</span>                        )
<span class="line-number">555</span>
<span class="line-number">556</span>            i += 1
<span class="line-number">557</span>
<span class="line-number">558</span>        return aliases
<span class="line-number">559</span>
<span class="line-number">560</span>    # _parse_typedef_relations_with_tokenizer method removed - tag names are now in struct/enum/union
<span class="line-number">561</span>
<span class="line-number">562</span>    def _extract_tag_name_for_struct(self, tokens, struct_name: str) -&gt; str:
<span class="line-number">563</span>        &quot;&quot;&quot;Extract tag name for a struct if it has a typedef&quot;&quot;&quot;
<span class="line-number">564</span>        i = 0
<span class="line-number">565</span>        while i &lt; len(tokens):
<span class="line-number">566</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">567</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">568</span>                if typedef_info:
<span class="line-number">569</span>                    typedef_name, original_type = typedef_info
<span class="line-number">570</span>                    if original_type == &quot;struct&quot; and typedef_name == struct_name:
<span class="line-number">571</span>                        # Extract the tag name from the typedef
<span class="line-number">572</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">573</span>            i += 1
<span class="line-number">574</span>        return &quot;&quot;
<span class="line-number">575</span>
<span class="line-number">576</span>    def _extract_tag_name_for_enum(self, tokens, enum_name: str) -&gt; str:
<span class="line-number">577</span>        &quot;&quot;&quot;Extract tag name for an enum if it has a typedef&quot;&quot;&quot;
<span class="line-number">578</span>        i = 0
<span class="line-number">579</span>        while i &lt; len(tokens):
<span class="line-number">580</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">581</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">582</span>                if typedef_info:
<span class="line-number">583</span>                    typedef_name, original_type = typedef_info
<span class="line-number">584</span>                    if original_type == &quot;enum&quot; and typedef_name == enum_name:
<span class="line-number">585</span>                        # Extract the tag name from the typedef
<span class="line-number">586</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">587</span>            i += 1
<span class="line-number">588</span>        return &quot;&quot;
<span class="line-number">589</span>
<span class="line-number">590</span>    def _extract_tag_name_for_union(self, tokens, union_name: str) -&gt; str:
<span class="line-number">591</span>        &quot;&quot;&quot;Extract tag name for a union if it has a typedef&quot;&quot;&quot;
<span class="line-number">592</span>        i = 0
<span class="line-number">593</span>        while i &lt; len(tokens):
<span class="line-number">594</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">595</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">596</span>                if typedef_info:
<span class="line-number">597</span>                    typedef_name, original_type = typedef_info
<span class="line-number">598</span>                    if original_type == &quot;union&quot; and typedef_name == union_name:
<span class="line-number">599</span>                        # Extract the tag name from the typedef
<span class="line-number">600</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">601</span>            i += 1
<span class="line-number">602</span>        return &quot;&quot;
<span class="line-number">603</span>
<span class="line-number">604</span>    def _extract_non_primitive_types(
<span class="line-number">605</span>        self, type_str: str, available_types: Set[str]
<span class="line-number">606</span>    ) -&gt; List[str]:
<span class="line-number">607</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">608</span>        # Define primitive types
<span class="line-number">609</span><span class="uncovered">        primitive_types = {</span>
<span class="line-number">610</span>            &quot;void&quot;,
<span class="line-number">611</span>            &quot;char&quot;,
<span class="line-number">612</span>            &quot;short&quot;,
<span class="line-number">613</span>            &quot;int&quot;,
<span class="line-number">614</span>            &quot;long&quot;,
<span class="line-number">615</span>            &quot;float&quot;,
<span class="line-number">616</span>            &quot;double&quot;,
<span class="line-number">617</span>            &quot;signed&quot;,
<span class="line-number">618</span>            &quot;unsigned&quot;,
<span class="line-number">619</span>            &quot;const&quot;,
<span class="line-number">620</span>            &quot;volatile&quot;,
<span class="line-number">621</span>            &quot;static&quot;,
<span class="line-number">622</span>            &quot;extern&quot;,
<span class="line-number">623</span>            &quot;auto&quot;,
<span class="line-number">624</span>            &quot;register&quot;,
<span class="line-number">625</span>            &quot;inline&quot;,
<span class="line-number">626</span>            &quot;restrict&quot;,
<span class="line-number">627</span>            &quot;size_t&quot;,
<span class="line-number">628</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">629</span>            &quot;int8_t&quot;,
<span class="line-number">630</span>            &quot;int16_t&quot;,
<span class="line-number">631</span>            &quot;int32_t&quot;,
<span class="line-number">632</span>            &quot;int64_t&quot;,
<span class="line-number">633</span>            &quot;uint8_t&quot;,
<span class="line-number">634</span>            &quot;uint16_t&quot;,
<span class="line-number">635</span>            &quot;uint32_t&quot;,
<span class="line-number">636</span>            &quot;uint64_t&quot;,
<span class="line-number">637</span>            &quot;intptr_t&quot;,
<span class="line-number">638</span>            &quot;uintptr_t&quot;,
<span class="line-number">639</span>            &quot;bool&quot;,
<span class="line-number">640</span>            &quot;true&quot;,
<span class="line-number">641</span>            &quot;false&quot;,
<span class="line-number">642</span>            &quot;NULL&quot;,
<span class="line-number">643</span>            &quot;nullptr&quot;,
<span class="line-number">644</span>        }
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span><span class="uncovered">        import re</span>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span><span class="uncovered">        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)</span>
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span><span class="uncovered">        types = []</span>
<span class="line-number">654</span><span class="uncovered">        for part in parts:</span>
<span class="line-number">655</span><span class="uncovered">            part = part.strip()</span>
<span class="line-number">656</span><span class="uncovered">            if part and len(part) &gt; 1 and part not in primitive_types:</span>
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span><span class="uncovered">                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):</span>
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span><span class="uncovered">                    if part in available_types:</span>
<span class="line-number">661</span><span class="uncovered">                        types.append(part)</span>
<span class="line-number">662</span>
<span class="line-number">663</span><span class="uncovered">        return list(set(types))  # Remove duplicates</span>
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
<span class="line-number">669</span>
<span class="line-number">670</span>        self.logger.debug(&quot;Searching for files with extensions: %s&quot;, c_extensions)
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
<span class="line-number">696</span>
<span class="line-number">697</span>    def _find_files_with_include_dependencies(
<span class="line-number">698</span>        self, project_root: Path, recursive_search: bool, config: &quot;Config&quot;
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
<span class="line-number">710</span>        # Step 1: Find all C/C++ files in the project
<span class="line-number">711</span>        all_c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number">712</span>        self.logger.debug(&quot;All C files found: %s&quot;, [f.name for f in all_c_files])
<span class="line-number">713</span>
<span class="line-number">714</span>        # Step 2: Apply initial file filtering (include/exclude patterns) and separate .c and .h files
<span class="line-number">715</span>        initial_c_files = []  # Only .c files as starting files
<span class="line-number">716</span>        all_header_files = []  # All .h files for later include processing
<span class="line-number">717</span>
<span class="line-number">718</span>        for file_path in all_c_files:
<span class="line-number">719</span>            relative_path = str(file_path.relative_to(project_root))
<span class="line-number">720</span>            if self._should_include_file(relative_path, config):
<span class="line-number">721</span>                if file_path.suffix in [&quot;.c&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;]:
<span class="line-number">722</span>                    initial_c_files.append(file_path)
<span class="line-number">723</span>                    self.logger.debug(
<span class="line-number">724</span>                        f&quot;Included C file after filtering: {relative_path}&quot;
<span class="line-number">725</span>                    )
<span class="line-number">726</span>                else:
<span class="line-number">727</span>                    all_header_files.append(file_path)
<span class="line-number">728</span>                    self.logger.debug(&quot;Found header file: %s&quot;, relative_path)
<span class="line-number">729</span>            else:
<span class="line-number">730</span>                self.logger.debug(&quot;Excluded file after filtering: %s&quot;, relative_path)
<span class="line-number">731</span>
<span class="line-number">732</span>        self.logger.info(
<span class="line-number">733</span>            f&quot;Initial C files after filtering: {len(initial_c_files)} files&quot;
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
<span class="line-number">745</span>            self.logger.info(&quot;Processing include iteration %d&quot;, iteration + 1)
<span class="line-number">746</span>
<span class="line-number">747</span>            # Get the files that were in the list at the start of this iteration
<span class="line-number">748</span>            files_at_start_of_iteration = list(files_to_parse)
<span class="line-number">749</span>            self.logger.debug(
<span class="line-number">750</span>                f&quot;Files at start of iteration {iteration + 1}: {[f.name for f in files_at_start_of_iteration]}&quot;
<span class="line-number">751</span>            )
<span class="line-number">752</span>
<span class="line-number">753</span>            # Find all includes from files that were in the list at the start of this iteration
<span class="line-number">754</span>            new_includes = set()
<span class="line-number">755</span>            for file_path in files_at_start_of_iteration:
<span class="line-number">756</span>                # Extract includes from this file
<span class="line-number">757</span>                includes = self._extract_includes_from_file(file_path)
<span class="line-number">758</span>                self.logger.debug(&quot;Found includes in %s: %s&quot;, file_path.name, includes)
<span class="line-number">759</span>
<span class="line-number">760</span>                # Find the actual header files
<span class="line-number">761</span>                for include_name in includes:
<span class="line-number">762</span>                    included_file = self._find_included_file(
<span class="line-number">763</span>                        include_name, file_path, project_root
<span class="line-number">764</span>                    )
<span class="line-number">765</span>                    if included_file and included_file not in files_to_parse:
<span class="line-number">766</span>                        # Check if the included file should be included based on config
<span class="line-number">767</span>                        relative_included_path = str(
<span class="line-number">768</span>                            included_file.relative_to(project_root)
<span class="line-number">769</span>                        )
<span class="line-number">770</span>                        if self._should_include_file(relative_included_path, config):
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
<span class="line-number">782</span>                        )
<span class="line-number">783</span>                    else:
<span class="line-number">784</span>                        self.logger.debug(
<span class="line-number">785</span>                            f&quot;Could not find included file: {include_name}&quot;
<span class="line-number">786</span>                        )
<span class="line-number">787</span>
<span class="line-number">788</span>            # Add new includes to the parsing list
<span class="line-number">789</span>            files_to_parse.update(new_includes)
<span class="line-number">790</span>            self.logger.info(
<span class="line-number">791</span>                f&quot;Iteration {iteration + 1}: Added {len(new_includes)} new files&quot;
<span class="line-number">792</span>            )
<span class="line-number">793</span>
<span class="line-number">794</span>            # If no new files were found, we can stop early
<span class="line-number">795</span>            if not new_includes:
<span class="line-number">796</span>                self.logger.info(
<span class="line-number">797</span>                    f&quot;No new files found in iteration {iteration + 1}, stopping early&quot;
<span class="line-number">798</span>                )
<span class="line-number">799</span>                break
<span class="line-number">800</span>
<span class="line-number">801</span>        result = list(files_to_parse)
<span class="line-number">802</span>        self.logger.info(&quot;Final file list: %d files&quot;, len(result))
<span class="line-number">803</span>        self.logger.debug(&quot;Final files: %s&quot;, [f.name for f in result])
<span class="line-number">804</span>        return result
<span class="line-number">805</span>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _parse_globals_with_tokenizer (lines 375-1493)</h4>
<pre>
<span class="line-number">375</span>    def _parse_globals_with_tokenizer(self, tokens) -&gt; List[&quot;Field&quot;]:
<span class="line-number">376</span>        &quot;&quot;&quot;Parse global variables using tokenizer&quot;&quot;&quot;
<span class="line-number">377</span>        from .models import Field
<span class="line-number">378</span>
<span class="line-number">379</span>        globals_list = []
<span class="line-number">380</span>
<span class="line-number">381</span>        i = 0
<span class="line-number">382</span>        while i &lt; len(tokens):
<span class="line-number">383</span>            # Skip preprocessor directives, comments, etc.
<span class="line-number">384</span>            if tokens[i].type in [
<span class="line-number">385</span>                TokenType.INCLUDE,
<span class="line-number">386</span>                TokenType.DEFINE,
<span class="line-number">387</span>                TokenType.COMMENT,
<span class="line-number">388</span>                TokenType.WHITESPACE,
<span class="line-number">389</span>                TokenType.NEWLINE,
<span class="line-number">390</span>            ]:
<span class="line-number">391</span>                i += 1
<span class="line-number">392</span>                continue
<span class="line-number">393</span>
<span class="line-number">394</span>            # Skip preprocessor directives but keep their content
<span class="line-number">395</span>            if tokens[i].type == TokenType.PREPROCESSOR:
<span class="line-number">396</span><span class="uncovered">                i = self._skip_preprocessor_directives(tokens, i)</span>
<span class="line-number">397</span><span class="uncovered">                continue</span>
<span class="line-number">398</span>
<span class="line-number">399</span>            # Skip function definitions (look for parentheses)
<span class="line-number">400</span>            if self._looks_like_function(tokens, i):
<span class="line-number">401</span>                i = self._skip_function(tokens, i)
<span class="line-number">402</span>                continue
<span class="line-number">403</span>
<span class="line-number">404</span>            # Skip struct/enum/union definitions
<span class="line-number">405</span>            if tokens[i].type in [
<span class="line-number">406</span>                TokenType.STRUCT,
<span class="line-number">407</span>                TokenType.ENUM,
<span class="line-number">408</span>                TokenType.UNION,
<span class="line-number">409</span>                TokenType.TYPEDEF,
<span class="line-number">410</span>            ]:
<span class="line-number">411</span>                i = self._skip_structure_definition(tokens, i)
<span class="line-number">412</span>                continue
<span class="line-number">413</span>
<span class="line-number">414</span>            # Skip if we&#x27;re inside a struct definition (look for opening brace)
<span class="line-number">415</span>            if i &gt; 0 and tokens[i - 1].type == TokenType.LBRACE:
<span class="line-number">416</span>                # We&#x27;re inside a struct, skip until closing brace
<span class="line-number">417</span><span class="uncovered">                brace_count = 1</span>
<span class="line-number">418</span><span class="uncovered">                j = i</span>
<span class="line-number">419</span><span class="uncovered">                while j &lt; len(tokens) and brace_count &gt; 0:</span>
<span class="line-number">420</span><span class="uncovered">                    if tokens[j].type == TokenType.LBRACE:</span>
<span class="line-number">421</span><span class="uncovered">                        brace_count += 1</span>
<span class="line-number">422</span><span class="uncovered">                    elif tokens[j].type == TokenType.RBRACE:</span>
<span class="line-number">423</span><span class="uncovered">                        brace_count -= 1</span>
<span class="line-number">424</span><span class="uncovered">                    j += 1</span>
<span class="line-number">425</span><span class="uncovered">                i = j</span>
<span class="line-number">426</span><span class="uncovered">                continue</span>
<span class="line-number">427</span>
<span class="line-number">428</span>            # Skip macros and other preprocessor content
<span class="line-number">429</span>            if tokens[i].type == TokenType.DEFINE:
<span class="line-number">430</span>                # Skip the entire macro content (multi-line macros are now merged)
<span class="line-number">431</span><span class="uncovered">                i += 1</span>
<span class="line-number">432</span><span class="uncovered">                continue</span>
<span class="line-number">433</span>
<span class="line-number">434</span>            # Additional check: skip if we&#x27;re inside any brace block (struct, function, etc.)
<span class="line-number">435</span>            brace_count = 0
<span class="line-number">436</span>            j = i - 1
<span class="line-number">437</span>            while j &gt;= 0:
<span class="line-number">438</span>                if tokens[j].type == TokenType.RBRACE:
<span class="line-number">439</span>                    brace_count += 1
<span class="line-number">440</span>                elif tokens[j].type == TokenType.LBRACE:
<span class="line-number">441</span>                    brace_count -= 1
<span class="line-number">442</span>                    if brace_count &lt; 0:
<span class="line-number">443</span>                        # We&#x27;re inside a brace block, skip this token
<span class="line-number">444</span>                        i += 1
<span class="line-number">445</span>                        break
<span class="line-number">446</span>                j -= 1
<span class="line-number">447</span>            else:
<span class="line-number">448</span>                # Not inside a brace block, proceed with global variable parsing
<span class="line-number">449</span>                global_info = self._parse_global_variable(tokens, i)
<span class="line-number">450</span>                if global_info:
<span class="line-number">451</span>                    var_name, var_type, var_value = global_info
<span class="line-number">452</span>                    # Only add if it looks like a real global variable (not a fragment)
<span class="line-number">453</span>                    if (
<span class="line-number">454</span>                        var_name
<span class="line-number">455</span>                        and var_name.strip()
<span class="line-number">456</span>                        and var_type
<span class="line-number">457</span>                        and var_type.strip()
<span class="line-number">458</span>                        and not var_name.startswith(&quot;#&quot;)
<span class="line-number">459</span>                        and len(var_type) &lt; 200
<span class="line-number">460</span>                        and not var_type.startswith(&quot;\\&quot;)
<span class="line-number">461</span>                        and not var_name.startswith(&quot;\\&quot;)
<span class="line-number">462</span>                        and &quot;\\&quot; not in var_type
<span class="line-number">463</span>                        and &quot;\\&quot; not in var_name
<span class="line-number">464</span>                    ):
<span class="line-number">465</span>                        try:
<span class="line-number">466</span>                            # Additional validation before creating Field
<span class="line-number">467</span>                            stripped_name = var_name.strip()
<span class="line-number">468</span>                            stripped_type = var_type.strip()
<span class="line-number">469</span>                            if stripped_name and stripped_type:
<span class="line-number">470</span>                                globals_list.append(
<span class="line-number">471</span>                                    Field(
<span class="line-number">472</span>                                        name=stripped_name,
<span class="line-number">473</span>                                        type=stripped_type,
<span class="line-number">474</span>                                        value=var_value,
<span class="line-number">475</span>                                    )
<span class="line-number">476</span>                                )
<span class="line-number">477</span>                                self.logger.debug(
<span class="line-number">478</span>                                    f&quot;Parsed global: {stripped_name} : {stripped_type}&quot;
<span class="line-number">479</span>                                )
<span class="line-number">480</span><span class="uncovered">                        except Exception as e:</span>
<span class="line-number">481</span><span class="uncovered">                            self.logger.warning(</span>
<span class="line-number">482</span>                                f&quot;Error creating global field {var_name}: {e}&quot;
<span class="line-number">483</span>                            )
<span class="line-number">484</span>                    i = self._skip_to_semicolon(tokens, i)
<span class="line-number">485</span>                else:
<span class="line-number">486</span>                    i += 1
<span class="line-number">487</span>
<span class="line-number">488</span>        return globals_list
<span class="line-number">489</span>
<span class="line-number">490</span>    def _parse_includes_with_tokenizer(self, tokens) -&gt; List[str]:
<span class="line-number">491</span>        &quot;&quot;&quot;Parse #include directives using tokenizer&quot;&quot;&quot;
<span class="line-number">492</span>        includes = []
<span class="line-number">493</span>
<span class="line-number">494</span>        for token in tokens:
<span class="line-number">495</span>            if token.type == TokenType.INCLUDE:
<span class="line-number">496</span>                # Extract include filename from the token value
<span class="line-number">497</span>                # e.g., &quot;#include &lt;stdio.h&gt;&quot; -&gt; &quot;stdio.h&quot;
<span class="line-number">498</span>                # e.g., &#x27;#include &quot;header.h&quot;&#x27; -&gt; &quot;header.h&quot;
<span class="line-number">499</span>                # e.g., &quot;#include &#x27;header.h&#x27;&quot; -&gt; &quot;header.h&quot;
<span class="line-number">500</span>                import re
<span class="line-number">501</span>
<span class="line-number">502</span>                match = re.search(r&#x27;[&lt;&quot;\&#x27;]([^&gt;\&#x27;&quot;]+)[&gt;\&#x27;&quot;]&#x27;, token.value)
<span class="line-number">503</span>                if match:
<span class="line-number">504</span>                    # Return just the filename without quotes or angle brackets
<span class="line-number">505</span>                    includes.append(match.group(1))
<span class="line-number">506</span>
<span class="line-number">507</span>        return includes
<span class="line-number">508</span>
<span class="line-number">509</span>    def _parse_macros_with_tokenizer(self, tokens) -&gt; List[str]:
<span class="line-number">510</span>        &quot;&quot;&quot;Parse macro definitions using tokenizer&quot;&quot;&quot;
<span class="line-number">511</span>        macros = []
<span class="line-number">512</span>
<span class="line-number">513</span>        for token in tokens:
<span class="line-number">514</span>            if token.type == TokenType.DEFINE:
<span class="line-number">515</span>                # Extract macro name and parameters only, not the full value
<span class="line-number">516</span>                # e.g., &quot;#define PI 3.14159&quot; -&gt; &quot;PI&quot;
<span class="line-number">517</span>                # e.g., &quot;#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))&quot; -&gt; &quot;MIN(a, b)&quot;
<span class="line-number">518</span>                import re
<span class="line-number">519</span>
<span class="line-number">520</span>                # For function-like macros: extract name and parameters
<span class="line-number">521</span>                func_match = re.search(
<span class="line-number">522</span>                    r&quot;#define\s+([A-Za-z_][A-Za-z0-9_]*\s*\([^)]*\))&quot;, token.value
<span class="line-number">523</span>                )
<span class="line-number">524</span>                if func_match:
<span class="line-number">525</span>                    macros.append(func_match.group(1))
<span class="line-number">526</span>                else:
<span class="line-number">527</span>                    # For simple defines: extract only the name
<span class="line-number">528</span>                    simple_match = re.search(
<span class="line-number">529</span>                        r&quot;#define\s+([A-Za-z_][A-Za-z0-9_]*)&quot;, token.value
<span class="line-number">530</span>                    )
<span class="line-number">531</span>                    if simple_match:
<span class="line-number">532</span>                        macros.append(simple_match.group(1))
<span class="line-number">533</span>
<span class="line-number">534</span>        return macros
<span class="line-number">535</span>
<span class="line-number">536</span>    def _parse_aliases_with_tokenizer(self, tokens) -&gt; Dict[str, &quot;Alias&quot;]:
<span class="line-number">537</span>        &quot;&quot;&quot;Parse type aliases (primitive or derived typedefs) using tokenizer&quot;&quot;&quot;
<span class="line-number">538</span>        from .models import Alias
<span class="line-number">539</span>
<span class="line-number">540</span>        aliases = {}
<span class="line-number">541</span>
<span class="line-number">542</span>        i = 0
<span class="line-number">543</span>        while i &lt; len(tokens):
<span class="line-number">544</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">545</span>                # Found typedef, parse it
<span class="line-number">546</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">547</span>                if typedef_info:
<span class="line-number">548</span>                    typedef_name, original_type = typedef_info
<span class="line-number">549</span>
<span class="line-number">550</span>                    # Only include if it&#x27;s NOT a struct/enum/union typedef
<span class="line-number">551</span>                    if original_type not in [&quot;struct&quot;, &quot;enum&quot;, &quot;union&quot;]:
<span class="line-number">552</span>                        aliases[typedef_name] = Alias(
<span class="line-number">553</span>                            name=typedef_name, original_type=original_type, uses=[]
<span class="line-number">554</span>                        )
<span class="line-number">555</span>
<span class="line-number">556</span>            i += 1
<span class="line-number">557</span>
<span class="line-number">558</span>        return aliases
<span class="line-number">559</span>
<span class="line-number">560</span>    # _parse_typedef_relations_with_tokenizer method removed - tag names are now in struct/enum/union
<span class="line-number">561</span>
<span class="line-number">562</span>    def _extract_tag_name_for_struct(self, tokens, struct_name: str) -&gt; str:
<span class="line-number">563</span>        &quot;&quot;&quot;Extract tag name for a struct if it has a typedef&quot;&quot;&quot;
<span class="line-number">564</span>        i = 0
<span class="line-number">565</span>        while i &lt; len(tokens):
<span class="line-number">566</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">567</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">568</span>                if typedef_info:
<span class="line-number">569</span>                    typedef_name, original_type = typedef_info
<span class="line-number">570</span>                    if original_type == &quot;struct&quot; and typedef_name == struct_name:
<span class="line-number">571</span>                        # Extract the tag name from the typedef
<span class="line-number">572</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">573</span>            i += 1
<span class="line-number">574</span>        return &quot;&quot;
<span class="line-number">575</span>
<span class="line-number">576</span>    def _extract_tag_name_for_enum(self, tokens, enum_name: str) -&gt; str:
<span class="line-number">577</span>        &quot;&quot;&quot;Extract tag name for an enum if it has a typedef&quot;&quot;&quot;
<span class="line-number">578</span>        i = 0
<span class="line-number">579</span>        while i &lt; len(tokens):
<span class="line-number">580</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">581</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">582</span>                if typedef_info:
<span class="line-number">583</span>                    typedef_name, original_type = typedef_info
<span class="line-number">584</span>                    if original_type == &quot;enum&quot; and typedef_name == enum_name:
<span class="line-number">585</span>                        # Extract the tag name from the typedef
<span class="line-number">586</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">587</span>            i += 1
<span class="line-number">588</span>        return &quot;&quot;
<span class="line-number">589</span>
<span class="line-number">590</span>    def _extract_tag_name_for_union(self, tokens, union_name: str) -&gt; str:
<span class="line-number">591</span>        &quot;&quot;&quot;Extract tag name for a union if it has a typedef&quot;&quot;&quot;
<span class="line-number">592</span>        i = 0
<span class="line-number">593</span>        while i &lt; len(tokens):
<span class="line-number">594</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">595</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">596</span>                if typedef_info:
<span class="line-number">597</span>                    typedef_name, original_type = typedef_info
<span class="line-number">598</span>                    if original_type == &quot;union&quot; and typedef_name == union_name:
<span class="line-number">599</span>                        # Extract the tag name from the typedef
<span class="line-number">600</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">601</span>            i += 1
<span class="line-number">602</span>        return &quot;&quot;
<span class="line-number">603</span>
<span class="line-number">604</span>    def _extract_non_primitive_types(
<span class="line-number">605</span>        self, type_str: str, available_types: Set[str]
<span class="line-number">606</span>    ) -&gt; List[str]:
<span class="line-number">607</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">608</span>        # Define primitive types
<span class="line-number">609</span><span class="uncovered">        primitive_types = {</span>
<span class="line-number">610</span>            &quot;void&quot;,
<span class="line-number">611</span>            &quot;char&quot;,
<span class="line-number">612</span>            &quot;short&quot;,
<span class="line-number">613</span>            &quot;int&quot;,
<span class="line-number">614</span>            &quot;long&quot;,
<span class="line-number">615</span>            &quot;float&quot;,
<span class="line-number">616</span>            &quot;double&quot;,
<span class="line-number">617</span>            &quot;signed&quot;,
<span class="line-number">618</span>            &quot;unsigned&quot;,
<span class="line-number">619</span>            &quot;const&quot;,
<span class="line-number">620</span>            &quot;volatile&quot;,
<span class="line-number">621</span>            &quot;static&quot;,
<span class="line-number">622</span>            &quot;extern&quot;,
<span class="line-number">623</span>            &quot;auto&quot;,
<span class="line-number">624</span>            &quot;register&quot;,
<span class="line-number">625</span>            &quot;inline&quot;,
<span class="line-number">626</span>            &quot;restrict&quot;,
<span class="line-number">627</span>            &quot;size_t&quot;,
<span class="line-number">628</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">629</span>            &quot;int8_t&quot;,
<span class="line-number">630</span>            &quot;int16_t&quot;,
<span class="line-number">631</span>            &quot;int32_t&quot;,
<span class="line-number">632</span>            &quot;int64_t&quot;,
<span class="line-number">633</span>            &quot;uint8_t&quot;,
<span class="line-number">634</span>            &quot;uint16_t&quot;,
<span class="line-number">635</span>            &quot;uint32_t&quot;,
<span class="line-number">636</span>            &quot;uint64_t&quot;,
<span class="line-number">637</span>            &quot;intptr_t&quot;,
<span class="line-number">638</span>            &quot;uintptr_t&quot;,
<span class="line-number">639</span>            &quot;bool&quot;,
<span class="line-number">640</span>            &quot;true&quot;,
<span class="line-number">641</span>            &quot;false&quot;,
<span class="line-number">642</span>            &quot;NULL&quot;,
<span class="line-number">643</span>            &quot;nullptr&quot;,
<span class="line-number">644</span>        }
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span><span class="uncovered">        import re</span>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span><span class="uncovered">        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)</span>
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span><span class="uncovered">        types = []</span>
<span class="line-number">654</span><span class="uncovered">        for part in parts:</span>
<span class="line-number">655</span><span class="uncovered">            part = part.strip()</span>
<span class="line-number">656</span><span class="uncovered">            if part and len(part) &gt; 1 and part not in primitive_types:</span>
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span><span class="uncovered">                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):</span>
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span><span class="uncovered">                    if part in available_types:</span>
<span class="line-number">661</span><span class="uncovered">                        types.append(part)</span>
<span class="line-number">662</span>
<span class="line-number">663</span><span class="uncovered">        return list(set(types))  # Remove duplicates</span>
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
<span class="line-number">669</span>
<span class="line-number">670</span>        self.logger.debug(&quot;Searching for files with extensions: %s&quot;, c_extensions)
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
<span class="line-number">696</span>
<span class="line-number">697</span>    def _find_files_with_include_dependencies(
<span class="line-number">698</span>        self, project_root: Path, recursive_search: bool, config: &quot;Config&quot;
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
<span class="line-number">710</span>        # Step 1: Find all C/C++ files in the project
<span class="line-number">711</span>        all_c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number">712</span>        self.logger.debug(&quot;All C files found: %s&quot;, [f.name for f in all_c_files])
<span class="line-number">713</span>
<span class="line-number">714</span>        # Step 2: Apply initial file filtering (include/exclude patterns) and separate .c and .h files
<span class="line-number">715</span>        initial_c_files = []  # Only .c files as starting files
<span class="line-number">716</span>        all_header_files = []  # All .h files for later include processing
<span class="line-number">717</span>
<span class="line-number">718</span>        for file_path in all_c_files:
<span class="line-number">719</span>            relative_path = str(file_path.relative_to(project_root))
<span class="line-number">720</span>            if self._should_include_file(relative_path, config):
<span class="line-number">721</span>                if file_path.suffix in [&quot;.c&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;]:
<span class="line-number">722</span>                    initial_c_files.append(file_path)
<span class="line-number">723</span>                    self.logger.debug(
<span class="line-number">724</span>                        f&quot;Included C file after filtering: {relative_path}&quot;
<span class="line-number">725</span>                    )
<span class="line-number">726</span>                else:
<span class="line-number">727</span>                    all_header_files.append(file_path)
<span class="line-number">728</span>                    self.logger.debug(&quot;Found header file: %s&quot;, relative_path)
<span class="line-number">729</span>            else:
<span class="line-number">730</span>                self.logger.debug(&quot;Excluded file after filtering: %s&quot;, relative_path)
<span class="line-number">731</span>
<span class="line-number">732</span>        self.logger.info(
<span class="line-number">733</span>            f&quot;Initial C files after filtering: {len(initial_c_files)} files&quot;
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
<span class="line-number">745</span>            self.logger.info(&quot;Processing include iteration %d&quot;, iteration + 1)
<span class="line-number">746</span>
<span class="line-number">747</span>            # Get the files that were in the list at the start of this iteration
<span class="line-number">748</span>            files_at_start_of_iteration = list(files_to_parse)
<span class="line-number">749</span>            self.logger.debug(
<span class="line-number">750</span>                f&quot;Files at start of iteration {iteration + 1}: {[f.name for f in files_at_start_of_iteration]}&quot;
<span class="line-number">751</span>            )
<span class="line-number">752</span>
<span class="line-number">753</span>            # Find all includes from files that were in the list at the start of this iteration
<span class="line-number">754</span>            new_includes = set()
<span class="line-number">755</span>            for file_path in files_at_start_of_iteration:
<span class="line-number">756</span>                # Extract includes from this file
<span class="line-number">757</span>                includes = self._extract_includes_from_file(file_path)
<span class="line-number">758</span>                self.logger.debug(&quot;Found includes in %s: %s&quot;, file_path.name, includes)
<span class="line-number">759</span>
<span class="line-number">760</span>                # Find the actual header files
<span class="line-number">761</span>                for include_name in includes:
<span class="line-number">762</span>                    included_file = self._find_included_file(
<span class="line-number">763</span>                        include_name, file_path, project_root
<span class="line-number">764</span>                    )
<span class="line-number">765</span>                    if included_file and included_file not in files_to_parse:
<span class="line-number">766</span>                        # Check if the included file should be included based on config
<span class="line-number">767</span>                        relative_included_path = str(
<span class="line-number">768</span>                            included_file.relative_to(project_root)
<span class="line-number">769</span>                        )
<span class="line-number">770</span>                        if self._should_include_file(relative_included_path, config):
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
<span class="line-number">782</span>                        )
<span class="line-number">783</span>                    else:
<span class="line-number">784</span>                        self.logger.debug(
<span class="line-number">785</span>                            f&quot;Could not find included file: {include_name}&quot;
<span class="line-number">786</span>                        )
<span class="line-number">787</span>
<span class="line-number">788</span>            # Add new includes to the parsing list
<span class="line-number">789</span>            files_to_parse.update(new_includes)
<span class="line-number">790</span>            self.logger.info(
<span class="line-number">791</span>                f&quot;Iteration {iteration + 1}: Added {len(new_includes)} new files&quot;
<span class="line-number">792</span>            )
<span class="line-number">793</span>
<span class="line-number">794</span>            # If no new files were found, we can stop early
<span class="line-number">795</span>            if not new_includes:
<span class="line-number">796</span>                self.logger.info(
<span class="line-number">797</span>                    f&quot;No new files found in iteration {iteration + 1}, stopping early&quot;
<span class="line-number">798</span>                )
<span class="line-number">799</span>                break
<span class="line-number">800</span>
<span class="line-number">801</span>        result = list(files_to_parse)
<span class="line-number">802</span>        self.logger.info(&quot;Final file list: %d files&quot;, len(result))
<span class="line-number">803</span>        self.logger.debug(&quot;Final files: %s&quot;, [f.name for f in result])
<span class="line-number">804</span>        return result
<span class="line-number">805</span>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _parse_includes_with_tokenizer (lines 490-1493)</h4>
<pre>
<span class="line-number">490</span>    def _parse_includes_with_tokenizer(self, tokens) -&gt; List[str]:
<span class="line-number">491</span>        &quot;&quot;&quot;Parse #include directives using tokenizer&quot;&quot;&quot;
<span class="line-number">492</span>        includes = []
<span class="line-number">493</span>
<span class="line-number">494</span>        for token in tokens:
<span class="line-number">495</span>            if token.type == TokenType.INCLUDE:
<span class="line-number">496</span>                # Extract include filename from the token value
<span class="line-number">497</span>                # e.g., &quot;#include &lt;stdio.h&gt;&quot; -&gt; &quot;stdio.h&quot;
<span class="line-number">498</span>                # e.g., &#x27;#include &quot;header.h&quot;&#x27; -&gt; &quot;header.h&quot;
<span class="line-number">499</span>                # e.g., &quot;#include &#x27;header.h&#x27;&quot; -&gt; &quot;header.h&quot;
<span class="line-number">500</span>                import re
<span class="line-number">501</span>
<span class="line-number">502</span>                match = re.search(r&#x27;[&lt;&quot;\&#x27;]([^&gt;\&#x27;&quot;]+)[&gt;\&#x27;&quot;]&#x27;, token.value)
<span class="line-number">503</span>                if match:
<span class="line-number">504</span>                    # Return just the filename without quotes or angle brackets
<span class="line-number">505</span>                    includes.append(match.group(1))
<span class="line-number">506</span>
<span class="line-number">507</span>        return includes
<span class="line-number">508</span>
<span class="line-number">509</span>    def _parse_macros_with_tokenizer(self, tokens) -&gt; List[str]:
<span class="line-number">510</span>        &quot;&quot;&quot;Parse macro definitions using tokenizer&quot;&quot;&quot;
<span class="line-number">511</span>        macros = []
<span class="line-number">512</span>
<span class="line-number">513</span>        for token in tokens:
<span class="line-number">514</span>            if token.type == TokenType.DEFINE:
<span class="line-number">515</span>                # Extract macro name and parameters only, not the full value
<span class="line-number">516</span>                # e.g., &quot;#define PI 3.14159&quot; -&gt; &quot;PI&quot;
<span class="line-number">517</span>                # e.g., &quot;#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))&quot; -&gt; &quot;MIN(a, b)&quot;
<span class="line-number">518</span>                import re
<span class="line-number">519</span>
<span class="line-number">520</span>                # For function-like macros: extract name and parameters
<span class="line-number">521</span>                func_match = re.search(
<span class="line-number">522</span>                    r&quot;#define\s+([A-Za-z_][A-Za-z0-9_]*\s*\([^)]*\))&quot;, token.value
<span class="line-number">523</span>                )
<span class="line-number">524</span>                if func_match:
<span class="line-number">525</span>                    macros.append(func_match.group(1))
<span class="line-number">526</span>                else:
<span class="line-number">527</span>                    # For simple defines: extract only the name
<span class="line-number">528</span>                    simple_match = re.search(
<span class="line-number">529</span>                        r&quot;#define\s+([A-Za-z_][A-Za-z0-9_]*)&quot;, token.value
<span class="line-number">530</span>                    )
<span class="line-number">531</span>                    if simple_match:
<span class="line-number">532</span>                        macros.append(simple_match.group(1))
<span class="line-number">533</span>
<span class="line-number">534</span>        return macros
<span class="line-number">535</span>
<span class="line-number">536</span>    def _parse_aliases_with_tokenizer(self, tokens) -&gt; Dict[str, &quot;Alias&quot;]:
<span class="line-number">537</span>        &quot;&quot;&quot;Parse type aliases (primitive or derived typedefs) using tokenizer&quot;&quot;&quot;
<span class="line-number">538</span>        from .models import Alias
<span class="line-number">539</span>
<span class="line-number">540</span>        aliases = {}
<span class="line-number">541</span>
<span class="line-number">542</span>        i = 0
<span class="line-number">543</span>        while i &lt; len(tokens):
<span class="line-number">544</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">545</span>                # Found typedef, parse it
<span class="line-number">546</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">547</span>                if typedef_info:
<span class="line-number">548</span>                    typedef_name, original_type = typedef_info
<span class="line-number">549</span>
<span class="line-number">550</span>                    # Only include if it&#x27;s NOT a struct/enum/union typedef
<span class="line-number">551</span>                    if original_type not in [&quot;struct&quot;, &quot;enum&quot;, &quot;union&quot;]:
<span class="line-number">552</span>                        aliases[typedef_name] = Alias(
<span class="line-number">553</span>                            name=typedef_name, original_type=original_type, uses=[]
<span class="line-number">554</span>                        )
<span class="line-number">555</span>
<span class="line-number">556</span>            i += 1
<span class="line-number">557</span>
<span class="line-number">558</span>        return aliases
<span class="line-number">559</span>
<span class="line-number">560</span>    # _parse_typedef_relations_with_tokenizer method removed - tag names are now in struct/enum/union
<span class="line-number">561</span>
<span class="line-number">562</span>    def _extract_tag_name_for_struct(self, tokens, struct_name: str) -&gt; str:
<span class="line-number">563</span>        &quot;&quot;&quot;Extract tag name for a struct if it has a typedef&quot;&quot;&quot;
<span class="line-number">564</span>        i = 0
<span class="line-number">565</span>        while i &lt; len(tokens):
<span class="line-number">566</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">567</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">568</span>                if typedef_info:
<span class="line-number">569</span>                    typedef_name, original_type = typedef_info
<span class="line-number">570</span>                    if original_type == &quot;struct&quot; and typedef_name == struct_name:
<span class="line-number">571</span>                        # Extract the tag name from the typedef
<span class="line-number">572</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">573</span>            i += 1
<span class="line-number">574</span>        return &quot;&quot;
<span class="line-number">575</span>
<span class="line-number">576</span>    def _extract_tag_name_for_enum(self, tokens, enum_name: str) -&gt; str:
<span class="line-number">577</span>        &quot;&quot;&quot;Extract tag name for an enum if it has a typedef&quot;&quot;&quot;
<span class="line-number">578</span>        i = 0
<span class="line-number">579</span>        while i &lt; len(tokens):
<span class="line-number">580</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">581</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">582</span>                if typedef_info:
<span class="line-number">583</span>                    typedef_name, original_type = typedef_info
<span class="line-number">584</span>                    if original_type == &quot;enum&quot; and typedef_name == enum_name:
<span class="line-number">585</span>                        # Extract the tag name from the typedef
<span class="line-number">586</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">587</span>            i += 1
<span class="line-number">588</span>        return &quot;&quot;
<span class="line-number">589</span>
<span class="line-number">590</span>    def _extract_tag_name_for_union(self, tokens, union_name: str) -&gt; str:
<span class="line-number">591</span>        &quot;&quot;&quot;Extract tag name for a union if it has a typedef&quot;&quot;&quot;
<span class="line-number">592</span>        i = 0
<span class="line-number">593</span>        while i &lt; len(tokens):
<span class="line-number">594</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">595</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">596</span>                if typedef_info:
<span class="line-number">597</span>                    typedef_name, original_type = typedef_info
<span class="line-number">598</span>                    if original_type == &quot;union&quot; and typedef_name == union_name:
<span class="line-number">599</span>                        # Extract the tag name from the typedef
<span class="line-number">600</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">601</span>            i += 1
<span class="line-number">602</span>        return &quot;&quot;
<span class="line-number">603</span>
<span class="line-number">604</span>    def _extract_non_primitive_types(
<span class="line-number">605</span>        self, type_str: str, available_types: Set[str]
<span class="line-number">606</span>    ) -&gt; List[str]:
<span class="line-number">607</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">608</span>        # Define primitive types
<span class="line-number">609</span><span class="uncovered">        primitive_types = {</span>
<span class="line-number">610</span>            &quot;void&quot;,
<span class="line-number">611</span>            &quot;char&quot;,
<span class="line-number">612</span>            &quot;short&quot;,
<span class="line-number">613</span>            &quot;int&quot;,
<span class="line-number">614</span>            &quot;long&quot;,
<span class="line-number">615</span>            &quot;float&quot;,
<span class="line-number">616</span>            &quot;double&quot;,
<span class="line-number">617</span>            &quot;signed&quot;,
<span class="line-number">618</span>            &quot;unsigned&quot;,
<span class="line-number">619</span>            &quot;const&quot;,
<span class="line-number">620</span>            &quot;volatile&quot;,
<span class="line-number">621</span>            &quot;static&quot;,
<span class="line-number">622</span>            &quot;extern&quot;,
<span class="line-number">623</span>            &quot;auto&quot;,
<span class="line-number">624</span>            &quot;register&quot;,
<span class="line-number">625</span>            &quot;inline&quot;,
<span class="line-number">626</span>            &quot;restrict&quot;,
<span class="line-number">627</span>            &quot;size_t&quot;,
<span class="line-number">628</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">629</span>            &quot;int8_t&quot;,
<span class="line-number">630</span>            &quot;int16_t&quot;,
<span class="line-number">631</span>            &quot;int32_t&quot;,
<span class="line-number">632</span>            &quot;int64_t&quot;,
<span class="line-number">633</span>            &quot;uint8_t&quot;,
<span class="line-number">634</span>            &quot;uint16_t&quot;,
<span class="line-number">635</span>            &quot;uint32_t&quot;,
<span class="line-number">636</span>            &quot;uint64_t&quot;,
<span class="line-number">637</span>            &quot;intptr_t&quot;,
<span class="line-number">638</span>            &quot;uintptr_t&quot;,
<span class="line-number">639</span>            &quot;bool&quot;,
<span class="line-number">640</span>            &quot;true&quot;,
<span class="line-number">641</span>            &quot;false&quot;,
<span class="line-number">642</span>            &quot;NULL&quot;,
<span class="line-number">643</span>            &quot;nullptr&quot;,
<span class="line-number">644</span>        }
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span><span class="uncovered">        import re</span>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span><span class="uncovered">        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)</span>
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span><span class="uncovered">        types = []</span>
<span class="line-number">654</span><span class="uncovered">        for part in parts:</span>
<span class="line-number">655</span><span class="uncovered">            part = part.strip()</span>
<span class="line-number">656</span><span class="uncovered">            if part and len(part) &gt; 1 and part not in primitive_types:</span>
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span><span class="uncovered">                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):</span>
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span><span class="uncovered">                    if part in available_types:</span>
<span class="line-number">661</span><span class="uncovered">                        types.append(part)</span>
<span class="line-number">662</span>
<span class="line-number">663</span><span class="uncovered">        return list(set(types))  # Remove duplicates</span>
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
<span class="line-number">669</span>
<span class="line-number">670</span>        self.logger.debug(&quot;Searching for files with extensions: %s&quot;, c_extensions)
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
<span class="line-number">696</span>
<span class="line-number">697</span>    def _find_files_with_include_dependencies(
<span class="line-number">698</span>        self, project_root: Path, recursive_search: bool, config: &quot;Config&quot;
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
<span class="line-number">710</span>        # Step 1: Find all C/C++ files in the project
<span class="line-number">711</span>        all_c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number">712</span>        self.logger.debug(&quot;All C files found: %s&quot;, [f.name for f in all_c_files])
<span class="line-number">713</span>
<span class="line-number">714</span>        # Step 2: Apply initial file filtering (include/exclude patterns) and separate .c and .h files
<span class="line-number">715</span>        initial_c_files = []  # Only .c files as starting files
<span class="line-number">716</span>        all_header_files = []  # All .h files for later include processing
<span class="line-number">717</span>
<span class="line-number">718</span>        for file_path in all_c_files:
<span class="line-number">719</span>            relative_path = str(file_path.relative_to(project_root))
<span class="line-number">720</span>            if self._should_include_file(relative_path, config):
<span class="line-number">721</span>                if file_path.suffix in [&quot;.c&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;]:
<span class="line-number">722</span>                    initial_c_files.append(file_path)
<span class="line-number">723</span>                    self.logger.debug(
<span class="line-number">724</span>                        f&quot;Included C file after filtering: {relative_path}&quot;
<span class="line-number">725</span>                    )
<span class="line-number">726</span>                else:
<span class="line-number">727</span>                    all_header_files.append(file_path)
<span class="line-number">728</span>                    self.logger.debug(&quot;Found header file: %s&quot;, relative_path)
<span class="line-number">729</span>            else:
<span class="line-number">730</span>                self.logger.debug(&quot;Excluded file after filtering: %s&quot;, relative_path)
<span class="line-number">731</span>
<span class="line-number">732</span>        self.logger.info(
<span class="line-number">733</span>            f&quot;Initial C files after filtering: {len(initial_c_files)} files&quot;
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
<span class="line-number">745</span>            self.logger.info(&quot;Processing include iteration %d&quot;, iteration + 1)
<span class="line-number">746</span>
<span class="line-number">747</span>            # Get the files that were in the list at the start of this iteration
<span class="line-number">748</span>            files_at_start_of_iteration = list(files_to_parse)
<span class="line-number">749</span>            self.logger.debug(
<span class="line-number">750</span>                f&quot;Files at start of iteration {iteration + 1}: {[f.name for f in files_at_start_of_iteration]}&quot;
<span class="line-number">751</span>            )
<span class="line-number">752</span>
<span class="line-number">753</span>            # Find all includes from files that were in the list at the start of this iteration
<span class="line-number">754</span>            new_includes = set()
<span class="line-number">755</span>            for file_path in files_at_start_of_iteration:
<span class="line-number">756</span>                # Extract includes from this file
<span class="line-number">757</span>                includes = self._extract_includes_from_file(file_path)
<span class="line-number">758</span>                self.logger.debug(&quot;Found includes in %s: %s&quot;, file_path.name, includes)
<span class="line-number">759</span>
<span class="line-number">760</span>                # Find the actual header files
<span class="line-number">761</span>                for include_name in includes:
<span class="line-number">762</span>                    included_file = self._find_included_file(
<span class="line-number">763</span>                        include_name, file_path, project_root
<span class="line-number">764</span>                    )
<span class="line-number">765</span>                    if included_file and included_file not in files_to_parse:
<span class="line-number">766</span>                        # Check if the included file should be included based on config
<span class="line-number">767</span>                        relative_included_path = str(
<span class="line-number">768</span>                            included_file.relative_to(project_root)
<span class="line-number">769</span>                        )
<span class="line-number">770</span>                        if self._should_include_file(relative_included_path, config):
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
<span class="line-number">782</span>                        )
<span class="line-number">783</span>                    else:
<span class="line-number">784</span>                        self.logger.debug(
<span class="line-number">785</span>                            f&quot;Could not find included file: {include_name}&quot;
<span class="line-number">786</span>                        )
<span class="line-number">787</span>
<span class="line-number">788</span>            # Add new includes to the parsing list
<span class="line-number">789</span>            files_to_parse.update(new_includes)
<span class="line-number">790</span>            self.logger.info(
<span class="line-number">791</span>                f&quot;Iteration {iteration + 1}: Added {len(new_includes)} new files&quot;
<span class="line-number">792</span>            )
<span class="line-number">793</span>
<span class="line-number">794</span>            # If no new files were found, we can stop early
<span class="line-number">795</span>            if not new_includes:
<span class="line-number">796</span>                self.logger.info(
<span class="line-number">797</span>                    f&quot;No new files found in iteration {iteration + 1}, stopping early&quot;
<span class="line-number">798</span>                )
<span class="line-number">799</span>                break
<span class="line-number">800</span>
<span class="line-number">801</span>        result = list(files_to_parse)
<span class="line-number">802</span>        self.logger.info(&quot;Final file list: %d files&quot;, len(result))
<span class="line-number">803</span>        self.logger.debug(&quot;Final files: %s&quot;, [f.name for f in result])
<span class="line-number">804</span>        return result
<span class="line-number">805</span>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _parse_macros_with_tokenizer (lines 509-1493)</h4>
<pre>
<span class="line-number">509</span>    def _parse_macros_with_tokenizer(self, tokens) -&gt; List[str]:
<span class="line-number">510</span>        &quot;&quot;&quot;Parse macro definitions using tokenizer&quot;&quot;&quot;
<span class="line-number">511</span>        macros = []
<span class="line-number">512</span>
<span class="line-number">513</span>        for token in tokens:
<span class="line-number">514</span>            if token.type == TokenType.DEFINE:
<span class="line-number">515</span>                # Extract macro name and parameters only, not the full value
<span class="line-number">516</span>                # e.g., &quot;#define PI 3.14159&quot; -&gt; &quot;PI&quot;
<span class="line-number">517</span>                # e.g., &quot;#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))&quot; -&gt; &quot;MIN(a, b)&quot;
<span class="line-number">518</span>                import re
<span class="line-number">519</span>
<span class="line-number">520</span>                # For function-like macros: extract name and parameters
<span class="line-number">521</span>                func_match = re.search(
<span class="line-number">522</span>                    r&quot;#define\s+([A-Za-z_][A-Za-z0-9_]*\s*\([^)]*\))&quot;, token.value
<span class="line-number">523</span>                )
<span class="line-number">524</span>                if func_match:
<span class="line-number">525</span>                    macros.append(func_match.group(1))
<span class="line-number">526</span>                else:
<span class="line-number">527</span>                    # For simple defines: extract only the name
<span class="line-number">528</span>                    simple_match = re.search(
<span class="line-number">529</span>                        r&quot;#define\s+([A-Za-z_][A-Za-z0-9_]*)&quot;, token.value
<span class="line-number">530</span>                    )
<span class="line-number">531</span>                    if simple_match:
<span class="line-number">532</span>                        macros.append(simple_match.group(1))
<span class="line-number">533</span>
<span class="line-number">534</span>        return macros
<span class="line-number">535</span>
<span class="line-number">536</span>    def _parse_aliases_with_tokenizer(self, tokens) -&gt; Dict[str, &quot;Alias&quot;]:
<span class="line-number">537</span>        &quot;&quot;&quot;Parse type aliases (primitive or derived typedefs) using tokenizer&quot;&quot;&quot;
<span class="line-number">538</span>        from .models import Alias
<span class="line-number">539</span>
<span class="line-number">540</span>        aliases = {}
<span class="line-number">541</span>
<span class="line-number">542</span>        i = 0
<span class="line-number">543</span>        while i &lt; len(tokens):
<span class="line-number">544</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">545</span>                # Found typedef, parse it
<span class="line-number">546</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">547</span>                if typedef_info:
<span class="line-number">548</span>                    typedef_name, original_type = typedef_info
<span class="line-number">549</span>
<span class="line-number">550</span>                    # Only include if it&#x27;s NOT a struct/enum/union typedef
<span class="line-number">551</span>                    if original_type not in [&quot;struct&quot;, &quot;enum&quot;, &quot;union&quot;]:
<span class="line-number">552</span>                        aliases[typedef_name] = Alias(
<span class="line-number">553</span>                            name=typedef_name, original_type=original_type, uses=[]
<span class="line-number">554</span>                        )
<span class="line-number">555</span>
<span class="line-number">556</span>            i += 1
<span class="line-number">557</span>
<span class="line-number">558</span>        return aliases
<span class="line-number">559</span>
<span class="line-number">560</span>    # _parse_typedef_relations_with_tokenizer method removed - tag names are now in struct/enum/union
<span class="line-number">561</span>
<span class="line-number">562</span>    def _extract_tag_name_for_struct(self, tokens, struct_name: str) -&gt; str:
<span class="line-number">563</span>        &quot;&quot;&quot;Extract tag name for a struct if it has a typedef&quot;&quot;&quot;
<span class="line-number">564</span>        i = 0
<span class="line-number">565</span>        while i &lt; len(tokens):
<span class="line-number">566</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">567</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">568</span>                if typedef_info:
<span class="line-number">569</span>                    typedef_name, original_type = typedef_info
<span class="line-number">570</span>                    if original_type == &quot;struct&quot; and typedef_name == struct_name:
<span class="line-number">571</span>                        # Extract the tag name from the typedef
<span class="line-number">572</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">573</span>            i += 1
<span class="line-number">574</span>        return &quot;&quot;
<span class="line-number">575</span>
<span class="line-number">576</span>    def _extract_tag_name_for_enum(self, tokens, enum_name: str) -&gt; str:
<span class="line-number">577</span>        &quot;&quot;&quot;Extract tag name for an enum if it has a typedef&quot;&quot;&quot;
<span class="line-number">578</span>        i = 0
<span class="line-number">579</span>        while i &lt; len(tokens):
<span class="line-number">580</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">581</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">582</span>                if typedef_info:
<span class="line-number">583</span>                    typedef_name, original_type = typedef_info
<span class="line-number">584</span>                    if original_type == &quot;enum&quot; and typedef_name == enum_name:
<span class="line-number">585</span>                        # Extract the tag name from the typedef
<span class="line-number">586</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">587</span>            i += 1
<span class="line-number">588</span>        return &quot;&quot;
<span class="line-number">589</span>
<span class="line-number">590</span>    def _extract_tag_name_for_union(self, tokens, union_name: str) -&gt; str:
<span class="line-number">591</span>        &quot;&quot;&quot;Extract tag name for a union if it has a typedef&quot;&quot;&quot;
<span class="line-number">592</span>        i = 0
<span class="line-number">593</span>        while i &lt; len(tokens):
<span class="line-number">594</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">595</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">596</span>                if typedef_info:
<span class="line-number">597</span>                    typedef_name, original_type = typedef_info
<span class="line-number">598</span>                    if original_type == &quot;union&quot; and typedef_name == union_name:
<span class="line-number">599</span>                        # Extract the tag name from the typedef
<span class="line-number">600</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">601</span>            i += 1
<span class="line-number">602</span>        return &quot;&quot;
<span class="line-number">603</span>
<span class="line-number">604</span>    def _extract_non_primitive_types(
<span class="line-number">605</span>        self, type_str: str, available_types: Set[str]
<span class="line-number">606</span>    ) -&gt; List[str]:
<span class="line-number">607</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">608</span>        # Define primitive types
<span class="line-number">609</span><span class="uncovered">        primitive_types = {</span>
<span class="line-number">610</span>            &quot;void&quot;,
<span class="line-number">611</span>            &quot;char&quot;,
<span class="line-number">612</span>            &quot;short&quot;,
<span class="line-number">613</span>            &quot;int&quot;,
<span class="line-number">614</span>            &quot;long&quot;,
<span class="line-number">615</span>            &quot;float&quot;,
<span class="line-number">616</span>            &quot;double&quot;,
<span class="line-number">617</span>            &quot;signed&quot;,
<span class="line-number">618</span>            &quot;unsigned&quot;,
<span class="line-number">619</span>            &quot;const&quot;,
<span class="line-number">620</span>            &quot;volatile&quot;,
<span class="line-number">621</span>            &quot;static&quot;,
<span class="line-number">622</span>            &quot;extern&quot;,
<span class="line-number">623</span>            &quot;auto&quot;,
<span class="line-number">624</span>            &quot;register&quot;,
<span class="line-number">625</span>            &quot;inline&quot;,
<span class="line-number">626</span>            &quot;restrict&quot;,
<span class="line-number">627</span>            &quot;size_t&quot;,
<span class="line-number">628</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">629</span>            &quot;int8_t&quot;,
<span class="line-number">630</span>            &quot;int16_t&quot;,
<span class="line-number">631</span>            &quot;int32_t&quot;,
<span class="line-number">632</span>            &quot;int64_t&quot;,
<span class="line-number">633</span>            &quot;uint8_t&quot;,
<span class="line-number">634</span>            &quot;uint16_t&quot;,
<span class="line-number">635</span>            &quot;uint32_t&quot;,
<span class="line-number">636</span>            &quot;uint64_t&quot;,
<span class="line-number">637</span>            &quot;intptr_t&quot;,
<span class="line-number">638</span>            &quot;uintptr_t&quot;,
<span class="line-number">639</span>            &quot;bool&quot;,
<span class="line-number">640</span>            &quot;true&quot;,
<span class="line-number">641</span>            &quot;false&quot;,
<span class="line-number">642</span>            &quot;NULL&quot;,
<span class="line-number">643</span>            &quot;nullptr&quot;,
<span class="line-number">644</span>        }
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span><span class="uncovered">        import re</span>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span><span class="uncovered">        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)</span>
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span><span class="uncovered">        types = []</span>
<span class="line-number">654</span><span class="uncovered">        for part in parts:</span>
<span class="line-number">655</span><span class="uncovered">            part = part.strip()</span>
<span class="line-number">656</span><span class="uncovered">            if part and len(part) &gt; 1 and part not in primitive_types:</span>
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span><span class="uncovered">                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):</span>
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span><span class="uncovered">                    if part in available_types:</span>
<span class="line-number">661</span><span class="uncovered">                        types.append(part)</span>
<span class="line-number">662</span>
<span class="line-number">663</span><span class="uncovered">        return list(set(types))  # Remove duplicates</span>
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
<span class="line-number">669</span>
<span class="line-number">670</span>        self.logger.debug(&quot;Searching for files with extensions: %s&quot;, c_extensions)
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
<span class="line-number">696</span>
<span class="line-number">697</span>    def _find_files_with_include_dependencies(
<span class="line-number">698</span>        self, project_root: Path, recursive_search: bool, config: &quot;Config&quot;
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
<span class="line-number">710</span>        # Step 1: Find all C/C++ files in the project
<span class="line-number">711</span>        all_c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number">712</span>        self.logger.debug(&quot;All C files found: %s&quot;, [f.name for f in all_c_files])
<span class="line-number">713</span>
<span class="line-number">714</span>        # Step 2: Apply initial file filtering (include/exclude patterns) and separate .c and .h files
<span class="line-number">715</span>        initial_c_files = []  # Only .c files as starting files
<span class="line-number">716</span>        all_header_files = []  # All .h files for later include processing
<span class="line-number">717</span>
<span class="line-number">718</span>        for file_path in all_c_files:
<span class="line-number">719</span>            relative_path = str(file_path.relative_to(project_root))
<span class="line-number">720</span>            if self._should_include_file(relative_path, config):
<span class="line-number">721</span>                if file_path.suffix in [&quot;.c&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;]:
<span class="line-number">722</span>                    initial_c_files.append(file_path)
<span class="line-number">723</span>                    self.logger.debug(
<span class="line-number">724</span>                        f&quot;Included C file after filtering: {relative_path}&quot;
<span class="line-number">725</span>                    )
<span class="line-number">726</span>                else:
<span class="line-number">727</span>                    all_header_files.append(file_path)
<span class="line-number">728</span>                    self.logger.debug(&quot;Found header file: %s&quot;, relative_path)
<span class="line-number">729</span>            else:
<span class="line-number">730</span>                self.logger.debug(&quot;Excluded file after filtering: %s&quot;, relative_path)
<span class="line-number">731</span>
<span class="line-number">732</span>        self.logger.info(
<span class="line-number">733</span>            f&quot;Initial C files after filtering: {len(initial_c_files)} files&quot;
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
<span class="line-number">745</span>            self.logger.info(&quot;Processing include iteration %d&quot;, iteration + 1)
<span class="line-number">746</span>
<span class="line-number">747</span>            # Get the files that were in the list at the start of this iteration
<span class="line-number">748</span>            files_at_start_of_iteration = list(files_to_parse)
<span class="line-number">749</span>            self.logger.debug(
<span class="line-number">750</span>                f&quot;Files at start of iteration {iteration + 1}: {[f.name for f in files_at_start_of_iteration]}&quot;
<span class="line-number">751</span>            )
<span class="line-number">752</span>
<span class="line-number">753</span>            # Find all includes from files that were in the list at the start of this iteration
<span class="line-number">754</span>            new_includes = set()
<span class="line-number">755</span>            for file_path in files_at_start_of_iteration:
<span class="line-number">756</span>                # Extract includes from this file
<span class="line-number">757</span>                includes = self._extract_includes_from_file(file_path)
<span class="line-number">758</span>                self.logger.debug(&quot;Found includes in %s: %s&quot;, file_path.name, includes)
<span class="line-number">759</span>
<span class="line-number">760</span>                # Find the actual header files
<span class="line-number">761</span>                for include_name in includes:
<span class="line-number">762</span>                    included_file = self._find_included_file(
<span class="line-number">763</span>                        include_name, file_path, project_root
<span class="line-number">764</span>                    )
<span class="line-number">765</span>                    if included_file and included_file not in files_to_parse:
<span class="line-number">766</span>                        # Check if the included file should be included based on config
<span class="line-number">767</span>                        relative_included_path = str(
<span class="line-number">768</span>                            included_file.relative_to(project_root)
<span class="line-number">769</span>                        )
<span class="line-number">770</span>                        if self._should_include_file(relative_included_path, config):
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
<span class="line-number">782</span>                        )
<span class="line-number">783</span>                    else:
<span class="line-number">784</span>                        self.logger.debug(
<span class="line-number">785</span>                            f&quot;Could not find included file: {include_name}&quot;
<span class="line-number">786</span>                        )
<span class="line-number">787</span>
<span class="line-number">788</span>            # Add new includes to the parsing list
<span class="line-number">789</span>            files_to_parse.update(new_includes)
<span class="line-number">790</span>            self.logger.info(
<span class="line-number">791</span>                f&quot;Iteration {iteration + 1}: Added {len(new_includes)} new files&quot;
<span class="line-number">792</span>            )
<span class="line-number">793</span>
<span class="line-number">794</span>            # If no new files were found, we can stop early
<span class="line-number">795</span>            if not new_includes:
<span class="line-number">796</span>                self.logger.info(
<span class="line-number">797</span>                    f&quot;No new files found in iteration {iteration + 1}, stopping early&quot;
<span class="line-number">798</span>                )
<span class="line-number">799</span>                break
<span class="line-number">800</span>
<span class="line-number">801</span>        result = list(files_to_parse)
<span class="line-number">802</span>        self.logger.info(&quot;Final file list: %d files&quot;, len(result))
<span class="line-number">803</span>        self.logger.debug(&quot;Final files: %s&quot;, [f.name for f in result])
<span class="line-number">804</span>        return result
<span class="line-number">805</span>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _parse_aliases_with_tokenizer (lines 536-1493)</h4>
<pre>
<span class="line-number">536</span>    def _parse_aliases_with_tokenizer(self, tokens) -&gt; Dict[str, &quot;Alias&quot;]:
<span class="line-number">537</span>        &quot;&quot;&quot;Parse type aliases (primitive or derived typedefs) using tokenizer&quot;&quot;&quot;
<span class="line-number">538</span>        from .models import Alias
<span class="line-number">539</span>
<span class="line-number">540</span>        aliases = {}
<span class="line-number">541</span>
<span class="line-number">542</span>        i = 0
<span class="line-number">543</span>        while i &lt; len(tokens):
<span class="line-number">544</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">545</span>                # Found typedef, parse it
<span class="line-number">546</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">547</span>                if typedef_info:
<span class="line-number">548</span>                    typedef_name, original_type = typedef_info
<span class="line-number">549</span>
<span class="line-number">550</span>                    # Only include if it&#x27;s NOT a struct/enum/union typedef
<span class="line-number">551</span>                    if original_type not in [&quot;struct&quot;, &quot;enum&quot;, &quot;union&quot;]:
<span class="line-number">552</span>                        aliases[typedef_name] = Alias(
<span class="line-number">553</span>                            name=typedef_name, original_type=original_type, uses=[]
<span class="line-number">554</span>                        )
<span class="line-number">555</span>
<span class="line-number">556</span>            i += 1
<span class="line-number">557</span>
<span class="line-number">558</span>        return aliases
<span class="line-number">559</span>
<span class="line-number">560</span>    # _parse_typedef_relations_with_tokenizer method removed - tag names are now in struct/enum/union
<span class="line-number">561</span>
<span class="line-number">562</span>    def _extract_tag_name_for_struct(self, tokens, struct_name: str) -&gt; str:
<span class="line-number">563</span>        &quot;&quot;&quot;Extract tag name for a struct if it has a typedef&quot;&quot;&quot;
<span class="line-number">564</span>        i = 0
<span class="line-number">565</span>        while i &lt; len(tokens):
<span class="line-number">566</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">567</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">568</span>                if typedef_info:
<span class="line-number">569</span>                    typedef_name, original_type = typedef_info
<span class="line-number">570</span>                    if original_type == &quot;struct&quot; and typedef_name == struct_name:
<span class="line-number">571</span>                        # Extract the tag name from the typedef
<span class="line-number">572</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">573</span>            i += 1
<span class="line-number">574</span>        return &quot;&quot;
<span class="line-number">575</span>
<span class="line-number">576</span>    def _extract_tag_name_for_enum(self, tokens, enum_name: str) -&gt; str:
<span class="line-number">577</span>        &quot;&quot;&quot;Extract tag name for an enum if it has a typedef&quot;&quot;&quot;
<span class="line-number">578</span>        i = 0
<span class="line-number">579</span>        while i &lt; len(tokens):
<span class="line-number">580</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">581</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">582</span>                if typedef_info:
<span class="line-number">583</span>                    typedef_name, original_type = typedef_info
<span class="line-number">584</span>                    if original_type == &quot;enum&quot; and typedef_name == enum_name:
<span class="line-number">585</span>                        # Extract the tag name from the typedef
<span class="line-number">586</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">587</span>            i += 1
<span class="line-number">588</span>        return &quot;&quot;
<span class="line-number">589</span>
<span class="line-number">590</span>    def _extract_tag_name_for_union(self, tokens, union_name: str) -&gt; str:
<span class="line-number">591</span>        &quot;&quot;&quot;Extract tag name for a union if it has a typedef&quot;&quot;&quot;
<span class="line-number">592</span>        i = 0
<span class="line-number">593</span>        while i &lt; len(tokens):
<span class="line-number">594</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">595</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">596</span>                if typedef_info:
<span class="line-number">597</span>                    typedef_name, original_type = typedef_info
<span class="line-number">598</span>                    if original_type == &quot;union&quot; and typedef_name == union_name:
<span class="line-number">599</span>                        # Extract the tag name from the typedef
<span class="line-number">600</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">601</span>            i += 1
<span class="line-number">602</span>        return &quot;&quot;
<span class="line-number">603</span>
<span class="line-number">604</span>    def _extract_non_primitive_types(
<span class="line-number">605</span>        self, type_str: str, available_types: Set[str]
<span class="line-number">606</span>    ) -&gt; List[str]:
<span class="line-number">607</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">608</span>        # Define primitive types
<span class="line-number">609</span><span class="uncovered">        primitive_types = {</span>
<span class="line-number">610</span>            &quot;void&quot;,
<span class="line-number">611</span>            &quot;char&quot;,
<span class="line-number">612</span>            &quot;short&quot;,
<span class="line-number">613</span>            &quot;int&quot;,
<span class="line-number">614</span>            &quot;long&quot;,
<span class="line-number">615</span>            &quot;float&quot;,
<span class="line-number">616</span>            &quot;double&quot;,
<span class="line-number">617</span>            &quot;signed&quot;,
<span class="line-number">618</span>            &quot;unsigned&quot;,
<span class="line-number">619</span>            &quot;const&quot;,
<span class="line-number">620</span>            &quot;volatile&quot;,
<span class="line-number">621</span>            &quot;static&quot;,
<span class="line-number">622</span>            &quot;extern&quot;,
<span class="line-number">623</span>            &quot;auto&quot;,
<span class="line-number">624</span>            &quot;register&quot;,
<span class="line-number">625</span>            &quot;inline&quot;,
<span class="line-number">626</span>            &quot;restrict&quot;,
<span class="line-number">627</span>            &quot;size_t&quot;,
<span class="line-number">628</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">629</span>            &quot;int8_t&quot;,
<span class="line-number">630</span>            &quot;int16_t&quot;,
<span class="line-number">631</span>            &quot;int32_t&quot;,
<span class="line-number">632</span>            &quot;int64_t&quot;,
<span class="line-number">633</span>            &quot;uint8_t&quot;,
<span class="line-number">634</span>            &quot;uint16_t&quot;,
<span class="line-number">635</span>            &quot;uint32_t&quot;,
<span class="line-number">636</span>            &quot;uint64_t&quot;,
<span class="line-number">637</span>            &quot;intptr_t&quot;,
<span class="line-number">638</span>            &quot;uintptr_t&quot;,
<span class="line-number">639</span>            &quot;bool&quot;,
<span class="line-number">640</span>            &quot;true&quot;,
<span class="line-number">641</span>            &quot;false&quot;,
<span class="line-number">642</span>            &quot;NULL&quot;,
<span class="line-number">643</span>            &quot;nullptr&quot;,
<span class="line-number">644</span>        }
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span><span class="uncovered">        import re</span>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span><span class="uncovered">        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)</span>
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span><span class="uncovered">        types = []</span>
<span class="line-number">654</span><span class="uncovered">        for part in parts:</span>
<span class="line-number">655</span><span class="uncovered">            part = part.strip()</span>
<span class="line-number">656</span><span class="uncovered">            if part and len(part) &gt; 1 and part not in primitive_types:</span>
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span><span class="uncovered">                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):</span>
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span><span class="uncovered">                    if part in available_types:</span>
<span class="line-number">661</span><span class="uncovered">                        types.append(part)</span>
<span class="line-number">662</span>
<span class="line-number">663</span><span class="uncovered">        return list(set(types))  # Remove duplicates</span>
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
<span class="line-number">669</span>
<span class="line-number">670</span>        self.logger.debug(&quot;Searching for files with extensions: %s&quot;, c_extensions)
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
<span class="line-number">696</span>
<span class="line-number">697</span>    def _find_files_with_include_dependencies(
<span class="line-number">698</span>        self, project_root: Path, recursive_search: bool, config: &quot;Config&quot;
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
<span class="line-number">710</span>        # Step 1: Find all C/C++ files in the project
<span class="line-number">711</span>        all_c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number">712</span>        self.logger.debug(&quot;All C files found: %s&quot;, [f.name for f in all_c_files])
<span class="line-number">713</span>
<span class="line-number">714</span>        # Step 2: Apply initial file filtering (include/exclude patterns) and separate .c and .h files
<span class="line-number">715</span>        initial_c_files = []  # Only .c files as starting files
<span class="line-number">716</span>        all_header_files = []  # All .h files for later include processing
<span class="line-number">717</span>
<span class="line-number">718</span>        for file_path in all_c_files:
<span class="line-number">719</span>            relative_path = str(file_path.relative_to(project_root))
<span class="line-number">720</span>            if self._should_include_file(relative_path, config):
<span class="line-number">721</span>                if file_path.suffix in [&quot;.c&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;]:
<span class="line-number">722</span>                    initial_c_files.append(file_path)
<span class="line-number">723</span>                    self.logger.debug(
<span class="line-number">724</span>                        f&quot;Included C file after filtering: {relative_path}&quot;
<span class="line-number">725</span>                    )
<span class="line-number">726</span>                else:
<span class="line-number">727</span>                    all_header_files.append(file_path)
<span class="line-number">728</span>                    self.logger.debug(&quot;Found header file: %s&quot;, relative_path)
<span class="line-number">729</span>            else:
<span class="line-number">730</span>                self.logger.debug(&quot;Excluded file after filtering: %s&quot;, relative_path)
<span class="line-number">731</span>
<span class="line-number">732</span>        self.logger.info(
<span class="line-number">733</span>            f&quot;Initial C files after filtering: {len(initial_c_files)} files&quot;
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
<span class="line-number">745</span>            self.logger.info(&quot;Processing include iteration %d&quot;, iteration + 1)
<span class="line-number">746</span>
<span class="line-number">747</span>            # Get the files that were in the list at the start of this iteration
<span class="line-number">748</span>            files_at_start_of_iteration = list(files_to_parse)
<span class="line-number">749</span>            self.logger.debug(
<span class="line-number">750</span>                f&quot;Files at start of iteration {iteration + 1}: {[f.name for f in files_at_start_of_iteration]}&quot;
<span class="line-number">751</span>            )
<span class="line-number">752</span>
<span class="line-number">753</span>            # Find all includes from files that were in the list at the start of this iteration
<span class="line-number">754</span>            new_includes = set()
<span class="line-number">755</span>            for file_path in files_at_start_of_iteration:
<span class="line-number">756</span>                # Extract includes from this file
<span class="line-number">757</span>                includes = self._extract_includes_from_file(file_path)
<span class="line-number">758</span>                self.logger.debug(&quot;Found includes in %s: %s&quot;, file_path.name, includes)
<span class="line-number">759</span>
<span class="line-number">760</span>                # Find the actual header files
<span class="line-number">761</span>                for include_name in includes:
<span class="line-number">762</span>                    included_file = self._find_included_file(
<span class="line-number">763</span>                        include_name, file_path, project_root
<span class="line-number">764</span>                    )
<span class="line-number">765</span>                    if included_file and included_file not in files_to_parse:
<span class="line-number">766</span>                        # Check if the included file should be included based on config
<span class="line-number">767</span>                        relative_included_path = str(
<span class="line-number">768</span>                            included_file.relative_to(project_root)
<span class="line-number">769</span>                        )
<span class="line-number">770</span>                        if self._should_include_file(relative_included_path, config):
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
<span class="line-number">782</span>                        )
<span class="line-number">783</span>                    else:
<span class="line-number">784</span>                        self.logger.debug(
<span class="line-number">785</span>                            f&quot;Could not find included file: {include_name}&quot;
<span class="line-number">786</span>                        )
<span class="line-number">787</span>
<span class="line-number">788</span>            # Add new includes to the parsing list
<span class="line-number">789</span>            files_to_parse.update(new_includes)
<span class="line-number">790</span>            self.logger.info(
<span class="line-number">791</span>                f&quot;Iteration {iteration + 1}: Added {len(new_includes)} new files&quot;
<span class="line-number">792</span>            )
<span class="line-number">793</span>
<span class="line-number">794</span>            # If no new files were found, we can stop early
<span class="line-number">795</span>            if not new_includes:
<span class="line-number">796</span>                self.logger.info(
<span class="line-number">797</span>                    f&quot;No new files found in iteration {iteration + 1}, stopping early&quot;
<span class="line-number">798</span>                )
<span class="line-number">799</span>                break
<span class="line-number">800</span>
<span class="line-number">801</span>        result = list(files_to_parse)
<span class="line-number">802</span>        self.logger.info(&quot;Final file list: %d files&quot;, len(result))
<span class="line-number">803</span>        self.logger.debug(&quot;Final files: %s&quot;, [f.name for f in result])
<span class="line-number">804</span>        return result
<span class="line-number">805</span>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _extract_tag_name_for_struct (lines 562-1493)</h4>
<pre>
<span class="line-number">562</span>    def _extract_tag_name_for_struct(self, tokens, struct_name: str) -&gt; str:
<span class="line-number">563</span>        &quot;&quot;&quot;Extract tag name for a struct if it has a typedef&quot;&quot;&quot;
<span class="line-number">564</span>        i = 0
<span class="line-number">565</span>        while i &lt; len(tokens):
<span class="line-number">566</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">567</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">568</span>                if typedef_info:
<span class="line-number">569</span>                    typedef_name, original_type = typedef_info
<span class="line-number">570</span>                    if original_type == &quot;struct&quot; and typedef_name == struct_name:
<span class="line-number">571</span>                        # Extract the tag name from the typedef
<span class="line-number">572</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">573</span>            i += 1
<span class="line-number">574</span>        return &quot;&quot;
<span class="line-number">575</span>
<span class="line-number">576</span>    def _extract_tag_name_for_enum(self, tokens, enum_name: str) -&gt; str:
<span class="line-number">577</span>        &quot;&quot;&quot;Extract tag name for an enum if it has a typedef&quot;&quot;&quot;
<span class="line-number">578</span>        i = 0
<span class="line-number">579</span>        while i &lt; len(tokens):
<span class="line-number">580</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">581</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">582</span>                if typedef_info:
<span class="line-number">583</span>                    typedef_name, original_type = typedef_info
<span class="line-number">584</span>                    if original_type == &quot;enum&quot; and typedef_name == enum_name:
<span class="line-number">585</span>                        # Extract the tag name from the typedef
<span class="line-number">586</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">587</span>            i += 1
<span class="line-number">588</span>        return &quot;&quot;
<span class="line-number">589</span>
<span class="line-number">590</span>    def _extract_tag_name_for_union(self, tokens, union_name: str) -&gt; str:
<span class="line-number">591</span>        &quot;&quot;&quot;Extract tag name for a union if it has a typedef&quot;&quot;&quot;
<span class="line-number">592</span>        i = 0
<span class="line-number">593</span>        while i &lt; len(tokens):
<span class="line-number">594</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">595</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">596</span>                if typedef_info:
<span class="line-number">597</span>                    typedef_name, original_type = typedef_info
<span class="line-number">598</span>                    if original_type == &quot;union&quot; and typedef_name == union_name:
<span class="line-number">599</span>                        # Extract the tag name from the typedef
<span class="line-number">600</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">601</span>            i += 1
<span class="line-number">602</span>        return &quot;&quot;
<span class="line-number">603</span>
<span class="line-number">604</span>    def _extract_non_primitive_types(
<span class="line-number">605</span>        self, type_str: str, available_types: Set[str]
<span class="line-number">606</span>    ) -&gt; List[str]:
<span class="line-number">607</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">608</span>        # Define primitive types
<span class="line-number">609</span><span class="uncovered">        primitive_types = {</span>
<span class="line-number">610</span>            &quot;void&quot;,
<span class="line-number">611</span>            &quot;char&quot;,
<span class="line-number">612</span>            &quot;short&quot;,
<span class="line-number">613</span>            &quot;int&quot;,
<span class="line-number">614</span>            &quot;long&quot;,
<span class="line-number">615</span>            &quot;float&quot;,
<span class="line-number">616</span>            &quot;double&quot;,
<span class="line-number">617</span>            &quot;signed&quot;,
<span class="line-number">618</span>            &quot;unsigned&quot;,
<span class="line-number">619</span>            &quot;const&quot;,
<span class="line-number">620</span>            &quot;volatile&quot;,
<span class="line-number">621</span>            &quot;static&quot;,
<span class="line-number">622</span>            &quot;extern&quot;,
<span class="line-number">623</span>            &quot;auto&quot;,
<span class="line-number">624</span>            &quot;register&quot;,
<span class="line-number">625</span>            &quot;inline&quot;,
<span class="line-number">626</span>            &quot;restrict&quot;,
<span class="line-number">627</span>            &quot;size_t&quot;,
<span class="line-number">628</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">629</span>            &quot;int8_t&quot;,
<span class="line-number">630</span>            &quot;int16_t&quot;,
<span class="line-number">631</span>            &quot;int32_t&quot;,
<span class="line-number">632</span>            &quot;int64_t&quot;,
<span class="line-number">633</span>            &quot;uint8_t&quot;,
<span class="line-number">634</span>            &quot;uint16_t&quot;,
<span class="line-number">635</span>            &quot;uint32_t&quot;,
<span class="line-number">636</span>            &quot;uint64_t&quot;,
<span class="line-number">637</span>            &quot;intptr_t&quot;,
<span class="line-number">638</span>            &quot;uintptr_t&quot;,
<span class="line-number">639</span>            &quot;bool&quot;,
<span class="line-number">640</span>            &quot;true&quot;,
<span class="line-number">641</span>            &quot;false&quot;,
<span class="line-number">642</span>            &quot;NULL&quot;,
<span class="line-number">643</span>            &quot;nullptr&quot;,
<span class="line-number">644</span>        }
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span><span class="uncovered">        import re</span>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span><span class="uncovered">        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)</span>
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span><span class="uncovered">        types = []</span>
<span class="line-number">654</span><span class="uncovered">        for part in parts:</span>
<span class="line-number">655</span><span class="uncovered">            part = part.strip()</span>
<span class="line-number">656</span><span class="uncovered">            if part and len(part) &gt; 1 and part not in primitive_types:</span>
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span><span class="uncovered">                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):</span>
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span><span class="uncovered">                    if part in available_types:</span>
<span class="line-number">661</span><span class="uncovered">                        types.append(part)</span>
<span class="line-number">662</span>
<span class="line-number">663</span><span class="uncovered">        return list(set(types))  # Remove duplicates</span>
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
<span class="line-number">669</span>
<span class="line-number">670</span>        self.logger.debug(&quot;Searching for files with extensions: %s&quot;, c_extensions)
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
<span class="line-number">696</span>
<span class="line-number">697</span>    def _find_files_with_include_dependencies(
<span class="line-number">698</span>        self, project_root: Path, recursive_search: bool, config: &quot;Config&quot;
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
<span class="line-number">710</span>        # Step 1: Find all C/C++ files in the project
<span class="line-number">711</span>        all_c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number">712</span>        self.logger.debug(&quot;All C files found: %s&quot;, [f.name for f in all_c_files])
<span class="line-number">713</span>
<span class="line-number">714</span>        # Step 2: Apply initial file filtering (include/exclude patterns) and separate .c and .h files
<span class="line-number">715</span>        initial_c_files = []  # Only .c files as starting files
<span class="line-number">716</span>        all_header_files = []  # All .h files for later include processing
<span class="line-number">717</span>
<span class="line-number">718</span>        for file_path in all_c_files:
<span class="line-number">719</span>            relative_path = str(file_path.relative_to(project_root))
<span class="line-number">720</span>            if self._should_include_file(relative_path, config):
<span class="line-number">721</span>                if file_path.suffix in [&quot;.c&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;]:
<span class="line-number">722</span>                    initial_c_files.append(file_path)
<span class="line-number">723</span>                    self.logger.debug(
<span class="line-number">724</span>                        f&quot;Included C file after filtering: {relative_path}&quot;
<span class="line-number">725</span>                    )
<span class="line-number">726</span>                else:
<span class="line-number">727</span>                    all_header_files.append(file_path)
<span class="line-number">728</span>                    self.logger.debug(&quot;Found header file: %s&quot;, relative_path)
<span class="line-number">729</span>            else:
<span class="line-number">730</span>                self.logger.debug(&quot;Excluded file after filtering: %s&quot;, relative_path)
<span class="line-number">731</span>
<span class="line-number">732</span>        self.logger.info(
<span class="line-number">733</span>            f&quot;Initial C files after filtering: {len(initial_c_files)} files&quot;
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
<span class="line-number">745</span>            self.logger.info(&quot;Processing include iteration %d&quot;, iteration + 1)
<span class="line-number">746</span>
<span class="line-number">747</span>            # Get the files that were in the list at the start of this iteration
<span class="line-number">748</span>            files_at_start_of_iteration = list(files_to_parse)
<span class="line-number">749</span>            self.logger.debug(
<span class="line-number">750</span>                f&quot;Files at start of iteration {iteration + 1}: {[f.name for f in files_at_start_of_iteration]}&quot;
<span class="line-number">751</span>            )
<span class="line-number">752</span>
<span class="line-number">753</span>            # Find all includes from files that were in the list at the start of this iteration
<span class="line-number">754</span>            new_includes = set()
<span class="line-number">755</span>            for file_path in files_at_start_of_iteration:
<span class="line-number">756</span>                # Extract includes from this file
<span class="line-number">757</span>                includes = self._extract_includes_from_file(file_path)
<span class="line-number">758</span>                self.logger.debug(&quot;Found includes in %s: %s&quot;, file_path.name, includes)
<span class="line-number">759</span>
<span class="line-number">760</span>                # Find the actual header files
<span class="line-number">761</span>                for include_name in includes:
<span class="line-number">762</span>                    included_file = self._find_included_file(
<span class="line-number">763</span>                        include_name, file_path, project_root
<span class="line-number">764</span>                    )
<span class="line-number">765</span>                    if included_file and included_file not in files_to_parse:
<span class="line-number">766</span>                        # Check if the included file should be included based on config
<span class="line-number">767</span>                        relative_included_path = str(
<span class="line-number">768</span>                            included_file.relative_to(project_root)
<span class="line-number">769</span>                        )
<span class="line-number">770</span>                        if self._should_include_file(relative_included_path, config):
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
<span class="line-number">782</span>                        )
<span class="line-number">783</span>                    else:
<span class="line-number">784</span>                        self.logger.debug(
<span class="line-number">785</span>                            f&quot;Could not find included file: {include_name}&quot;
<span class="line-number">786</span>                        )
<span class="line-number">787</span>
<span class="line-number">788</span>            # Add new includes to the parsing list
<span class="line-number">789</span>            files_to_parse.update(new_includes)
<span class="line-number">790</span>            self.logger.info(
<span class="line-number">791</span>                f&quot;Iteration {iteration + 1}: Added {len(new_includes)} new files&quot;
<span class="line-number">792</span>            )
<span class="line-number">793</span>
<span class="line-number">794</span>            # If no new files were found, we can stop early
<span class="line-number">795</span>            if not new_includes:
<span class="line-number">796</span>                self.logger.info(
<span class="line-number">797</span>                    f&quot;No new files found in iteration {iteration + 1}, stopping early&quot;
<span class="line-number">798</span>                )
<span class="line-number">799</span>                break
<span class="line-number">800</span>
<span class="line-number">801</span>        result = list(files_to_parse)
<span class="line-number">802</span>        self.logger.info(&quot;Final file list: %d files&quot;, len(result))
<span class="line-number">803</span>        self.logger.debug(&quot;Final files: %s&quot;, [f.name for f in result])
<span class="line-number">804</span>        return result
<span class="line-number">805</span>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _extract_tag_name_for_enum (lines 576-1493)</h4>
<pre>
<span class="line-number">576</span>    def _extract_tag_name_for_enum(self, tokens, enum_name: str) -&gt; str:
<span class="line-number">577</span>        &quot;&quot;&quot;Extract tag name for an enum if it has a typedef&quot;&quot;&quot;
<span class="line-number">578</span>        i = 0
<span class="line-number">579</span>        while i &lt; len(tokens):
<span class="line-number">580</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">581</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">582</span>                if typedef_info:
<span class="line-number">583</span>                    typedef_name, original_type = typedef_info
<span class="line-number">584</span>                    if original_type == &quot;enum&quot; and typedef_name == enum_name:
<span class="line-number">585</span>                        # Extract the tag name from the typedef
<span class="line-number">586</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">587</span>            i += 1
<span class="line-number">588</span>        return &quot;&quot;
<span class="line-number">589</span>
<span class="line-number">590</span>    def _extract_tag_name_for_union(self, tokens, union_name: str) -&gt; str:
<span class="line-number">591</span>        &quot;&quot;&quot;Extract tag name for a union if it has a typedef&quot;&quot;&quot;
<span class="line-number">592</span>        i = 0
<span class="line-number">593</span>        while i &lt; len(tokens):
<span class="line-number">594</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">595</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">596</span>                if typedef_info:
<span class="line-number">597</span>                    typedef_name, original_type = typedef_info
<span class="line-number">598</span>                    if original_type == &quot;union&quot; and typedef_name == union_name:
<span class="line-number">599</span>                        # Extract the tag name from the typedef
<span class="line-number">600</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">601</span>            i += 1
<span class="line-number">602</span>        return &quot;&quot;
<span class="line-number">603</span>
<span class="line-number">604</span>    def _extract_non_primitive_types(
<span class="line-number">605</span>        self, type_str: str, available_types: Set[str]
<span class="line-number">606</span>    ) -&gt; List[str]:
<span class="line-number">607</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">608</span>        # Define primitive types
<span class="line-number">609</span><span class="uncovered">        primitive_types = {</span>
<span class="line-number">610</span>            &quot;void&quot;,
<span class="line-number">611</span>            &quot;char&quot;,
<span class="line-number">612</span>            &quot;short&quot;,
<span class="line-number">613</span>            &quot;int&quot;,
<span class="line-number">614</span>            &quot;long&quot;,
<span class="line-number">615</span>            &quot;float&quot;,
<span class="line-number">616</span>            &quot;double&quot;,
<span class="line-number">617</span>            &quot;signed&quot;,
<span class="line-number">618</span>            &quot;unsigned&quot;,
<span class="line-number">619</span>            &quot;const&quot;,
<span class="line-number">620</span>            &quot;volatile&quot;,
<span class="line-number">621</span>            &quot;static&quot;,
<span class="line-number">622</span>            &quot;extern&quot;,
<span class="line-number">623</span>            &quot;auto&quot;,
<span class="line-number">624</span>            &quot;register&quot;,
<span class="line-number">625</span>            &quot;inline&quot;,
<span class="line-number">626</span>            &quot;restrict&quot;,
<span class="line-number">627</span>            &quot;size_t&quot;,
<span class="line-number">628</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">629</span>            &quot;int8_t&quot;,
<span class="line-number">630</span>            &quot;int16_t&quot;,
<span class="line-number">631</span>            &quot;int32_t&quot;,
<span class="line-number">632</span>            &quot;int64_t&quot;,
<span class="line-number">633</span>            &quot;uint8_t&quot;,
<span class="line-number">634</span>            &quot;uint16_t&quot;,
<span class="line-number">635</span>            &quot;uint32_t&quot;,
<span class="line-number">636</span>            &quot;uint64_t&quot;,
<span class="line-number">637</span>            &quot;intptr_t&quot;,
<span class="line-number">638</span>            &quot;uintptr_t&quot;,
<span class="line-number">639</span>            &quot;bool&quot;,
<span class="line-number">640</span>            &quot;true&quot;,
<span class="line-number">641</span>            &quot;false&quot;,
<span class="line-number">642</span>            &quot;NULL&quot;,
<span class="line-number">643</span>            &quot;nullptr&quot;,
<span class="line-number">644</span>        }
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span><span class="uncovered">        import re</span>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span><span class="uncovered">        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)</span>
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span><span class="uncovered">        types = []</span>
<span class="line-number">654</span><span class="uncovered">        for part in parts:</span>
<span class="line-number">655</span><span class="uncovered">            part = part.strip()</span>
<span class="line-number">656</span><span class="uncovered">            if part and len(part) &gt; 1 and part not in primitive_types:</span>
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span><span class="uncovered">                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):</span>
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span><span class="uncovered">                    if part in available_types:</span>
<span class="line-number">661</span><span class="uncovered">                        types.append(part)</span>
<span class="line-number">662</span>
<span class="line-number">663</span><span class="uncovered">        return list(set(types))  # Remove duplicates</span>
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
<span class="line-number">669</span>
<span class="line-number">670</span>        self.logger.debug(&quot;Searching for files with extensions: %s&quot;, c_extensions)
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
<span class="line-number">696</span>
<span class="line-number">697</span>    def _find_files_with_include_dependencies(
<span class="line-number">698</span>        self, project_root: Path, recursive_search: bool, config: &quot;Config&quot;
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
<span class="line-number">710</span>        # Step 1: Find all C/C++ files in the project
<span class="line-number">711</span>        all_c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number">712</span>        self.logger.debug(&quot;All C files found: %s&quot;, [f.name for f in all_c_files])
<span class="line-number">713</span>
<span class="line-number">714</span>        # Step 2: Apply initial file filtering (include/exclude patterns) and separate .c and .h files
<span class="line-number">715</span>        initial_c_files = []  # Only .c files as starting files
<span class="line-number">716</span>        all_header_files = []  # All .h files for later include processing
<span class="line-number">717</span>
<span class="line-number">718</span>        for file_path in all_c_files:
<span class="line-number">719</span>            relative_path = str(file_path.relative_to(project_root))
<span class="line-number">720</span>            if self._should_include_file(relative_path, config):
<span class="line-number">721</span>                if file_path.suffix in [&quot;.c&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;]:
<span class="line-number">722</span>                    initial_c_files.append(file_path)
<span class="line-number">723</span>                    self.logger.debug(
<span class="line-number">724</span>                        f&quot;Included C file after filtering: {relative_path}&quot;
<span class="line-number">725</span>                    )
<span class="line-number">726</span>                else:
<span class="line-number">727</span>                    all_header_files.append(file_path)
<span class="line-number">728</span>                    self.logger.debug(&quot;Found header file: %s&quot;, relative_path)
<span class="line-number">729</span>            else:
<span class="line-number">730</span>                self.logger.debug(&quot;Excluded file after filtering: %s&quot;, relative_path)
<span class="line-number">731</span>
<span class="line-number">732</span>        self.logger.info(
<span class="line-number">733</span>            f&quot;Initial C files after filtering: {len(initial_c_files)} files&quot;
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
<span class="line-number">745</span>            self.logger.info(&quot;Processing include iteration %d&quot;, iteration + 1)
<span class="line-number">746</span>
<span class="line-number">747</span>            # Get the files that were in the list at the start of this iteration
<span class="line-number">748</span>            files_at_start_of_iteration = list(files_to_parse)
<span class="line-number">749</span>            self.logger.debug(
<span class="line-number">750</span>                f&quot;Files at start of iteration {iteration + 1}: {[f.name for f in files_at_start_of_iteration]}&quot;
<span class="line-number">751</span>            )
<span class="line-number">752</span>
<span class="line-number">753</span>            # Find all includes from files that were in the list at the start of this iteration
<span class="line-number">754</span>            new_includes = set()
<span class="line-number">755</span>            for file_path in files_at_start_of_iteration:
<span class="line-number">756</span>                # Extract includes from this file
<span class="line-number">757</span>                includes = self._extract_includes_from_file(file_path)
<span class="line-number">758</span>                self.logger.debug(&quot;Found includes in %s: %s&quot;, file_path.name, includes)
<span class="line-number">759</span>
<span class="line-number">760</span>                # Find the actual header files
<span class="line-number">761</span>                for include_name in includes:
<span class="line-number">762</span>                    included_file = self._find_included_file(
<span class="line-number">763</span>                        include_name, file_path, project_root
<span class="line-number">764</span>                    )
<span class="line-number">765</span>                    if included_file and included_file not in files_to_parse:
<span class="line-number">766</span>                        # Check if the included file should be included based on config
<span class="line-number">767</span>                        relative_included_path = str(
<span class="line-number">768</span>                            included_file.relative_to(project_root)
<span class="line-number">769</span>                        )
<span class="line-number">770</span>                        if self._should_include_file(relative_included_path, config):
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
<span class="line-number">782</span>                        )
<span class="line-number">783</span>                    else:
<span class="line-number">784</span>                        self.logger.debug(
<span class="line-number">785</span>                            f&quot;Could not find included file: {include_name}&quot;
<span class="line-number">786</span>                        )
<span class="line-number">787</span>
<span class="line-number">788</span>            # Add new includes to the parsing list
<span class="line-number">789</span>            files_to_parse.update(new_includes)
<span class="line-number">790</span>            self.logger.info(
<span class="line-number">791</span>                f&quot;Iteration {iteration + 1}: Added {len(new_includes)} new files&quot;
<span class="line-number">792</span>            )
<span class="line-number">793</span>
<span class="line-number">794</span>            # If no new files were found, we can stop early
<span class="line-number">795</span>            if not new_includes:
<span class="line-number">796</span>                self.logger.info(
<span class="line-number">797</span>                    f&quot;No new files found in iteration {iteration + 1}, stopping early&quot;
<span class="line-number">798</span>                )
<span class="line-number">799</span>                break
<span class="line-number">800</span>
<span class="line-number">801</span>        result = list(files_to_parse)
<span class="line-number">802</span>        self.logger.info(&quot;Final file list: %d files&quot;, len(result))
<span class="line-number">803</span>        self.logger.debug(&quot;Final files: %s&quot;, [f.name for f in result])
<span class="line-number">804</span>        return result
<span class="line-number">805</span>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _extract_tag_name_for_union (lines 590-1493)</h4>
<pre>
<span class="line-number">590</span>    def _extract_tag_name_for_union(self, tokens, union_name: str) -&gt; str:
<span class="line-number">591</span>        &quot;&quot;&quot;Extract tag name for a union if it has a typedef&quot;&quot;&quot;
<span class="line-number">592</span>        i = 0
<span class="line-number">593</span>        while i &lt; len(tokens):
<span class="line-number">594</span>            if tokens[i].type == TokenType.TYPEDEF:
<span class="line-number">595</span>                typedef_info = self._parse_single_typedef(tokens, i)
<span class="line-number">596</span>                if typedef_info:
<span class="line-number">597</span>                    typedef_name, original_type = typedef_info
<span class="line-number">598</span>                    if original_type == &quot;union&quot; and typedef_name == union_name:
<span class="line-number">599</span>                        # Extract the tag name from the typedef
<span class="line-number">600</span>                        return self._extract_tag_name_from_typedef(tokens, i)
<span class="line-number">601</span>            i += 1
<span class="line-number">602</span>        return &quot;&quot;
<span class="line-number">603</span>
<span class="line-number">604</span>    def _extract_non_primitive_types(
<span class="line-number">605</span>        self, type_str: str, available_types: Set[str]
<span class="line-number">606</span>    ) -&gt; List[str]:
<span class="line-number">607</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">608</span>        # Define primitive types
<span class="line-number">609</span><span class="uncovered">        primitive_types = {</span>
<span class="line-number">610</span>            &quot;void&quot;,
<span class="line-number">611</span>            &quot;char&quot;,
<span class="line-number">612</span>            &quot;short&quot;,
<span class="line-number">613</span>            &quot;int&quot;,
<span class="line-number">614</span>            &quot;long&quot;,
<span class="line-number">615</span>            &quot;float&quot;,
<span class="line-number">616</span>            &quot;double&quot;,
<span class="line-number">617</span>            &quot;signed&quot;,
<span class="line-number">618</span>            &quot;unsigned&quot;,
<span class="line-number">619</span>            &quot;const&quot;,
<span class="line-number">620</span>            &quot;volatile&quot;,
<span class="line-number">621</span>            &quot;static&quot;,
<span class="line-number">622</span>            &quot;extern&quot;,
<span class="line-number">623</span>            &quot;auto&quot;,
<span class="line-number">624</span>            &quot;register&quot;,
<span class="line-number">625</span>            &quot;inline&quot;,
<span class="line-number">626</span>            &quot;restrict&quot;,
<span class="line-number">627</span>            &quot;size_t&quot;,
<span class="line-number">628</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">629</span>            &quot;int8_t&quot;,
<span class="line-number">630</span>            &quot;int16_t&quot;,
<span class="line-number">631</span>            &quot;int32_t&quot;,
<span class="line-number">632</span>            &quot;int64_t&quot;,
<span class="line-number">633</span>            &quot;uint8_t&quot;,
<span class="line-number">634</span>            &quot;uint16_t&quot;,
<span class="line-number">635</span>            &quot;uint32_t&quot;,
<span class="line-number">636</span>            &quot;uint64_t&quot;,
<span class="line-number">637</span>            &quot;intptr_t&quot;,
<span class="line-number">638</span>            &quot;uintptr_t&quot;,
<span class="line-number">639</span>            &quot;bool&quot;,
<span class="line-number">640</span>            &quot;true&quot;,
<span class="line-number">641</span>            &quot;false&quot;,
<span class="line-number">642</span>            &quot;NULL&quot;,
<span class="line-number">643</span>            &quot;nullptr&quot;,
<span class="line-number">644</span>        }
<span class="line-number">645</span>
<span class="line-number">646</span>        # Remove common C keywords and operators
<span class="line-number">647</span><span class="uncovered">        import re</span>
<span class="line-number">648</span>
<span class="line-number">649</span>        # Split by common delimiters and operators
<span class="line-number">650</span><span class="uncovered">        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)</span>
<span class="line-number">651</span>
<span class="line-number">652</span>        # Extract potential type names that exist in available_types
<span class="line-number">653</span><span class="uncovered">        types = []</span>
<span class="line-number">654</span><span class="uncovered">        for part in parts:</span>
<span class="line-number">655</span><span class="uncovered">            part = part.strip()</span>
<span class="line-number">656</span><span class="uncovered">            if part and len(part) &gt; 1 and part not in primitive_types:</span>
<span class="line-number">657</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">658</span><span class="uncovered">                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):</span>
<span class="line-number">659</span>                    # Only include if it exists in available_types
<span class="line-number">660</span><span class="uncovered">                    if part in available_types:</span>
<span class="line-number">661</span><span class="uncovered">                        types.append(part)</span>
<span class="line-number">662</span>
<span class="line-number">663</span><span class="uncovered">        return list(set(types))  # Remove duplicates</span>
<span class="line-number">664</span>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
<span class="line-number">669</span>
<span class="line-number">670</span>        self.logger.debug(&quot;Searching for files with extensions: %s&quot;, c_extensions)
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
<span class="line-number">696</span>
<span class="line-number">697</span>    def _find_files_with_include_dependencies(
<span class="line-number">698</span>        self, project_root: Path, recursive_search: bool, config: &quot;Config&quot;
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
<span class="line-number">710</span>        # Step 1: Find all C/C++ files in the project
<span class="line-number">711</span>        all_c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number">712</span>        self.logger.debug(&quot;All C files found: %s&quot;, [f.name for f in all_c_files])
<span class="line-number">713</span>
<span class="line-number">714</span>        # Step 2: Apply initial file filtering (include/exclude patterns) and separate .c and .h files
<span class="line-number">715</span>        initial_c_files = []  # Only .c files as starting files
<span class="line-number">716</span>        all_header_files = []  # All .h files for later include processing
<span class="line-number">717</span>
<span class="line-number">718</span>        for file_path in all_c_files:
<span class="line-number">719</span>            relative_path = str(file_path.relative_to(project_root))
<span class="line-number">720</span>            if self._should_include_file(relative_path, config):
<span class="line-number">721</span>                if file_path.suffix in [&quot;.c&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;]:
<span class="line-number">722</span>                    initial_c_files.append(file_path)
<span class="line-number">723</span>                    self.logger.debug(
<span class="line-number">724</span>                        f&quot;Included C file after filtering: {relative_path}&quot;
<span class="line-number">725</span>                    )
<span class="line-number">726</span>                else:
<span class="line-number">727</span>                    all_header_files.append(file_path)
<span class="line-number">728</span>                    self.logger.debug(&quot;Found header file: %s&quot;, relative_path)
<span class="line-number">729</span>            else:
<span class="line-number">730</span>                self.logger.debug(&quot;Excluded file after filtering: %s&quot;, relative_path)
<span class="line-number">731</span>
<span class="line-number">732</span>        self.logger.info(
<span class="line-number">733</span>            f&quot;Initial C files after filtering: {len(initial_c_files)} files&quot;
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
<span class="line-number">745</span>            self.logger.info(&quot;Processing include iteration %d&quot;, iteration + 1)
<span class="line-number">746</span>
<span class="line-number">747</span>            # Get the files that were in the list at the start of this iteration
<span class="line-number">748</span>            files_at_start_of_iteration = list(files_to_parse)
<span class="line-number">749</span>            self.logger.debug(
<span class="line-number">750</span>                f&quot;Files at start of iteration {iteration + 1}: {[f.name for f in files_at_start_of_iteration]}&quot;
<span class="line-number">751</span>            )
<span class="line-number">752</span>
<span class="line-number">753</span>            # Find all includes from files that were in the list at the start of this iteration
<span class="line-number">754</span>            new_includes = set()
<span class="line-number">755</span>            for file_path in files_at_start_of_iteration:
<span class="line-number">756</span>                # Extract includes from this file
<span class="line-number">757</span>                includes = self._extract_includes_from_file(file_path)
<span class="line-number">758</span>                self.logger.debug(&quot;Found includes in %s: %s&quot;, file_path.name, includes)
<span class="line-number">759</span>
<span class="line-number">760</span>                # Find the actual header files
<span class="line-number">761</span>                for include_name in includes:
<span class="line-number">762</span>                    included_file = self._find_included_file(
<span class="line-number">763</span>                        include_name, file_path, project_root
<span class="line-number">764</span>                    )
<span class="line-number">765</span>                    if included_file and included_file not in files_to_parse:
<span class="line-number">766</span>                        # Check if the included file should be included based on config
<span class="line-number">767</span>                        relative_included_path = str(
<span class="line-number">768</span>                            included_file.relative_to(project_root)
<span class="line-number">769</span>                        )
<span class="line-number">770</span>                        if self._should_include_file(relative_included_path, config):
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
<span class="line-number">782</span>                        )
<span class="line-number">783</span>                    else:
<span class="line-number">784</span>                        self.logger.debug(
<span class="line-number">785</span>                            f&quot;Could not find included file: {include_name}&quot;
<span class="line-number">786</span>                        )
<span class="line-number">787</span>
<span class="line-number">788</span>            # Add new includes to the parsing list
<span class="line-number">789</span>            files_to_parse.update(new_includes)
<span class="line-number">790</span>            self.logger.info(
<span class="line-number">791</span>                f&quot;Iteration {iteration + 1}: Added {len(new_includes)} new files&quot;
<span class="line-number">792</span>            )
<span class="line-number">793</span>
<span class="line-number">794</span>            # If no new files were found, we can stop early
<span class="line-number">795</span>            if not new_includes:
<span class="line-number">796</span>                self.logger.info(
<span class="line-number">797</span>                    f&quot;No new files found in iteration {iteration + 1}, stopping early&quot;
<span class="line-number">798</span>                )
<span class="line-number">799</span>                break
<span class="line-number">800</span>
<span class="line-number">801</span>        result = list(files_to_parse)
<span class="line-number">802</span>        self.logger.info(&quot;Final file list: %d files&quot;, len(result))
<span class="line-number">803</span>        self.logger.debug(&quot;Final files: %s&quot;, [f.name for f in result])
<span class="line-number">804</span>        return result
<span class="line-number">805</span>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _find_c_files (lines 665-1493)</h4>
<pre>
<span class="line-number">665</span>    def _find_c_files(self, project_root: Path, recursive_search: bool) -&gt; List[Path]:
<span class="line-number">666</span>        &quot;&quot;&quot;Find all C/C++ files in the project&quot;&quot;&quot;
<span class="line-number">667</span>        c_extensions = {&quot;.c&quot;, &quot;.h&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;, &quot;.hpp&quot;, &quot;.hxx&quot;}
<span class="line-number">668</span>        files = []
<span class="line-number">669</span>
<span class="line-number">670</span>        self.logger.debug(&quot;Searching for files with extensions: %s&quot;, c_extensions)
<span class="line-number">671</span>
<span class="line-number">672</span>        if recursive_search:
<span class="line-number">673</span>            for ext in c_extensions:
<span class="line-number">674</span>                files.extend(project_root.rglob(f&quot;*{ext}&quot;))
<span class="line-number">675</span>        else:
<span class="line-number">676</span><span class="uncovered">            for ext in c_extensions:</span>
<span class="line-number">677</span><span class="uncovered">                files.extend(project_root.glob(f&quot;*{ext}&quot;))</span>
<span class="line-number">678</span>
<span class="line-number">679</span>        # Filter out hidden files and common exclude patterns
<span class="line-number">680</span>        filtered_files = []
<span class="line-number">681</span>        exclude_patterns = {&quot;.git&quot;, &quot;__pycache__&quot;, &quot;node_modules&quot;, &quot;.vscode&quot;, &quot;.idea&quot;}
<span class="line-number">682</span>
<span class="line-number">683</span>        for file_path in files:
<span class="line-number">684</span>            # Skip hidden files and directories
<span class="line-number">685</span>            if any(part.startswith(&quot;.&quot;) for part in file_path.parts):
<span class="line-number">686</span><span class="uncovered">                continue</span>
<span class="line-number">687</span>
<span class="line-number">688</span>            # Skip common exclude patterns
<span class="line-number">689</span>            if any(pattern in file_path.parts for pattern in exclude_patterns):
<span class="line-number">690</span><span class="uncovered">                continue</span>
<span class="line-number">691</span>
<span class="line-number">692</span>            filtered_files.append(file_path)
<span class="line-number">693</span>
<span class="line-number">694</span>        self.logger.debug(&quot;Found %d C/C++ files after filtering&quot;, len(filtered_files))
<span class="line-number">695</span>        return sorted(filtered_files)
<span class="line-number">696</span>
<span class="line-number">697</span>    def _find_files_with_include_dependencies(
<span class="line-number">698</span>        self, project_root: Path, recursive_search: bool, config: &quot;Config&quot;
<span class="line-number">699</span>    ) -&gt; List[Path]:
<span class="line-number">700</span>        &quot;&quot;&quot;Find C/C++ files based on configuration and include dependencies&quot;&quot;&quot;
<span class="line-number">701</span>
<span class="line-number">702</span>        # If no config provided, fall back to old behavior
<span class="line-number">703</span>        if config is None:
<span class="line-number">704</span><span class="uncovered">            return self._find_c_files(project_root, recursive_search)</span>
<span class="line-number">705</span>
<span class="line-number">706</span>        # Get include depth from config
<span class="line-number">707</span>        include_depth = getattr(config, &quot;include_depth&quot;, 1)
<span class="line-number">708</span>        self.logger.info(&quot;Using include depth: %d&quot;, include_depth)
<span class="line-number">709</span>
<span class="line-number">710</span>        # Step 1: Find all C/C++ files in the project
<span class="line-number">711</span>        all_c_files = self._find_c_files(project_root, recursive_search)
<span class="line-number">712</span>        self.logger.debug(&quot;All C files found: %s&quot;, [f.name for f in all_c_files])
<span class="line-number">713</span>
<span class="line-number">714</span>        # Step 2: Apply initial file filtering (include/exclude patterns) and separate .c and .h files
<span class="line-number">715</span>        initial_c_files = []  # Only .c files as starting files
<span class="line-number">716</span>        all_header_files = []  # All .h files for later include processing
<span class="line-number">717</span>
<span class="line-number">718</span>        for file_path in all_c_files:
<span class="line-number">719</span>            relative_path = str(file_path.relative_to(project_root))
<span class="line-number">720</span>            if self._should_include_file(relative_path, config):
<span class="line-number">721</span>                if file_path.suffix in [&quot;.c&quot;, &quot;.cpp&quot;, &quot;.cc&quot;, &quot;.cxx&quot;]:
<span class="line-number">722</span>                    initial_c_files.append(file_path)
<span class="line-number">723</span>                    self.logger.debug(
<span class="line-number">724</span>                        f&quot;Included C file after filtering: {relative_path}&quot;
<span class="line-number">725</span>                    )
<span class="line-number">726</span>                else:
<span class="line-number">727</span>                    all_header_files.append(file_path)
<span class="line-number">728</span>                    self.logger.debug(&quot;Found header file: %s&quot;, relative_path)
<span class="line-number">729</span>            else:
<span class="line-number">730</span>                self.logger.debug(&quot;Excluded file after filtering: %s&quot;, relative_path)
<span class="line-number">731</span>
<span class="line-number">732</span>        self.logger.info(
<span class="line-number">733</span>            f&quot;Initial C files after filtering: {len(initial_c_files)} files&quot;
<span class="line-number">734</span>        )
<span class="line-number">735</span>        self.logger.debug(&quot;Initial C files: %s&quot;, [f.name for f in initial_c_files])
<span class="line-number">736</span>
<span class="line-number">737</span>        # Step 3: If include_depth is 0, return only the initially filtered C files
<span class="line-number">738</span>        if include_depth == 0:
<span class="line-number">739</span><span class="uncovered">            return initial_c_files</span>
<span class="line-number">740</span>
<span class="line-number">741</span>        # Step 4: Process include dependencies for N iterations
<span class="line-number">742</span>        files_to_parse = set(initial_c_files)
<span class="line-number">743</span>
<span class="line-number">744</span>        for iteration in range(include_depth):
<span class="line-number">745</span>            self.logger.info(&quot;Processing include iteration %d&quot;, iteration + 1)
<span class="line-number">746</span>
<span class="line-number">747</span>            # Get the files that were in the list at the start of this iteration
<span class="line-number">748</span>            files_at_start_of_iteration = list(files_to_parse)
<span class="line-number">749</span>            self.logger.debug(
<span class="line-number">750</span>                f&quot;Files at start of iteration {iteration + 1}: {[f.name for f in files_at_start_of_iteration]}&quot;
<span class="line-number">751</span>            )
<span class="line-number">752</span>
<span class="line-number">753</span>            # Find all includes from files that were in the list at the start of this iteration
<span class="line-number">754</span>            new_includes = set()
<span class="line-number">755</span>            for file_path in files_at_start_of_iteration:
<span class="line-number">756</span>                # Extract includes from this file
<span class="line-number">757</span>                includes = self._extract_includes_from_file(file_path)
<span class="line-number">758</span>                self.logger.debug(&quot;Found includes in %s: %s&quot;, file_path.name, includes)
<span class="line-number">759</span>
<span class="line-number">760</span>                # Find the actual header files
<span class="line-number">761</span>                for include_name in includes:
<span class="line-number">762</span>                    included_file = self._find_included_file(
<span class="line-number">763</span>                        include_name, file_path, project_root
<span class="line-number">764</span>                    )
<span class="line-number">765</span>                    if included_file and included_file not in files_to_parse:
<span class="line-number">766</span>                        # Check if the included file should be included based on config
<span class="line-number">767</span>                        relative_included_path = str(
<span class="line-number">768</span>                            included_file.relative_to(project_root)
<span class="line-number">769</span>                        )
<span class="line-number">770</span>                        if self._should_include_file(relative_included_path, config):
<span class="line-number">771</span>                            new_includes.add(included_file)
<span class="line-number">772</span>                            self.logger.debug(
<span class="line-number">773</span>                                f&quot;Added included file in iteration {iteration + 1}: {relative_included_path}&quot;
<span class="line-number">774</span>                            )
<span class="line-number">775</span>                        else:
<span class="line-number">776</span><span class="uncovered">                            self.logger.debug(</span>
<span class="line-number">777</span>                                f&quot;Excluded included file due to config: {relative_included_path}&quot;
<span class="line-number">778</span>                            )
<span class="line-number">779</span>                    elif included_file:
<span class="line-number">780</span>                        self.logger.debug(
<span class="line-number">781</span>                            f&quot;Included file already in list: {included_file.name}&quot;
<span class="line-number">782</span>                        )
<span class="line-number">783</span>                    else:
<span class="line-number">784</span>                        self.logger.debug(
<span class="line-number">785</span>                            f&quot;Could not find included file: {include_name}&quot;
<span class="line-number">786</span>                        )
<span class="line-number">787</span>
<span class="line-number">788</span>            # Add new includes to the parsing list
<span class="line-number">789</span>            files_to_parse.update(new_includes)
<span class="line-number">790</span>            self.logger.info(
<span class="line-number">791</span>                f&quot;Iteration {iteration + 1}: Added {len(new_includes)} new files&quot;
<span class="line-number">792</span>            )
<span class="line-number">793</span>
<span class="line-number">794</span>            # If no new files were found, we can stop early
<span class="line-number">795</span>            if not new_includes:
<span class="line-number">796</span>                self.logger.info(
<span class="line-number">797</span>                    f&quot;No new files found in iteration {iteration + 1}, stopping early&quot;
<span class="line-number">798</span>                )
<span class="line-number">799</span>                break
<span class="line-number">800</span>
<span class="line-number">801</span>        result = list(files_to_parse)
<span class="line-number">802</span>        self.logger.info(&quot;Final file list: %d files&quot;, len(result))
<span class="line-number">803</span>        self.logger.debug(&quot;Final files: %s&quot;, [f.name for f in result])
<span class="line-number">804</span>        return result
<span class="line-number">805</span>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _should_include_file (lines 806-1493)</h4>
<pre>
<span class="line-number">806</span>    def _should_include_file(self, relative_path: str, config: &quot;Config&quot;) -&gt; bool:
<span class="line-number">807</span>        &quot;&quot;&quot;Check if a file should be included based on configuration filters&quot;&quot;&quot;
<span class="line-number">808</span>        # Use the Config class&#x27;s _should_include_file method which properly handles regex patterns
<span class="line-number">809</span>        return config._should_include_file(relative_path)
<span class="line-number">810</span>
<span class="line-number">811</span>    def _find_included_file(
<span class="line-number">812</span>        self, include_name: str, source_file: Path, project_root: Path
<span class="line-number">813</span>    ) -&gt; Optional[Path]:
<span class="line-number">814</span>        &quot;&quot;&quot;Find the actual file path for an include statement&quot;&quot;&quot;
<span class="line-number">815</span>        # Remove quotes and angle brackets
<span class="line-number">816</span>        include_name = include_name.strip(&#x27;&quot;&lt;&gt;&#x27;)
<span class="line-number">817</span>
<span class="line-number">818</span>        # Check if this include has already been searched and failed
<span class="line-number">819</span>        cache_key = f&quot;{include_name}:{project_root}&quot;
<span class="line-number">820</span>        if cache_key in self._failed_includes_cache:
<span class="line-number">821</span>            self.logger.debug(
<span class="line-number">822</span>                f&quot;Include &#x27;{include_name}&#x27; already known to be not found (cached)&quot;
<span class="line-number">823</span>            )
<span class="line-number">824</span>            return None
<span class="line-number">825</span>
<span class="line-number">826</span>        # Try to find the file relative to the source file&#x27;s directory
<span class="line-number">827</span>        source_dir = source_file.parent
<span class="line-number">828</span>        possible_paths = [
<span class="line-number">829</span>            source_dir / include_name,
<span class="line-number">830</span>            source_dir / f&quot;{include_name}.h&quot;,
<span class="line-number">831</span>            source_dir / f&quot;{include_name}.hpp&quot;,
<span class="line-number">832</span>        ]
<span class="line-number">833</span>
<span class="line-number">834</span>        for path in possible_paths:
<span class="line-number">835</span>            if path.exists() and path.is_file():
<span class="line-number">836</span>                return path
<span class="line-number">837</span>
<span class="line-number">838</span>        # Try to find the file in subdirectories of the project root
<span class="line-number">839</span>        if project_root:
<span class="line-number">840</span>            for ext in [&quot;.h&quot;, &quot;.hpp&quot;, &quot;.c&quot;, &quot;.cpp&quot;]:
<span class="line-number">841</span>                full_name = (
<span class="line-number">842</span>                    include_name
<span class="line-number">843</span>                    if include_name.endswith(ext)
<span class="line-number">844</span>                    else f&quot;{include_name}{ext}&quot;
<span class="line-number">845</span>                )
<span class="line-number">846</span>                # Search recursively in project root
<span class="line-number">847</span>                for found_file in project_root.rglob(full_name):
<span class="line-number">848</span><span class="uncovered">                    if found_file.is_file():</span>
<span class="line-number">849</span>                        # For backward compatibility with tests, return full path if it&#x27;s a test
<span class="line-number">850</span>                        # Otherwise return filename for simplified tracking
<span class="line-number">851</span><span class="uncovered">                        if &quot;tmp&quot; in str(found_file):</span>
<span class="line-number">852</span><span class="uncovered">                            return found_file</span>
<span class="line-number">853</span>                        else:
<span class="line-number">854</span><span class="uncovered">                            return found_file</span>
<span class="line-number">855</span>
<span class="line-number">856</span>        # If we get here, the file was not found - cache this result
<span class="line-number">857</span>        self._failed_includes_cache.add(cache_key)
<span class="line-number">858</span>        self.logger.debug(&quot;Cached failed include search for &#x27;%s&#x27;&quot;, include_name)
<span class="line-number">859</span>        return None
<span class="line-number">860</span>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _extract_includes_from_file (lines 861-1493)</h4>
<pre>
<span class="line-number">861</span>    def _extract_includes_from_file(self, file_path: Path) -&gt; List[str]:
<span class="line-number">862</span>        &quot;&quot;&quot;Extract include statements from a file without full parsing&quot;&quot;&quot;
<span class="line-number">863</span>        try:
<span class="line-number">864</span>            encoding = self._detect_encoding(file_path)
<span class="line-number">865</span>            with open(file_path, &quot;r&quot;, encoding=encoding) as f:
<span class="line-number">866</span>                content = f.read()
<span class="line-number">867</span>
<span class="line-number">868</span>            # Tokenize and extract includes
<span class="line-number">869</span>            tokens = self.tokenizer.tokenize(content)
<span class="line-number">870</span>            return self._parse_includes_with_tokenizer(tokens)
<span class="line-number">871</span>
<span class="line-number">872</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">873</span><span class="uncovered">            self.logger.warning(&quot;Failed to extract includes from %s: %s&quot;, file_path, e)</span>
<span class="line-number">874</span><span class="uncovered">            return []</span>
<span class="line-number">875</span>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _detect_encoding (lines 876-1493)</h4>
<pre>
<span class="line-number">876</span>    def _detect_encoding(self, file_path: Path) -&gt; str:
<span class="line-number">877</span>        &quot;&quot;&quot;Detect file encoding with platform-aware fallbacks&quot;&quot;&quot;
<span class="line-number">878</span>        return detect_file_encoding(file_path)
<span class="line-number">879</span>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _find_original_token_pos (lines 880-1493)</h4>
<pre>
<span class="line-number">880</span>    def _find_original_token_pos(self, all_tokens, filtered_tokens, filtered_pos):
<span class="line-number">881</span>        &quot;&quot;&quot;Find the position in all_tokens that corresponds to filtered_tokens[filtered_pos]&quot;&quot;&quot;
<span class="line-number">882</span>        if filtered_pos &gt;= len(filtered_tokens):
<span class="line-number">883</span>            return None
<span class="line-number">884</span>
<span class="line-number">885</span>        target_token = filtered_tokens[filtered_pos]
<span class="line-number">886</span>
<span class="line-number">887</span>        # Search for the token in all_tokens by line and column
<span class="line-number">888</span>        for i, token in enumerate(all_tokens):
<span class="line-number">889</span>            if (
<span class="line-number">890</span>                token.line == target_token.line
<span class="line-number">891</span>                and token.column == target_token.column
<span class="line-number">892</span>                and token.value == target_token.value
<span class="line-number">893</span>            ):
<span class="line-number">894</span>                return i
<span class="line-number">895</span>
<span class="line-number">896</span><span class="uncovered">        return None</span>
<span class="line-number">897</span>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _parse_single_typedef (lines 898-1493)</h4>
<pre>
<span class="line-number">898</span>    def _parse_single_typedef(self, tokens, start_pos):
<span class="line-number">899</span>        &quot;&quot;&quot;Parse a single typedef starting at the given position&quot;&quot;&quot;
<span class="line-number">900</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">901</span>        pos = start_pos + 1
<span class="line-number">902</span>
<span class="line-number">903</span>        # Skip whitespace and comments
<span class="line-number">904</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">905</span>            TokenType.WHITESPACE,
<span class="line-number">906</span>            TokenType.COMMENT,
<span class="line-number">907</span>        ]:
<span class="line-number">908</span>            pos += 1
<span class="line-number">909</span>
<span class="line-number">910</span>        if pos &gt;= len(tokens):
<span class="line-number">911</span><span class="uncovered">            return None</span>
<span class="line-number">912</span>
<span class="line-number">913</span>        # Check if it&#x27;s a struct/enum/union typedef (we&#x27;ll handle these separately)
<span class="line-number">914</span>        if tokens[pos].type in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">915</span>            return self._parse_complex_typedef(tokens, pos)
<span class="line-number">916</span>
<span class="line-number">917</span>        # Collect all non-whitespace/comment tokens until semicolon
<span class="line-number">918</span>        all_tokens = []
<span class="line-number">919</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.SEMICOLON:
<span class="line-number">920</span>            if tokens[pos].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">921</span>                all_tokens.append(tokens[pos])
<span class="line-number">922</span>            pos += 1
<span class="line-number">923</span>
<span class="line-number">924</span>        if len(all_tokens) &lt; 2:
<span class="line-number">925</span><span class="uncovered">            return None</span>
<span class="line-number">926</span>
<span class="line-number">927</span>        # Function pointer typedef: typedef ret (*name)(params);
<span class="line-number">928</span>        for i in range(len(all_tokens) - 3):
<span class="line-number">929</span>            if (
<span class="line-number">930</span>                all_tokens[i].type
<span class="line-number">931</span>                in [
<span class="line-number">932</span>                    TokenType.IDENTIFIER,
<span class="line-number">933</span>                    TokenType.INT,
<span class="line-number">934</span>                    TokenType.VOID,
<span class="line-number">935</span>                    TokenType.CHAR,
<span class="line-number">936</span>                    TokenType.FLOAT,
<span class="line-number">937</span>                    TokenType.DOUBLE,
<span class="line-number">938</span>                    TokenType.LONG,
<span class="line-number">939</span>                    TokenType.SHORT,
<span class="line-number">940</span>                    TokenType.UNSIGNED,
<span class="line-number">941</span>                    TokenType.SIGNED,
<span class="line-number">942</span>                ]
<span class="line-number">943</span>                and all_tokens[i + 1].type == TokenType.LPAREN
<span class="line-number">944</span>                and all_tokens[i + 2].type == TokenType.ASTERISK
<span class="line-number">945</span>                and all_tokens[i + 3].type == TokenType.IDENTIFIER
<span class="line-number">946</span>            ):
<span class="line-number">947</span>                # typedef ret (*name)(...)
<span class="line-number">948</span>                typedef_name = all_tokens[i + 3].value
<span class="line-number">949</span>                original_type = &quot; &quot;.join(t.value for t in all_tokens)
<span class="line-number">950</span>                return (typedef_name, original_type)
<span class="line-number">951</span>
<span class="line-number">952</span>        # Array typedef: typedef type name[size];
<span class="line-number">953</span>        for i in range(len(all_tokens)):
<span class="line-number">954</span>            if (
<span class="line-number">955</span>                all_tokens[i].type == TokenType.LBRACKET
<span class="line-number">956</span>                and i &gt; 0
<span class="line-number">957</span>                and all_tokens[i - 1].type == TokenType.IDENTIFIER
<span class="line-number">958</span>            ):
<span class="line-number">959</span><span class="uncovered">                typedef_name = all_tokens[i - 1].value</span>
<span class="line-number">960</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">961</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">962</span>
<span class="line-number">963</span>        # Pointer typedef: typedef type * name;
<span class="line-number">964</span>        for i in range(len(all_tokens) - 2):
<span class="line-number">965</span>            if (
<span class="line-number">966</span>                all_tokens[i].type == TokenType.ASTERISK
<span class="line-number">967</span>                and all_tokens[i + 1].type == TokenType.IDENTIFIER
<span class="line-number">968</span>            ):
<span class="line-number">969</span><span class="uncovered">                typedef_name = all_tokens[i + 1].value</span>
<span class="line-number">970</span><span class="uncovered">                original_type = &quot; &quot;.join(t.value for t in all_tokens)</span>
<span class="line-number">971</span><span class="uncovered">                return (typedef_name, original_type)</span>
<span class="line-number">972</span>
<span class="line-number">973</span>        # Simple typedef: the last token should be the typedef name, everything else is the type
<span class="line-number">974</span>        typedef_name = all_tokens[-1].value
<span class="line-number">975</span>        type_tokens = all_tokens[:-1]
<span class="line-number">976</span>        original_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">977</span>        return (typedef_name, original_type)
<span class="line-number">978</span>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _parse_complex_typedef (lines 979-1493)</h4>
<pre>
<span class="line-number">979</span>    def _parse_complex_typedef(self, tokens, start_pos):
<span class="line-number">980</span>        &quot;&quot;&quot;Parse complex typedef (struct/enum/union)&quot;&quot;&quot;
<span class="line-number">981</span>        # For now, return a simplified version
<span class="line-number">982</span>        # TODO: Implement full complex typedef parsing
<span class="line-number">983</span>
<span class="line-number">984</span>        # Find the typedef name by looking for the pattern after the closing brace
<span class="line-number">985</span>        brace_count = 0
<span class="line-number">986</span>        pos = start_pos
<span class="line-number">987</span>
<span class="line-number">988</span>        # Find opening brace
<span class="line-number">989</span>        while pos &lt; len(tokens) and tokens[pos].type != TokenType.LBRACE:
<span class="line-number">990</span>            pos += 1
<span class="line-number">991</span>
<span class="line-number">992</span>        if pos &gt;= len(tokens):
<span class="line-number">993</span>            return None
<span class="line-number">994</span>
<span class="line-number">995</span>        # Skip to closing brace
<span class="line-number">996</span>        brace_count = 1
<span class="line-number">997</span>        pos += 1
<span class="line-number">998</span>
<span class="line-number">999</span>        while pos &lt; len(tokens) and brace_count &gt; 0:
<span class="line-number">1000</span>            if tokens[pos].type == TokenType.LBRACE:
<span class="line-number">1001</span>                brace_count += 1
<span class="line-number">1002</span>            elif tokens[pos].type == TokenType.RBRACE:
<span class="line-number">1003</span>                brace_count -= 1
<span class="line-number">1004</span>            pos += 1
<span class="line-number">1005</span>
<span class="line-number">1006</span>        if brace_count &gt; 0:
<span class="line-number">1007</span><span class="uncovered">            return None</span>
<span class="line-number">1008</span>
<span class="line-number">1009</span>        # Find typedef name after closing brace
<span class="line-number">1010</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1011</span>            TokenType.WHITESPACE,
<span class="line-number">1012</span>            TokenType.COMMENT,
<span class="line-number">1013</span>        ]:
<span class="line-number">1014</span>            pos += 1
<span class="line-number">1015</span>
<span class="line-number">1016</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1017</span>            typedef_name = tokens[pos].value
<span class="line-number">1018</span>            struct_type = tokens[start_pos].value  # struct/enum/union
<span class="line-number">1019</span>            return (typedef_name, struct_type)
<span class="line-number">1020</span>
<span class="line-number">1021</span>        return None
<span class="line-number">1022</span>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _extract_tag_name_from_typedef (lines 1023-1493)</h4>
<pre>
<span class="line-number">1023</span>    def _extract_tag_name_from_typedef(self, tokens, start_pos):
<span class="line-number">1024</span>        &quot;&quot;&quot;Extract the tag name from a typedef like &#x27;typedef struct TagName { ... } TypedefName;&#x27;&quot;&quot;&quot;
<span class="line-number">1025</span>        # Skip &#x27;typedef&#x27; keyword
<span class="line-number">1026</span>        pos = start_pos + 1
<span class="line-number">1027</span>
<span class="line-number">1028</span>        # Skip whitespace and comments
<span class="line-number">1029</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1030</span>            TokenType.WHITESPACE,
<span class="line-number">1031</span>            TokenType.COMMENT,
<span class="line-number">1032</span>        ]:
<span class="line-number">1033</span>            pos += 1
<span class="line-number">1034</span>
<span class="line-number">1035</span>        if pos &gt;= len(tokens):
<span class="line-number">1036</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1037</span>
<span class="line-number">1038</span>        # Check if it&#x27;s a struct/enum/union
<span class="line-number">1039</span>        if tokens[pos].type not in [TokenType.STRUCT, TokenType.ENUM, TokenType.UNION]:
<span class="line-number">1040</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">1041</span>
<span class="line-number">1042</span>        # Skip struct/enum/union keyword
<span class="line-number">1043</span>        pos += 1
<span class="line-number">1044</span>
<span class="line-number">1045</span>        # Skip whitespace and comments
<span class="line-number">1046</span>        while pos &lt; len(tokens) and tokens[pos].type in [
<span class="line-number">1047</span>            TokenType.WHITESPACE,
<span class="line-number">1048</span>            TokenType.COMMENT,
<span class="line-number">1049</span>        ]:
<span class="line-number">1050</span>            pos += 1
<span class="line-number">1051</span>
<span class="line-number">1052</span>        # Look for tag name (identifier before opening brace)
<span class="line-number">1053</span>        if pos &lt; len(tokens) and tokens[pos].type == TokenType.IDENTIFIER:
<span class="line-number">1054</span>            tag_name = tokens[pos].value
<span class="line-number">1055</span>            return tag_name
<span class="line-number">1056</span>
<span class="line-number">1057</span>        return &quot;&quot;
<span class="line-number">1058</span>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _looks_like_function (lines 1059-1493)</h4>
<pre>
<span class="line-number">1059</span>    def _looks_like_function(self, tokens, start_pos):
<span class="line-number">1060</span>        &quot;&quot;&quot;Check if the token sequence starting at start_pos looks like a function&quot;&quot;&quot;
<span class="line-number">1061</span>        # Look ahead for parentheses within a reasonable distance
<span class="line-number">1062</span>        for i in range(start_pos, min(start_pos + 10, len(tokens))):
<span class="line-number">1063</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1064</span>                return True
<span class="line-number">1065</span>            if tokens[i].type in [
<span class="line-number">1066</span>                TokenType.SEMICOLON,
<span class="line-number">1067</span>                TokenType.LBRACE,
<span class="line-number">1068</span>                TokenType.RBRACE,
<span class="line-number">1069</span>            ]:
<span class="line-number">1070</span>                return False
<span class="line-number">1071</span>        return False
<span class="line-number">1072</span>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _skip_function (lines 1073-1493)</h4>
<pre>
<span class="line-number">1073</span>    def _skip_function(self, tokens, start_pos):
<span class="line-number">1074</span>        &quot;&quot;&quot;Skip over a function definition or declaration&quot;&quot;&quot;
<span class="line-number">1075</span>        # Find the end (either semicolon for declaration or closing brace for definition)
<span class="line-number">1076</span>        i = start_pos
<span class="line-number">1077</span>        brace_count = 0
<span class="line-number">1078</span>        paren_count = 0
<span class="line-number">1079</span>
<span class="line-number">1080</span>        while i &lt; len(tokens):
<span class="line-number">1081</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1082</span>                paren_count += 1
<span class="line-number">1083</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1084</span>                paren_count -= 1
<span class="line-number">1085</span>            elif tokens[i].type == TokenType.LBRACE:
<span class="line-number">1086</span>                brace_count += 1
<span class="line-number">1087</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1088</span>                brace_count -= 1
<span class="line-number">1089</span>                if brace_count == 0 and paren_count == 0:
<span class="line-number">1090</span>                    return i + 1
<span class="line-number">1091</span>            elif (
<span class="line-number">1092</span>                tokens[i].type == TokenType.SEMICOLON
<span class="line-number">1093</span>                and paren_count == 0
<span class="line-number">1094</span>                and brace_count == 0
<span class="line-number">1095</span>            ):
<span class="line-number">1096</span>                return i + 1
<span class="line-number">1097</span>            i += 1
<span class="line-number">1098</span>
<span class="line-number">1099</span>        return i
<span class="line-number">1100</span>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _skip_structure_definition (lines 1101-1493)</h4>
<pre>
<span class="line-number">1101</span>    def _skip_structure_definition(self, tokens, start_pos):
<span class="line-number">1102</span>        &quot;&quot;&quot;Skip over struct/enum/union/typedef definition&quot;&quot;&quot;
<span class="line-number">1103</span>        i = start_pos
<span class="line-number">1104</span>        brace_count = 0
<span class="line-number">1105</span>
<span class="line-number">1106</span>        while i &lt; len(tokens):
<span class="line-number">1107</span>            if tokens[i].type == TokenType.LBRACE:
<span class="line-number">1108</span>                brace_count += 1
<span class="line-number">1109</span>            elif tokens[i].type == TokenType.RBRACE:
<span class="line-number">1110</span>                brace_count -= 1
<span class="line-number">1111</span>                if brace_count == 0:
<span class="line-number">1112</span>                    # Continue until semicolon
<span class="line-number">1113</span>                    while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1114</span>                        i += 1
<span class="line-number">1115</span>                    return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1116</span>            elif tokens[i].type == TokenType.SEMICOLON and brace_count == 0:
<span class="line-number">1117</span>                return i + 1
<span class="line-number">1118</span>            i += 1
<span class="line-number">1119</span>
<span class="line-number">1120</span><span class="uncovered">        return i</span>
<span class="line-number">1121</span>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _parse_global_variable (lines 1122-1493)</h4>
<pre>
<span class="line-number">1122</span>    def _parse_global_variable(self, tokens, start_pos):
<span class="line-number">1123</span>        &quot;&quot;&quot;Parse a global variable declaration starting at start_pos&quot;&quot;&quot;
<span class="line-number">1124</span>        # Look for pattern: [static/extern] type name [= value];
<span class="line-number">1125</span>        i = start_pos
<span class="line-number">1126</span>        collected_tokens = []
<span class="line-number">1127</span>
<span class="line-number">1128</span>        # Collect tokens until semicolon
<span class="line-number">1129</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1130</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1131</span>                collected_tokens.append(tokens[i])
<span class="line-number">1132</span>            i += 1
<span class="line-number">1133</span>
<span class="line-number">1134</span>        if len(collected_tokens) &lt; 2:
<span class="line-number">1135</span>            return None
<span class="line-number">1136</span>
<span class="line-number">1137</span>        # Skip modifiers
<span class="line-number">1138</span>        start_idx = 0
<span class="line-number">1139</span>        while start_idx &lt; len(collected_tokens) and collected_tokens[
<span class="line-number">1140</span>            start_idx
<span class="line-number">1141</span>        ].type in [TokenType.STATIC, TokenType.EXTERN, TokenType.CONST]:
<span class="line-number">1142</span>            start_idx += 1
<span class="line-number">1143</span>
<span class="line-number">1144</span>        # Check if there&#x27;s an assignment
<span class="line-number">1145</span>        assign_idx = None
<span class="line-number">1146</span>        for j in range(start_idx, len(collected_tokens)):
<span class="line-number">1147</span>            if collected_tokens[j].type == TokenType.ASSIGN:
<span class="line-number">1148</span>                assign_idx = j
<span class="line-number">1149</span>                break
<span class="line-number">1150</span>
<span class="line-number">1151</span>        # Extract variable name and type
<span class="line-number">1152</span>        if assign_idx is not None:
<span class="line-number">1153</span>            # Has assignment: type name = value
<span class="line-number">1154</span>            if assign_idx &gt; start_idx + 1:
<span class="line-number">1155</span>                var_name = collected_tokens[assign_idx - 1].value
<span class="line-number">1156</span>                type_tokens = collected_tokens[start_idx : assign_idx - 1]
<span class="line-number">1157</span>                value_tokens = collected_tokens[assign_idx + 1 :]
<span class="line-number">1158</span>                var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1159</span>                var_value = &quot; &quot;.join(t.value for t in value_tokens)
<span class="line-number">1160</span>                return (var_name, var_type, var_value)
<span class="line-number">1161</span>        else:
<span class="line-number">1162</span>            # No assignment: type name or type name[size]
<span class="line-number">1163</span>            if len(collected_tokens) &gt; start_idx + 1:
<span class="line-number">1164</span>                # Check if this is an array declaration
<span class="line-number">1165</span>                bracket_idx = None
<span class="line-number">1166</span>                for j in range(len(collected_tokens) - 1, start_idx, -1):
<span class="line-number">1167</span>                    if collected_tokens[j].type == TokenType.RBRACKET:
<span class="line-number">1168</span>                        bracket_idx = j
<span class="line-number">1169</span>                        break
<span class="line-number">1170</span>
<span class="line-number">1171</span>                if bracket_idx is not None:
<span class="line-number">1172</span>                    # Array declaration: find the identifier before the opening bracket
<span class="line-number">1173</span>                    for j in range(bracket_idx - 1, start_idx, -1):
<span class="line-number">1174</span>                        if collected_tokens[j].type == TokenType.LBRACKET:
<span class="line-number">1175</span>                            # Found opening bracket, look for identifier before it
<span class="line-number">1176</span>                            for k in range(j - 1, start_idx, -1):
<span class="line-number">1177</span>                                if collected_tokens[k].type == TokenType.IDENTIFIER:
<span class="line-number">1178</span>                                    var_name = collected_tokens[k].value
<span class="line-number">1179</span>                                    type_tokens = collected_tokens[start_idx:k]
<span class="line-number">1180</span>                                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1181</span>                                    return (var_name, var_type, None)
<span class="line-number">1182</span><span class="uncovered">                            break</span>
<span class="line-number">1183</span>                else:
<span class="line-number">1184</span>                    # Regular variable: last token is the name
<span class="line-number">1185</span>                    var_name = collected_tokens[-1].value
<span class="line-number">1186</span>                    type_tokens = collected_tokens[start_idx:-1]
<span class="line-number">1187</span>                    var_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1188</span>                    return (var_name, var_type, None)
<span class="line-number">1189</span>
<span class="line-number">1190</span>        return None
<span class="line-number">1191</span>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _skip_to_semicolon (lines 1192-1493)</h4>
<pre>
<span class="line-number">1192</span>    def _skip_to_semicolon(self, tokens, start_pos):
<span class="line-number">1193</span>        &quot;&quot;&quot;Skip to the next semicolon&quot;&quot;&quot;
<span class="line-number">1194</span>        i = start_pos
<span class="line-number">1195</span>        while i &lt; len(tokens) and tokens[i].type != TokenType.SEMICOLON:
<span class="line-number">1196</span>            i += 1
<span class="line-number">1197</span>        return i + 1 if i &lt; len(tokens) else i
<span class="line-number">1198</span>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _skip_preprocessor_directives (lines 1199-1493)</h4>
<pre>
<span class="line-number">1199</span>    def _skip_preprocessor_directives(self, tokens, start_pos):
<span class="line-number">1200</span>        &quot;&quot;&quot;Skip preprocessor directives but keep their content for parsing&quot;&quot;&quot;
<span class="line-number">1201</span>        # This method is deprecated - use the PreprocessorManager instead
<span class="line-number">1202</span><span class="uncovered">        i = start_pos</span>
<span class="line-number">1203</span><span class="uncovered">        while i &lt; len(tokens) and tokens[i].type == TokenType.PREPROCESSOR:</span>
<span class="line-number">1204</span>            # Skip the preprocessor directive itself
<span class="line-number">1205</span><span class="uncovered">            i += 1</span>
<span class="line-number">1206</span><span class="uncovered">        return i</span>
<span class="line-number">1207</span>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _parse_function_parameters (lines 1208-1493)</h4>
<pre>
<span class="line-number">1208</span>    def _parse_function_parameters(self, tokens, start_pos, end_pos, func_name):
<span class="line-number">1209</span>        &quot;&quot;&quot;Parse function parameters from token range&quot;&quot;&quot;
<span class="line-number">1210</span>
<span class="line-number">1211</span>        parameters = []
<span class="line-number">1212</span>
<span class="line-number">1213</span>        # Find the opening parenthesis for the function
<span class="line-number">1214</span>        paren_start = None
<span class="line-number">1215</span>        paren_end = None
<span class="line-number">1216</span>
<span class="line-number">1217</span>        for i in range(start_pos, min(end_pos + 1, len(tokens))):
<span class="line-number">1218</span>            if tokens[i].type == TokenType.IDENTIFIER and tokens[i].value == func_name:
<span class="line-number">1219</span>                # Look for opening parenthesis after function name
<span class="line-number">1220</span>                for j in range(i + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1221</span>                    if tokens[j].type == TokenType.LPAREN:
<span class="line-number">1222</span>                        paren_start = j
<span class="line-number">1223</span>                        break
<span class="line-number">1224</span><span class="uncovered">                    elif tokens[j].type not in [</span>
<span class="line-number">1225</span>                        TokenType.WHITESPACE,
<span class="line-number">1226</span>                        TokenType.COMMENT,
<span class="line-number">1227</span>                    ]:
<span class="line-number">1228</span><span class="uncovered">                        break</span>
<span class="line-number">1229</span>                break
<span class="line-number">1230</span>
<span class="line-number">1231</span>        if paren_start is None:
<span class="line-number">1232</span><span class="uncovered">            return parameters</span>
<span class="line-number">1233</span>
<span class="line-number">1234</span>        # Find matching closing parenthesis
<span class="line-number">1235</span>        paren_depth = 1
<span class="line-number">1236</span>        for i in range(paren_start + 1, min(end_pos + 1, len(tokens))):
<span class="line-number">1237</span>            if tokens[i].type == TokenType.LPAREN:
<span class="line-number">1238</span>                paren_depth += 1
<span class="line-number">1239</span>            elif tokens[i].type == TokenType.RPAREN:
<span class="line-number">1240</span>                paren_depth -= 1
<span class="line-number">1241</span>                if paren_depth == 0:
<span class="line-number">1242</span>                    paren_end = i
<span class="line-number">1243</span>                    break
<span class="line-number">1244</span>
<span class="line-number">1245</span>        if paren_end is None:
<span class="line-number">1246</span><span class="uncovered">            return parameters</span>
<span class="line-number">1247</span>
<span class="line-number">1248</span>        # Parse parameter tokens between parentheses
<span class="line-number">1249</span>        param_tokens = []
<span class="line-number">1250</span>        for i in range(paren_start + 1, paren_end):
<span class="line-number">1251</span>            if tokens[i].type not in [TokenType.WHITESPACE, TokenType.COMMENT]:
<span class="line-number">1252</span>                param_tokens.append(tokens[i])
<span class="line-number">1253</span>
<span class="line-number">1254</span>        # If no parameters or just &quot;void&quot;, return empty list
<span class="line-number">1255</span>        if not param_tokens or (
<span class="line-number">1256</span>            len(param_tokens) == 1 and param_tokens[0].value == &quot;void&quot;
<span class="line-number">1257</span>        ):
<span class="line-number">1258</span>            return parameters
<span class="line-number">1259</span>
<span class="line-number">1260</span>        # Split parameters by commas
<span class="line-number">1261</span>        current_param = []
<span class="line-number">1262</span>        for token in param_tokens:
<span class="line-number">1263</span>            if token.type == TokenType.COMMA:
<span class="line-number">1264</span>                if current_param:
<span class="line-number">1265</span>                    param = self._parse_single_parameter(current_param)
<span class="line-number">1266</span>                    if param:
<span class="line-number">1267</span>                        parameters.append(param)
<span class="line-number">1268</span>                    current_param = []
<span class="line-number">1269</span>            else:
<span class="line-number">1270</span>                current_param.append(token)
<span class="line-number">1271</span>
<span class="line-number">1272</span>        # Handle last parameter
<span class="line-number">1273</span>        if current_param:
<span class="line-number">1274</span>            param = self._parse_single_parameter(current_param)
<span class="line-number">1275</span>            if param:
<span class="line-number">1276</span>                parameters.append(param)
<span class="line-number">1277</span>
<span class="line-number">1278</span>        return parameters
<span class="line-number">1279</span>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _parse_single_parameter (lines 1280-1493)</h4>
<pre>
<span class="line-number">1280</span>    def _parse_single_parameter(self, param_tokens):
<span class="line-number">1281</span>        &quot;&quot;&quot;Parse a single function parameter from tokens&quot;&quot;&quot;
<span class="line-number">1282</span>        from .models import Field
<span class="line-number">1283</span>
<span class="line-number">1284</span>        if not param_tokens:
<span class="line-number">1285</span><span class="uncovered">            return None</span>
<span class="line-number">1286</span>
<span class="line-number">1287</span>        # Handle variadic parameters (three consecutive dots)
<span class="line-number">1288</span>        if len(param_tokens) == 3 and all(t.value == &quot;.&quot; for t in param_tokens):
<span class="line-number">1289</span>            return Field(name=&quot;...&quot;, type=&quot;...&quot;)
<span class="line-number">1290</span>
<span class="line-number">1291</span>        # Handle variadic parameters (single ... token)
<span class="line-number">1292</span>        if len(param_tokens) == 1 and param_tokens[0].value == &quot;...&quot;:
<span class="line-number">1293</span><span class="uncovered">            return Field(name=&quot;...&quot;, type=&quot;...&quot;)</span>
<span class="line-number">1294</span>
<span class="line-number">1295</span>        # For parameters like &quot;int x&quot; or &quot;const char *name&quot;
<span class="line-number">1296</span>        if len(param_tokens) &gt;= 2:
<span class="line-number">1297</span>            # Last token is usually the parameter name
<span class="line-number">1298</span>            param_name = param_tokens[-1].value
<span class="line-number">1299</span>            type_tokens = param_tokens[:-1]
<span class="line-number">1300</span>            param_type = &quot; &quot;.join(t.value for t in type_tokens)
<span class="line-number">1301</span>
<span class="line-number">1302</span>            # Handle unnamed parameters (just type)
<span class="line-number">1303</span>            if param_name in [
<span class="line-number">1304</span>                &quot;void&quot;,
<span class="line-number">1305</span>                &quot;int&quot;,
<span class="line-number">1306</span>                &quot;char&quot;,
<span class="line-number">1307</span>                &quot;float&quot;,
<span class="line-number">1308</span>                &quot;double&quot;,
<span class="line-number">1309</span>                &quot;long&quot;,
<span class="line-number">1310</span>                &quot;short&quot;,
<span class="line-number">1311</span>                &quot;unsigned&quot;,
<span class="line-number">1312</span>                &quot;signed&quot;,
<span class="line-number">1313</span>            ]:
<span class="line-number">1314</span>                # This is just a type without a name
<span class="line-number">1315</span>                return Field(name=&quot;unnamed&quot;, type=param_type + &quot; &quot; + param_name)
<span class="line-number">1316</span>
<span class="line-number">1317</span>            # Additional validation before creating Field
<span class="line-number">1318</span>            if param_name and param_name.strip() and param_type and param_type.strip():
<span class="line-number">1319</span>                return Field(name=param_name.strip(), type=param_type.strip())
<span class="line-number">1320</span>            else:
<span class="line-number">1321</span>                # Fallback for invalid parameters
<span class="line-number">1322</span>                return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)
<span class="line-number">1323</span>        elif len(param_tokens) == 1:
<span class="line-number">1324</span>            # Single token - might be just type (like &quot;void&quot;) or name
<span class="line-number">1325</span>            token_value = param_tokens[0].value
<span class="line-number">1326</span>            if token_value in [
<span class="line-number">1327</span>                &quot;void&quot;,
<span class="line-number">1328</span>                &quot;int&quot;,
<span class="line-number">1329</span>                &quot;char&quot;,
<span class="line-number">1330</span>                &quot;float&quot;,
<span class="line-number">1331</span>                &quot;double&quot;,
<span class="line-number">1332</span>                &quot;long&quot;,
<span class="line-number">1333</span>                &quot;short&quot;,
<span class="line-number">1334</span>                &quot;unsigned&quot;,
<span class="line-number">1335</span>                &quot;signed&quot;,
<span class="line-number">1336</span>            ]:
<span class="line-number">1337</span>                return Field(name=&quot;unnamed&quot;, type=token_value)
<span class="line-number">1338</span>            else:
<span class="line-number">1339</span>                # If we can&#x27;t determine the type, use &#x27;unknown&#x27; as a fallback
<span class="line-number">1340</span><span class="uncovered">                if token_value and token_value.strip():</span>
<span class="line-number">1341</span><span class="uncovered">                    return Field(name=token_value.strip(), type=&quot;unknown&quot;)</span>
<span class="line-number">1342</span>                else:
<span class="line-number">1343</span><span class="uncovered">                    return Field(name=&quot;unnamed&quot;, type=&quot;unknown&quot;)</span>
<span class="line-number">1344</span>
<span class="line-number">1345</span><span class="uncovered">        return None</span>
<span class="line-number">1346</span>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
<span class="line-number">1362</span>    &quot;&quot;&quot;Main parser class for Step 1: Parse C code files and generate model.json&quot;&quot;&quot;
<span class="line-number">1363</span>
<span class="line-number">1364</span>    def __init__(self):
<span class="line-number">1365</span>        self.c_parser = CParser()
<span class="line-number">1366</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">1367</span>
<span class="line-number">1368</span>    def parse(
<span class="line-number">1369</span>        self,
<span class="line-number">1370</span>        project_root: &quot;Union[str, List[str]]&quot;,
<span class="line-number">1371</span>        output_file: str = &quot;model.json&quot;,
<span class="line-number">1372</span>        recursive_search: bool = True,
<span class="line-number">1373</span>        config: &quot;Config&quot; = None,
<span class="line-number">1374</span>    ) -&gt; str:
<span class="line-number">1375</span>        &quot;&quot;&quot;
<span class="line-number">1376</span>        Step 1: Parse C code files and generate model.json
<span class="line-number">1377</span>
<span class="line-number">1378</span>        Args:
<span class="line-number">1379</span>            project_root: Either a single root directory of C/C++ project (for backward compatibility)
<span class="line-number">1380</span>                         or a list of source folder directories within the project
<span class="line-number">1381</span>            output_file: Output JSON model file path
<span class="line-number">1382</span>            recursive_search: Whether to search subdirectories recursively
<span class="line-number">1383</span>            config: Configuration object for filtering, include depth, and project name
<span class="line-number">1384</span>
<span class="line-number">1385</span>        Returns:
<span class="line-number">1386</span>            Path to the generated model.json file
<span class="line-number">1387</span>        &quot;&quot;&quot;
<span class="line-number">1388</span>        # Handle both single project_root (backward compatibility) and list of source_folders
<span class="line-number">1389</span>        if isinstance(project_root, str):
<span class="line-number">1390</span>            # Single source folder - backward compatibility
<span class="line-number">1391</span>            source_folders = [project_root]
<span class="line-number">1392</span>            self.logger.info(&quot;Step 1: Parsing C/C++ project: %s&quot;, project_root)
<span class="line-number">1393</span>        else:
<span class="line-number">1394</span>            # Multiple source folders
<span class="line-number">1395</span>            source_folders = project_root
<span class="line-number">1396</span>            if not source_folders:
<span class="line-number">1397</span>                raise ValueError(&quot;At least one source folder must be provided&quot;)
<span class="line-number">1398</span>            self.logger.info(
<span class="line-number">1399</span>                f&quot;Step 1: Parsing C/C++ project with {len(source_folders)} source folders&quot;
<span class="line-number">1400</span>            )
<span class="line-number">1401</span>
<span class="line-number">1402</span>        # Get project name from config or use default
<span class="line-number">1403</span>        project_name = (
<span class="line-number">1404</span>            getattr(config, &quot;project_name&quot;, &quot;C_Project&quot;) if config else &quot;C_Project&quot;
<span class="line-number">1405</span>        )
<span class="line-number">1406</span>
<span class="line-number">1407</span>        # Parse each source folder and combine results
<span class="line-number">1408</span>        all_files = {}
<span class="line-number">1409</span>        total_structs = 0
<span class="line-number">1410</span>        total_enums = 0
<span class="line-number">1411</span>        total_functions = 0
<span class="line-number">1412</span>
<span class="line-number">1413</span>        for i, source_folder in enumerate(source_folders):
<span class="line-number">1414</span>            self.logger.info(
<span class="line-number">1415</span>                f&quot;Parsing source folder {i+1}/{len(source_folders)}: {source_folder}&quot;
<span class="line-number">1416</span>            )
<span class="line-number">1417</span>
<span class="line-number">1418</span>            try:
<span class="line-number">1419</span>                # Parse the individual source folder
<span class="line-number">1420</span>                model = self.c_parser.parse_project(
<span class="line-number">1421</span>                    source_folder, recursive_search, config
<span class="line-number">1422</span>                )
<span class="line-number">1423</span>
<span class="line-number">1424</span>                if len(source_folders) == 1:
<span class="line-number">1425</span>                    # Single source folder - use original behavior (no prefix)
<span class="line-number">1426</span>                    all_files.update(model.files)
<span class="line-number">1427</span>                else:
<span class="line-number">1428</span>                    # Multiple source folders - use source folder name as prefix to avoid conflicts
<span class="line-number">1429</span>                    source_folder_prefix = f&quot;{Path(source_folder).name}_&quot;
<span class="line-number">1430</span>                    for relative_path, file_model in model.files.items():
<span class="line-number">1431</span>                        # Create a unique key for each file across all source folders
<span class="line-number">1432</span>                        unique_key = f&quot;{source_folder_prefix}{relative_path}&quot;
<span class="line-number">1433</span>                        all_files[unique_key] = file_model
<span class="line-number">1434</span>
<span class="line-number">1435</span>                # Update totals
<span class="line-number">1436</span>                total_structs += sum(len(f.structs) for f in model.files.values())
<span class="line-number">1437</span>                total_enums += sum(len(f.enums) for f in model.files.values())
<span class="line-number">1438</span>                total_functions += sum(len(f.functions) for f in model.files.values())
<span class="line-number">1439</span>
<span class="line-number">1440</span>                self.logger.info(
<span class="line-number">1441</span>                    f&quot;Successfully parsed source folder {source_folder}: {len(model.files)} files&quot;
<span class="line-number">1442</span>                )
<span class="line-number">1443</span>
<span class="line-number">1444</span>            except Exception as e:
<span class="line-number">1445</span>                self.logger.error(
<span class="line-number">1446</span>                    &quot;Failed to parse source folder %s: %s&quot;, source_folder, e
<span class="line-number">1447</span>                )
<span class="line-number">1448</span>                raise
<span class="line-number">1449</span>
<span class="line-number">1450</span>        # Create combined project model
<span class="line-number">1451</span>        combined_model = ProjectModel(
<span class="line-number">1452</span>            project_name=project_name,
<span class="line-number">1453</span>            project_root=(
<span class="line-number">1454</span>                &quot;,&quot;.join(source_folders)
<span class="line-number">1455</span>                if len(source_folders) &gt; 1
<span class="line-number">1456</span>                else source_folders[0]
<span class="line-number">1457</span>            ),
<span class="line-number">1458</span>            files=all_files,
<span class="line-number">1459</span>        )
<span class="line-number">1460</span>
<span class="line-number">1461</span>        # Update all uses fields across the entire combined project
<span class="line-number">1462</span>        combined_model.update_uses_fields()
<span class="line-number">1463</span>
<span class="line-number">1464</span>        # Save combined model to JSON file
<span class="line-number">1465</span>        combined_model.save(output_file)
<span class="line-number">1466</span>
<span class="line-number">1467</span>        # Step 1.5: Verify model sanity
<span class="line-number">1468</span>        self.logger.info(&quot;Step 1.5: Verifying model sanity...&quot;)
<span class="line-number">1469</span>        from .verifier import ModelVerifier
<span class="line-number">1470</span>
<span class="line-number">1471</span>        verifier = ModelVerifier()
<span class="line-number">1472</span>        is_valid, issues = verifier.verify_model(combined_model)
<span class="line-number">1473</span>
<span class="line-number">1474</span>        if not is_valid:
<span class="line-number">1475</span>            self.logger.warning(
<span class="line-number">1476</span>                f&quot;Model verification found {len(issues)} issues - model may contain parsing errors&quot;
<span class="line-number">1477</span>            )
<span class="line-number">1478</span>            # Continue processing but warn about potential issues
<span class="line-number">1479</span>        else:
<span class="line-number">1480</span>            self.logger.info(&quot;Model verification passed - all values look sane&quot;)
<span class="line-number">1481</span>
<span class="line-number">1482</span>        self.logger.info(&quot;Step 1 complete! Model saved to: %s&quot;, output_file)
<span class="line-number">1483</span>        self.logger.info(
<span class="line-number">1484</span>            f&quot;Found {len(all_files)} total files across {len(source_folders)} source folder(s)&quot;
<span class="line-number">1485</span>        )
<span class="line-number">1486</span>
<span class="line-number">1487</span>        # Print summary
<span class="line-number">1488</span>        self.logger.info(
<span class="line-number">1489</span>            f&quot;Summary: {total_structs} structs, {total_enums} enums, &quot;
<span class="line-number">1490</span>            f&quot;{total_functions} functions&quot;
<span class="line-number">1491</span>        )
<span class="line-number">1492</span>
<span class="line-number">1493</span>        return output_file
</pre>
<h4>Function: _get_timestamp (lines 1347-1361)</h4>
<pre>
<span class="line-number">1347</span>    def _get_timestamp(self) -&gt; str:
<span class="line-number">1348</span>        &quot;&quot;&quot;Get current timestamp string&quot;&quot;&quot;
<span class="line-number">1349</span><span class="uncovered">        from datetime import datetime</span>
<span class="line-number">1350</span>
<span class="line-number">1351</span><span class="uncovered">        return datetime.now().isoformat()</span>
<span class="line-number">1352</span>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
<span class="line-number">1361</span>class Parser:
</pre>
<h4>Function: get_failed_includes_cache_stats (lines 1353-1360)</h4>
<pre>
<span class="line-number">1353</span>    def get_failed_includes_cache_stats(self) -&gt; dict:
<span class="line-number">1354</span>        &quot;&quot;&quot;Get statistics about the failed includes cache&quot;&quot;&quot;
<span class="line-number">1355</span><span class="uncovered">        return {</span>
<span class="line-number">1356</span>            &quot;cache_size&quot;: len(self._failed_includes_cache),
<span class="line-number">1357</span>            &quot;cached_includes&quot;: list(self._failed_includes_cache),
<span class="line-number">1358</span>        }
<span class="line-number">1359</span>
<span class="line-number">1360</span>
</pre>
</div>
<div class="file-section">
<div class="file-header">
/home/runner/work/generator_project/generator_project/c_to_plantuml/models.py - 86.54% coverage (225/260 lines)
</div>
<h4>Function: __repr__ (lines 19-49)</h4>
<pre>
<span class="line-number"> 19</span>    def __repr__(self):
<span class="line-number"> 20</span>        if self.value is not None:
<span class="line-number"> 21</span>            return f&quot;Field(name={self.name}, type={self.type}, value={self.value})&quot;
<span class="line-number"> 22</span>        return f&quot;Field(name={self.name}, type={self.type})&quot;
<span class="line-number"> 23</span>
<span class="line-number"> 24</span>    def __post_init__(self):
<span class="line-number"> 25</span>        &quot;&quot;&quot;Validate field data after initialization&quot;&quot;&quot;
<span class="line-number"> 26</span>        if not isinstance(self.name, str):
<span class="line-number"> 27</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 28</span>                f&quot;Field name must be a string, got {type(self.name)}: {repr(self.name)}&quot;
<span class="line-number"> 29</span>            )
<span class="line-number"> 30</span>        if not self.type or not isinstance(self.type, str):
<span class="line-number"> 31</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 32</span>                f&quot;Field type must be a non-empty string, got {type(self.type)}: {repr(self.type)}&quot;
<span class="line-number"> 33</span>            )
<span class="line-number"> 34</span>
<span class="line-number"> 35</span>        # Additional validation: ensure name and type are not just whitespace
<span class="line-number"> 36</span>        if not self.name.strip():
<span class="line-number"> 37</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 38</span>                f&quot;Field name cannot be empty or whitespace, got: {repr(self.name)}&quot;
<span class="line-number"> 39</span>            )
<span class="line-number"> 40</span>        if not self.type.strip():
<span class="line-number"> 41</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 42</span>                f&quot;Field type cannot be empty or whitespace, got: {repr(self.type)}&quot;
<span class="line-number"> 43</span>            )
<span class="line-number"> 44</span>
<span class="line-number"> 45</span>
<span class="line-number"> 46</span># TypedefRelation class removed - tag names moved to struct/enum/union
<span class="line-number"> 47</span>
<span class="line-number"> 48</span>
<span class="line-number"> 49</span>@dataclass
</pre>
<h4>Function: __post_init__ (lines 24-48)</h4>
<pre>
<span class="line-number"> 24</span>    def __post_init__(self):
<span class="line-number"> 25</span>        &quot;&quot;&quot;Validate field data after initialization&quot;&quot;&quot;
<span class="line-number"> 26</span>        if not isinstance(self.name, str):
<span class="line-number"> 27</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 28</span>                f&quot;Field name must be a string, got {type(self.name)}: {repr(self.name)}&quot;
<span class="line-number"> 29</span>            )
<span class="line-number"> 30</span>        if not self.type or not isinstance(self.type, str):
<span class="line-number"> 31</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 32</span>                f&quot;Field type must be a non-empty string, got {type(self.type)}: {repr(self.type)}&quot;
<span class="line-number"> 33</span>            )
<span class="line-number"> 34</span>
<span class="line-number"> 35</span>        # Additional validation: ensure name and type are not just whitespace
<span class="line-number"> 36</span>        if not self.name.strip():
<span class="line-number"> 37</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 38</span>                f&quot;Field name cannot be empty or whitespace, got: {repr(self.name)}&quot;
<span class="line-number"> 39</span>            )
<span class="line-number"> 40</span>        if not self.type.strip():
<span class="line-number"> 41</span><span class="uncovered">            raise ValueError(</span>
<span class="line-number"> 42</span>                f&quot;Field type cannot be empty or whitespace, got: {repr(self.type)}&quot;
<span class="line-number"> 43</span>            )
<span class="line-number"> 44</span>
<span class="line-number"> 45</span>
<span class="line-number"> 46</span># TypedefRelation class removed - tag names moved to struct/enum/union
<span class="line-number"> 47</span>
<span class="line-number"> 48</span>
</pre>
<h4>Function: __post_init__ (lines 57-66)</h4>
<pre>
<span class="line-number"> 57</span>    def __post_init__(self):
<span class="line-number"> 58</span>        &quot;&quot;&quot;Validate include relation data after initialization&quot;&quot;&quot;
<span class="line-number"> 59</span>        if not self.source_file or not isinstance(self.source_file, str):
<span class="line-number"> 60</span><span class="uncovered">            raise ValueError(&quot;Source file must be a non-empty string&quot;)</span>
<span class="line-number"> 61</span>        if not self.included_file or not isinstance(self.included_file, str):
<span class="line-number"> 62</span><span class="uncovered">            raise ValueError(&quot;Included file must be a non-empty string&quot;)</span>
<span class="line-number"> 63</span>        if not isinstance(self.depth, int) or self.depth &lt; 0:
<span class="line-number"> 64</span><span class="uncovered">            raise ValueError(&quot;Depth must be a non-negative integer&quot;)</span>
<span class="line-number"> 65</span>
<span class="line-number"> 66</span>
</pre>
<h4>Function: __post_init__ (lines 77-94)</h4>
<pre>
<span class="line-number"> 77</span>    def __post_init__(self):
<span class="line-number"> 78</span>        &quot;&quot;&quot;Validate function data after initialization&quot;&quot;&quot;
<span class="line-number"> 79</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number"> 80</span><span class="uncovered">            raise ValueError(&quot;Function name must be a non-empty string&quot;)</span>
<span class="line-number"> 81</span>        if not self.return_type or not isinstance(self.return_type, str):
<span class="line-number"> 82</span><span class="uncovered">            raise ValueError(&quot;Function return type must be a non-empty string&quot;)</span>
<span class="line-number"> 83</span>
<span class="line-number"> 84</span>        # Convert parameters to Field objects if they&#x27;re dictionaries
<span class="line-number"> 85</span>        if self.parameters:
<span class="line-number"> 86</span>            converted_params = []
<span class="line-number"> 87</span>            for param in self.parameters:
<span class="line-number"> 88</span>                if isinstance(param, dict):
<span class="line-number"> 89</span>                    converted_params.append(Field(**param))
<span class="line-number"> 90</span>                else:
<span class="line-number"> 91</span>                    converted_params.append(param)
<span class="line-number"> 92</span>            self.parameters = converted_params
<span class="line-number"> 93</span>
<span class="line-number"> 94</span>
</pre>
<h4>Function: __post_init__ (lines 107-112)</h4>
<pre>
<span class="line-number">107</span>    def __post_init__(self):
<span class="line-number">108</span>        &quot;&quot;&quot;Validate struct data after initialization&quot;&quot;&quot;
<span class="line-number">109</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">110</span><span class="uncovered">            raise ValueError(&quot;Struct name must be a non-empty string&quot;)</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
</pre>
<h4>Function: __post_init__ (lines 118-122)</h4>
<pre>
<span class="line-number">118</span>    def __post_init__(self):
<span class="line-number">119</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">120</span><span class="uncovered">            raise ValueError(&quot;Enum value name must be a non-empty string&quot;)</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
</pre>
<h4>Function: __post_init__ (lines 131-139)</h4>
<pre>
<span class="line-number">131</span>    def __post_init__(self):
<span class="line-number">132</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">133</span><span class="uncovered">            raise ValueError(&quot;Enum name must be a non-empty string&quot;)</span>
<span class="line-number">134</span>        # Convert any string values to EnumValue
<span class="line-number">135</span>        self.values = [
<span class="line-number">136</span>            v if isinstance(v, EnumValue) else EnumValue(v) for v in self.values
<span class="line-number">137</span>        ]
<span class="line-number">138</span>
<span class="line-number">139</span>
</pre>
<h4>Function: __post_init__ (lines 151-156)</h4>
<pre>
<span class="line-number">151</span>    def __post_init__(self):
<span class="line-number">152</span>        &quot;&quot;&quot;Validate union data after initialization&quot;&quot;&quot;
<span class="line-number">153</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">154</span><span class="uncovered">            raise ValueError(&quot;Union name must be a non-empty string&quot;)</span>
<span class="line-number">155</span>
<span class="line-number">156</span>
</pre>
<h4>Function: __post_init__ (lines 167-174)</h4>
<pre>
<span class="line-number">167</span>    def __post_init__(self):
<span class="line-number">168</span>        &quot;&quot;&quot;Validate alias data after initialization&quot;&quot;&quot;
<span class="line-number">169</span>        if not self.name or not isinstance(self.name, str):
<span class="line-number">170</span><span class="uncovered">            raise ValueError(&quot;Alias name must be a non-empty string&quot;)</span>
<span class="line-number">171</span>        if not self.original_type or not isinstance(self.original_type, str):
<span class="line-number">172</span><span class="uncovered">            raise ValueError(&quot;Original type must be a non-empty string&quot;)</span>
<span class="line-number">173</span>
<span class="line-number">174</span>
</pre>
<h4>Function: __post_init__ (lines 193-362)</h4>
<pre>
<span class="line-number">193</span>    def __post_init__(self):
<span class="line-number">194</span>        &quot;&quot;&quot;Validate file model data after initialization&quot;&quot;&quot;
<span class="line-number">195</span>        if not self.file_path or not isinstance(self.file_path, str):
<span class="line-number">196</span><span class="uncovered">            raise ValueError(&quot;File path must be a non-empty string&quot;)</span>
<span class="line-number">197</span>        if not self.relative_path or not isinstance(self.relative_path, str):
<span class="line-number">198</span><span class="uncovered">            raise ValueError(&quot;Relative path must be a non-empty string&quot;)</span>
<span class="line-number">199</span>        if not self.project_root or not isinstance(self.project_root, str):
<span class="line-number">200</span><span class="uncovered">            raise ValueError(&quot;Project root must be a non-empty string&quot;)</span>
<span class="line-number">201</span>        if not self.encoding_used or not isinstance(self.encoding_used, str):
<span class="line-number">202</span><span class="uncovered">            raise ValueError(&quot;Encoding must be a non-empty string&quot;)</span>
<span class="line-number">203</span>
<span class="line-number">204</span>    def to_dict(self) -&gt; dict:
<span class="line-number">205</span>        &quot;&quot;&quot;Convert to dictionary for JSON serialization&quot;&quot;&quot;
<span class="line-number">206</span>        data = asdict(self)
<span class="line-number">207</span>        # Convert set to list for JSON serialization and sort for consistency
<span class="line-number">208</span>        data[&quot;includes&quot;] = sorted(list(self.includes))
<span class="line-number">209</span>        # Convert include_relations to list of dicts and sort for consistency
<span class="line-number">210</span>        data[&quot;include_relations&quot;] = sorted(
<span class="line-number">211</span>            [asdict(rel) for rel in self.include_relations],
<span class="line-number">212</span>            key=lambda x: (x[&quot;source_file&quot;], x[&quot;included_file&quot;]),
<span class="line-number">213</span>        )
<span class="line-number">214</span>        # Sort all dictionary fields for consistent ordering
<span class="line-number">215</span>        data[&quot;structs&quot;] = dict(sorted(data[&quot;structs&quot;].items()))
<span class="line-number">216</span>        data[&quot;enums&quot;] = dict(sorted(data[&quot;enums&quot;].items()))
<span class="line-number">217</span>        data[&quot;unions&quot;] = dict(sorted(data[&quot;unions&quot;].items()))
<span class="line-number">218</span>        data[&quot;aliases&quot;] = dict(sorted(data[&quot;aliases&quot;].items()))
<span class="line-number">219</span>        data[&quot;macros&quot;] = sorted(data[&quot;macros&quot;])
<span class="line-number">220</span>        # Sort functions and globals by name (they are already objects, not dicts)
<span class="line-number">221</span>        data[&quot;functions&quot;] = sorted(self.functions, key=lambda x: x.name)
<span class="line-number">222</span>        data[&quot;globals&quot;] = sorted(self.globals, key=lambda x: x.name)
<span class="line-number">223</span>        # Convert functions and globals to dicts after sorting
<span class="line-number">224</span>        data[&quot;functions&quot;] = [asdict(f) for f in data[&quot;functions&quot;]]
<span class="line-number">225</span>        data[&quot;globals&quot;] = [asdict(g) for g in data[&quot;globals&quot;]]
<span class="line-number">226</span>
<span class="line-number">227</span>        # Sort &quot;uses&quot; arrays in structs, unions, and aliases for consistent ordering
<span class="line-number">228</span>        for struct_data in data[&quot;structs&quot;].values():
<span class="line-number">229</span>            if &quot;uses&quot; in struct_data:
<span class="line-number">230</span>                struct_data[&quot;uses&quot;] = sorted(struct_data[&quot;uses&quot;])
<span class="line-number">231</span>        for union_data in data[&quot;unions&quot;].values():
<span class="line-number">232</span>            if &quot;uses&quot; in union_data:
<span class="line-number">233</span>                union_data[&quot;uses&quot;] = sorted(union_data[&quot;uses&quot;])
<span class="line-number">234</span>        for alias_data in data[&quot;aliases&quot;].values():
<span class="line-number">235</span>            if &quot;uses&quot; in alias_data:
<span class="line-number">236</span>                alias_data[&quot;uses&quot;] = sorted(alias_data[&quot;uses&quot;])
<span class="line-number">237</span>
<span class="line-number">238</span>        # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">239</span>        return data
<span class="line-number">240</span>
<span class="line-number">241</span>    @classmethod
<span class="line-number">242</span>    def from_dict(cls, data: dict) -&gt; &quot;FileModel&quot;:
<span class="line-number">243</span>        &quot;&quot;&quot;Create from dictionary&quot;&quot;&quot;
<span class="line-number">244</span>        # Convert list back to set
<span class="line-number">245</span>        includes = set(data.get(&quot;includes&quot;, []))
<span class="line-number">246</span>
<span class="line-number">247</span>        # Convert globals back to Field objects
<span class="line-number">248</span>        globals_data = data.get(&quot;globals&quot;, [])
<span class="line-number">249</span>        globals = [Field(**g) if isinstance(g, dict) else g for g in globals_data]
<span class="line-number">250</span>
<span class="line-number">251</span>        # Convert functions back to Function objects
<span class="line-number">252</span>        functions_data = data.get(&quot;functions&quot;, [])
<span class="line-number">253</span>        functions = [
<span class="line-number">254</span>            Function(**f) if isinstance(f, dict) else f for f in functions_data
<span class="line-number">255</span>        ]
<span class="line-number">256</span>
<span class="line-number">257</span>        # Convert structs back to Struct objects
<span class="line-number">258</span>        structs_data = data.get(&quot;structs&quot;, {})
<span class="line-number">259</span>        structs = {}
<span class="line-number">260</span>        for name, struct_data in structs_data.items():
<span class="line-number">261</span>            if isinstance(struct_data, dict):
<span class="line-number">262</span>                fields = [
<span class="line-number">263</span>                    Field(**field) if isinstance(field, dict) else field
<span class="line-number">264</span>                    for field in struct_data.get(&quot;fields&quot;, [])
<span class="line-number">265</span>                ]
<span class="line-number">266</span>                methods = [
<span class="line-number">267</span>                    Function(**method) if isinstance(method, dict) else method
<span class="line-number">268</span>                    for method in struct_data.get(&quot;methods&quot;, [])
<span class="line-number">269</span>                ]
<span class="line-number">270</span>                structs[name] = Struct(
<span class="line-number">271</span>                    name=struct_data.get(&quot;name&quot;, name),
<span class="line-number">272</span>                    fields=fields,
<span class="line-number">273</span>                    methods=methods,
<span class="line-number">274</span>                    tag_name=struct_data.get(&quot;tag_name&quot;, &quot;&quot;),
<span class="line-number">275</span>                    uses=struct_data.get(&quot;uses&quot;, []),
<span class="line-number">276</span>                )
<span class="line-number">277</span>            else:
<span class="line-number">278</span><span class="uncovered">                structs[name] = struct_data</span>
<span class="line-number">279</span>
<span class="line-number">280</span>        # Convert enums back to Enum objects
<span class="line-number">281</span>        enums_data = data.get(&quot;enums&quot;, {})
<span class="line-number">282</span>        enums = {}
<span class="line-number">283</span>        for name, enum_data in enums_data.items():
<span class="line-number">284</span>            if isinstance(enum_data, dict):
<span class="line-number">285</span>                values = [
<span class="line-number">286</span>                    EnumValue(**val) if isinstance(val, dict) else EnumValue(val)
<span class="line-number">287</span>                    for val in enum_data.get(&quot;values&quot;, [])
<span class="line-number">288</span>                ]
<span class="line-number">289</span>                enums[name] = Enum(name=enum_data.get(&quot;name&quot;, name), values=values)
<span class="line-number">290</span>            else:
<span class="line-number">291</span><span class="uncovered">                enums[name] = enum_data</span>
<span class="line-number">292</span>
<span class="line-number">293</span>        # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">294</span>
<span class="line-number">295</span>        # Convert include_relations back to IncludeRelation objects
<span class="line-number">296</span>        include_relations_data = data.get(&quot;include_relations&quot;, [])
<span class="line-number">297</span>        include_relations = [
<span class="line-number">298</span>            IncludeRelation(**rel) if isinstance(rel, dict) else rel
<span class="line-number">299</span>            for rel in include_relations_data
<span class="line-number">300</span>        ]
<span class="line-number">301</span>
<span class="line-number">302</span>        # Convert unions back to Union objects
<span class="line-number">303</span>        unions_data = data.get(&quot;unions&quot;, {})
<span class="line-number">304</span>        unions = {}
<span class="line-number">305</span>        for name, union_data in unions_data.items():
<span class="line-number">306</span>            if isinstance(union_data, dict):
<span class="line-number">307</span>                fields = [
<span class="line-number">308</span>                    Field(**field) if isinstance(field, dict) else field
<span class="line-number">309</span>                    for field in union_data.get(&quot;fields&quot;, [])
<span class="line-number">310</span>                ]
<span class="line-number">311</span>                unions[name] = Union(
<span class="line-number">312</span>                    name=union_data.get(&quot;name&quot;, name),
<span class="line-number">313</span>                    fields=fields,
<span class="line-number">314</span>                    tag_name=union_data.get(&quot;tag_name&quot;, &quot;&quot;),
<span class="line-number">315</span>                    uses=union_data.get(&quot;uses&quot;, []),
<span class="line-number">316</span>                )
<span class="line-number">317</span>            else:
<span class="line-number">318</span><span class="uncovered">                unions[name] = union_data</span>
<span class="line-number">319</span>
<span class="line-number">320</span>        # Convert aliases back to Alias objects
<span class="line-number">321</span>        aliases_data = data.get(&quot;aliases&quot;, {})
<span class="line-number">322</span>        aliases = {}
<span class="line-number">323</span>        for name, alias_data in aliases_data.items():
<span class="line-number">324</span>            if isinstance(alias_data, dict):
<span class="line-number">325</span>                aliases[name] = Alias(
<span class="line-number">326</span>                    name=alias_data.get(&quot;name&quot;, name),
<span class="line-number">327</span>                    original_type=alias_data.get(&quot;original_type&quot;, &quot;&quot;),
<span class="line-number">328</span>                    uses=alias_data.get(&quot;uses&quot;, []),
<span class="line-number">329</span>                )
<span class="line-number">330</span>            else:
<span class="line-number">331</span>                # Handle legacy format where aliases was Dict[str, str]
<span class="line-number">332</span><span class="uncovered">                aliases[name] = Alias(name=name, original_type=alias_data, uses=[])</span>
<span class="line-number">333</span>
<span class="line-number">334</span>        # Create new data dict with converted objects
<span class="line-number">335</span>        new_data = data.copy()
<span class="line-number">336</span>        new_data[&quot;includes&quot;] = includes
<span class="line-number">337</span>        new_data[&quot;globals&quot;] = globals
<span class="line-number">338</span>        new_data[&quot;functions&quot;] = functions
<span class="line-number">339</span>        new_data[&quot;structs&quot;] = structs
<span class="line-number">340</span>        new_data[&quot;enums&quot;] = enums
<span class="line-number">341</span>        new_data[&quot;unions&quot;] = unions
<span class="line-number">342</span>        new_data[&quot;aliases&quot;] = aliases
<span class="line-number">343</span>        new_data[&quot;include_relations&quot;] = include_relations
<span class="line-number">344</span>
<span class="line-number">345</span>        return cls(**new_data)
<span class="line-number">346</span>
<span class="line-number">347</span>    def get_summary(self) -&gt; dict:
<span class="line-number">348</span>        &quot;&quot;&quot;Get a summary of the file contents&quot;&quot;&quot;
<span class="line-number">349</span><span class="uncovered">        return {</span>
<span class="line-number">350</span>            &quot;file_path&quot;: self.file_path,
<span class="line-number">351</span>            &quot;structs_count&quot;: len(self.structs),
<span class="line-number">352</span>            &quot;enums_count&quot;: len(self.enums),
<span class="line-number">353</span>            &quot;functions_count&quot;: len(self.functions),
<span class="line-number">354</span>            &quot;globals_count&quot;: len(self.globals),
<span class="line-number">355</span>            &quot;includes_count&quot;: len(self.includes),
<span class="line-number">356</span>            &quot;macros_count&quot;: len(self.macros),
<span class="line-number">357</span>            &quot;aliases_count&quot;: len(self.aliases),
<span class="line-number">358</span>        }
<span class="line-number">359</span>
<span class="line-number">360</span>
<span class="line-number">361</span>@dataclass
<span class="line-number">362</span>class ProjectModel:
</pre>
<h4>Function: from_dict (lines 242-361)</h4>
<pre>
<span class="line-number">242</span>    def from_dict(cls, data: dict) -&gt; &quot;FileModel&quot;:
<span class="line-number">243</span>        &quot;&quot;&quot;Create from dictionary&quot;&quot;&quot;
<span class="line-number">244</span>        # Convert list back to set
<span class="line-number">245</span>        includes = set(data.get(&quot;includes&quot;, []))
<span class="line-number">246</span>
<span class="line-number">247</span>        # Convert globals back to Field objects
<span class="line-number">248</span>        globals_data = data.get(&quot;globals&quot;, [])
<span class="line-number">249</span>        globals = [Field(**g) if isinstance(g, dict) else g for g in globals_data]
<span class="line-number">250</span>
<span class="line-number">251</span>        # Convert functions back to Function objects
<span class="line-number">252</span>        functions_data = data.get(&quot;functions&quot;, [])
<span class="line-number">253</span>        functions = [
<span class="line-number">254</span>            Function(**f) if isinstance(f, dict) else f for f in functions_data
<span class="line-number">255</span>        ]
<span class="line-number">256</span>
<span class="line-number">257</span>        # Convert structs back to Struct objects
<span class="line-number">258</span>        structs_data = data.get(&quot;structs&quot;, {})
<span class="line-number">259</span>        structs = {}
<span class="line-number">260</span>        for name, struct_data in structs_data.items():
<span class="line-number">261</span>            if isinstance(struct_data, dict):
<span class="line-number">262</span>                fields = [
<span class="line-number">263</span>                    Field(**field) if isinstance(field, dict) else field
<span class="line-number">264</span>                    for field in struct_data.get(&quot;fields&quot;, [])
<span class="line-number">265</span>                ]
<span class="line-number">266</span>                methods = [
<span class="line-number">267</span>                    Function(**method) if isinstance(method, dict) else method
<span class="line-number">268</span>                    for method in struct_data.get(&quot;methods&quot;, [])
<span class="line-number">269</span>                ]
<span class="line-number">270</span>                structs[name] = Struct(
<span class="line-number">271</span>                    name=struct_data.get(&quot;name&quot;, name),
<span class="line-number">272</span>                    fields=fields,
<span class="line-number">273</span>                    methods=methods,
<span class="line-number">274</span>                    tag_name=struct_data.get(&quot;tag_name&quot;, &quot;&quot;),
<span class="line-number">275</span>                    uses=struct_data.get(&quot;uses&quot;, []),
<span class="line-number">276</span>                )
<span class="line-number">277</span>            else:
<span class="line-number">278</span><span class="uncovered">                structs[name] = struct_data</span>
<span class="line-number">279</span>
<span class="line-number">280</span>        # Convert enums back to Enum objects
<span class="line-number">281</span>        enums_data = data.get(&quot;enums&quot;, {})
<span class="line-number">282</span>        enums = {}
<span class="line-number">283</span>        for name, enum_data in enums_data.items():
<span class="line-number">284</span>            if isinstance(enum_data, dict):
<span class="line-number">285</span>                values = [
<span class="line-number">286</span>                    EnumValue(**val) if isinstance(val, dict) else EnumValue(val)
<span class="line-number">287</span>                    for val in enum_data.get(&quot;values&quot;, [])
<span class="line-number">288</span>                ]
<span class="line-number">289</span>                enums[name] = Enum(name=enum_data.get(&quot;name&quot;, name), values=values)
<span class="line-number">290</span>            else:
<span class="line-number">291</span><span class="uncovered">                enums[name] = enum_data</span>
<span class="line-number">292</span>
<span class="line-number">293</span>        # typedef_relations removed - tag names are now in struct/enum/union
<span class="line-number">294</span>
<span class="line-number">295</span>        # Convert include_relations back to IncludeRelation objects
<span class="line-number">296</span>        include_relations_data = data.get(&quot;include_relations&quot;, [])
<span class="line-number">297</span>        include_relations = [
<span class="line-number">298</span>            IncludeRelation(**rel) if isinstance(rel, dict) else rel
<span class="line-number">299</span>            for rel in include_relations_data
<span class="line-number">300</span>        ]
<span class="line-number">301</span>
<span class="line-number">302</span>        # Convert unions back to Union objects
<span class="line-number">303</span>        unions_data = data.get(&quot;unions&quot;, {})
<span class="line-number">304</span>        unions = {}
<span class="line-number">305</span>        for name, union_data in unions_data.items():
<span class="line-number">306</span>            if isinstance(union_data, dict):
<span class="line-number">307</span>                fields = [
<span class="line-number">308</span>                    Field(**field) if isinstance(field, dict) else field
<span class="line-number">309</span>                    for field in union_data.get(&quot;fields&quot;, [])
<span class="line-number">310</span>                ]
<span class="line-number">311</span>                unions[name] = Union(
<span class="line-number">312</span>                    name=union_data.get(&quot;name&quot;, name),
<span class="line-number">313</span>                    fields=fields,
<span class="line-number">314</span>                    tag_name=union_data.get(&quot;tag_name&quot;, &quot;&quot;),
<span class="line-number">315</span>                    uses=union_data.get(&quot;uses&quot;, []),
<span class="line-number">316</span>                )
<span class="line-number">317</span>            else:
<span class="line-number">318</span><span class="uncovered">                unions[name] = union_data</span>
<span class="line-number">319</span>
<span class="line-number">320</span>        # Convert aliases back to Alias objects
<span class="line-number">321</span>        aliases_data = data.get(&quot;aliases&quot;, {})
<span class="line-number">322</span>        aliases = {}
<span class="line-number">323</span>        for name, alias_data in aliases_data.items():
<span class="line-number">324</span>            if isinstance(alias_data, dict):
<span class="line-number">325</span>                aliases[name] = Alias(
<span class="line-number">326</span>                    name=alias_data.get(&quot;name&quot;, name),
<span class="line-number">327</span>                    original_type=alias_data.get(&quot;original_type&quot;, &quot;&quot;),
<span class="line-number">328</span>                    uses=alias_data.get(&quot;uses&quot;, []),
<span class="line-number">329</span>                )
<span class="line-number">330</span>            else:
<span class="line-number">331</span>                # Handle legacy format where aliases was Dict[str, str]
<span class="line-number">332</span><span class="uncovered">                aliases[name] = Alias(name=name, original_type=alias_data, uses=[])</span>
<span class="line-number">333</span>
<span class="line-number">334</span>        # Create new data dict with converted objects
<span class="line-number">335</span>        new_data = data.copy()
<span class="line-number">336</span>        new_data[&quot;includes&quot;] = includes
<span class="line-number">337</span>        new_data[&quot;globals&quot;] = globals
<span class="line-number">338</span>        new_data[&quot;functions&quot;] = functions
<span class="line-number">339</span>        new_data[&quot;structs&quot;] = structs
<span class="line-number">340</span>        new_data[&quot;enums&quot;] = enums
<span class="line-number">341</span>        new_data[&quot;unions&quot;] = unions
<span class="line-number">342</span>        new_data[&quot;aliases&quot;] = aliases
<span class="line-number">343</span>        new_data[&quot;include_relations&quot;] = include_relations
<span class="line-number">344</span>
<span class="line-number">345</span>        return cls(**new_data)
<span class="line-number">346</span>
<span class="line-number">347</span>    def get_summary(self) -&gt; dict:
<span class="line-number">348</span>        &quot;&quot;&quot;Get a summary of the file contents&quot;&quot;&quot;
<span class="line-number">349</span><span class="uncovered">        return {</span>
<span class="line-number">350</span>            &quot;file_path&quot;: self.file_path,
<span class="line-number">351</span>            &quot;structs_count&quot;: len(self.structs),
<span class="line-number">352</span>            &quot;enums_count&quot;: len(self.enums),
<span class="line-number">353</span>            &quot;functions_count&quot;: len(self.functions),
<span class="line-number">354</span>            &quot;globals_count&quot;: len(self.globals),
<span class="line-number">355</span>            &quot;includes_count&quot;: len(self.includes),
<span class="line-number">356</span>            &quot;macros_count&quot;: len(self.macros),
<span class="line-number">357</span>            &quot;aliases_count&quot;: len(self.aliases),
<span class="line-number">358</span>        }
<span class="line-number">359</span>
<span class="line-number">360</span>
<span class="line-number">361</span>@dataclass
</pre>
<h4>Function: get_summary (lines 347-360)</h4>
<pre>
<span class="line-number">347</span>    def get_summary(self) -&gt; dict:
<span class="line-number">348</span>        &quot;&quot;&quot;Get a summary of the file contents&quot;&quot;&quot;
<span class="line-number">349</span><span class="uncovered">        return {</span>
<span class="line-number">350</span>            &quot;file_path&quot;: self.file_path,
<span class="line-number">351</span>            &quot;structs_count&quot;: len(self.structs),
<span class="line-number">352</span>            &quot;enums_count&quot;: len(self.enums),
<span class="line-number">353</span>            &quot;functions_count&quot;: len(self.functions),
<span class="line-number">354</span>            &quot;globals_count&quot;: len(self.globals),
<span class="line-number">355</span>            &quot;includes_count&quot;: len(self.includes),
<span class="line-number">356</span>            &quot;macros_count&quot;: len(self.macros),
<span class="line-number">357</span>            &quot;aliases_count&quot;: len(self.aliases),
<span class="line-number">358</span>        }
<span class="line-number">359</span>
<span class="line-number">360</span>
</pre>
<h4>Function: __post_init__ (lines 369-532)</h4>
<pre>
<span class="line-number">369</span>    def __post_init__(self):
<span class="line-number">370</span>        &quot;&quot;&quot;Validate project model data after initialization&quot;&quot;&quot;
<span class="line-number">371</span>        if not self.project_name or not isinstance(self.project_name, str):
<span class="line-number">372</span><span class="uncovered">            raise ValueError(&quot;Project name must be a non-empty string&quot;)</span>
<span class="line-number">373</span>        if not self.project_root or not isinstance(self.project_root, str):
<span class="line-number">374</span><span class="uncovered">            raise ValueError(&quot;Project root must be a non-empty string&quot;)</span>
<span class="line-number">375</span>
<span class="line-number">376</span>    def save(self, file_path: str) -&gt; None:
<span class="line-number">377</span>        &quot;&quot;&quot;Save model to JSON file&quot;&quot;&quot;
<span class="line-number">378</span>        data = {
<span class="line-number">379</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">380</span>            &quot;project_root&quot;: self.project_root,
<span class="line-number">381</span>            &quot;files&quot;: {
<span class="line-number">382</span>                path: file_model.to_dict()
<span class="line-number">383</span>                for path, file_model in sorted(self.files.items())
<span class="line-number">384</span>            },
<span class="line-number">385</span>        }
<span class="line-number">386</span>
<span class="line-number">387</span>        try:
<span class="line-number">388</span>            with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">389</span>                json.dump(data, f, indent=2, ensure_ascii=False, sort_keys=True)
<span class="line-number">390</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">391</span><span class="uncovered">            raise ValueError(f&quot;Failed to save model to {file_path}: {e}&quot;) from e</span>
<span class="line-number">392</span>
<span class="line-number">393</span>    @classmethod
<span class="line-number">394</span>    def from_dict(cls, data: dict) -&gt; &quot;ProjectModel&quot;:
<span class="line-number">395</span>        &quot;&quot;&quot;Create from dictionary&quot;&quot;&quot;
<span class="line-number">396</span>        files = {
<span class="line-number">397</span>            path: FileModel.from_dict(file_data)
<span class="line-number">398</span>            for path, file_data in data.get(&quot;files&quot;, {}).items()
<span class="line-number">399</span>        }
<span class="line-number">400</span>
<span class="line-number">401</span>        return cls(
<span class="line-number">402</span>            project_name=data.get(&quot;project_name&quot;, &quot;Unknown&quot;),
<span class="line-number">403</span>            project_root=data.get(&quot;project_root&quot;, &quot;&quot;),
<span class="line-number">404</span>            files=files,
<span class="line-number">405</span>        )
<span class="line-number">406</span>
<span class="line-number">407</span>    @classmethod
<span class="line-number">408</span>    def load(cls, file_path: str) -&gt; &quot;ProjectModel&quot;:
<span class="line-number">409</span>        &quot;&quot;&quot;Load model from JSON file&quot;&quot;&quot;
<span class="line-number">410</span>        try:
<span class="line-number">411</span>            with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">412</span>                data = json.load(f)
<span class="line-number">413</span>            return cls.from_dict(data)
<span class="line-number">414</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">415</span><span class="uncovered">            raise ValueError(f&quot;Failed to load model from {file_path}: {e}&quot;) from e</span>
<span class="line-number">416</span>
<span class="line-number">417</span>    def get_summary(self) -&gt; dict:
<span class="line-number">418</span>        &quot;&quot;&quot;Get a summary of the project&quot;&quot;&quot;
<span class="line-number">419</span><span class="uncovered">        total_structs = sum(len(f.structs) for f in self.files.values())</span>
<span class="line-number">420</span><span class="uncovered">        total_enums = sum(len(f.enums) for f in self.files.values())</span>
<span class="line-number">421</span><span class="uncovered">        total_functions = sum(len(f.functions) for f in self.files.values())</span>
<span class="line-number">422</span><span class="uncovered">        total_globals = sum(len(f.globals) for f in self.files.values())</span>
<span class="line-number">423</span>
<span class="line-number">424</span><span class="uncovered">        return {</span>
<span class="line-number">425</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">426</span>            &quot;project_root&quot;: self.project_root,
<span class="line-number">427</span>            &quot;files_count&quot;: len(self.files),
<span class="line-number">428</span>            &quot;total_structs&quot;: total_structs,
<span class="line-number">429</span>            &quot;total_enums&quot;: total_enums,
<span class="line-number">430</span>            &quot;total_functions&quot;: total_functions,
<span class="line-number">431</span>            &quot;total_globals&quot;: total_globals,
<span class="line-number">432</span>        }
<span class="line-number">433</span>
<span class="line-number">434</span>    def update_uses_fields(self):
<span class="line-number">435</span>        &quot;&quot;&quot;Update all uses fields across the entire project model&quot;&quot;&quot;
<span class="line-number">436</span>        # Collect all available type names from the entire project
<span class="line-number">437</span>        available_types = set()
<span class="line-number">438</span>        for file_model in self.files.values():
<span class="line-number">439</span>            available_types.update(file_model.structs.keys())
<span class="line-number">440</span>            available_types.update(file_model.enums.keys())
<span class="line-number">441</span>            available_types.update(file_model.unions.keys())
<span class="line-number">442</span>            available_types.update(file_model.aliases.keys())
<span class="line-number">443</span>
<span class="line-number">444</span>        # Update uses fields for all structures in all files
<span class="line-number">445</span>        for file_model in self.files.values():
<span class="line-number">446</span>            # Update struct uses
<span class="line-number">447</span>            for struct in file_model.structs.values():
<span class="line-number">448</span>                filtered_uses = []
<span class="line-number">449</span>                for struct_field in struct.fields:
<span class="line-number">450</span>                    field_uses = self._extract_non_primitive_types(
<span class="line-number">451</span>                        struct_field.type, available_types
<span class="line-number">452</span>                    )
<span class="line-number">453</span>                    filtered_uses.extend(field_uses)
<span class="line-number">454</span>                struct.uses = list(set(filtered_uses))
<span class="line-number">455</span>
<span class="line-number">456</span>            # Update union uses
<span class="line-number">457</span>            for union in file_model.unions.values():
<span class="line-number">458</span>                filtered_uses = []
<span class="line-number">459</span>                for union_field in union.fields:
<span class="line-number">460</span>                    field_uses = self._extract_non_primitive_types(
<span class="line-number">461</span>                        union_field.type, available_types
<span class="line-number">462</span>                    )
<span class="line-number">463</span>                    filtered_uses.extend(field_uses)
<span class="line-number">464</span>                union.uses = list(set(filtered_uses))
<span class="line-number">465</span>
<span class="line-number">466</span>            # Update alias uses
<span class="line-number">467</span>            for alias in file_model.aliases.values():
<span class="line-number">468</span>                alias.uses = self._extract_non_primitive_types(
<span class="line-number">469</span>                    alias.original_type, available_types
<span class="line-number">470</span>                )
<span class="line-number">471</span>                # Remove the alias name from its own uses list
<span class="line-number">472</span>                if alias.name in alias.uses:
<span class="line-number">473</span>                    alias.uses.remove(alias.name)
<span class="line-number">474</span>
<span class="line-number">475</span>    def _extract_non_primitive_types(self, type_str: str, available_types: set) -&gt; list:
<span class="line-number">476</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">477</span>        # Define primitive types
<span class="line-number">478</span>        primitive_types = {
<span class="line-number">479</span>            &quot;void&quot;,
<span class="line-number">480</span>            &quot;char&quot;,
<span class="line-number">481</span>            &quot;short&quot;,
<span class="line-number">482</span>            &quot;int&quot;,
<span class="line-number">483</span>            &quot;long&quot;,
<span class="line-number">484</span>            &quot;float&quot;,
<span class="line-number">485</span>            &quot;double&quot;,
<span class="line-number">486</span>            &quot;signed&quot;,
<span class="line-number">487</span>            &quot;unsigned&quot;,
<span class="line-number">488</span>            &quot;const&quot;,
<span class="line-number">489</span>            &quot;volatile&quot;,
<span class="line-number">490</span>            &quot;static&quot;,
<span class="line-number">491</span>            &quot;extern&quot;,
<span class="line-number">492</span>            &quot;auto&quot;,
<span class="line-number">493</span>            &quot;register&quot;,
<span class="line-number">494</span>            &quot;inline&quot;,
<span class="line-number">495</span>            &quot;restrict&quot;,
<span class="line-number">496</span>            &quot;size_t&quot;,
<span class="line-number">497</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">498</span>            &quot;int8_t&quot;,
<span class="line-number">499</span>            &quot;int16_t&quot;,
<span class="line-number">500</span>            &quot;int32_t&quot;,
<span class="line-number">501</span>            &quot;int64_t&quot;,
<span class="line-number">502</span>            &quot;uint8_t&quot;,
<span class="line-number">503</span>            &quot;uint16_t&quot;,
<span class="line-number">504</span>            &quot;uint32_t&quot;,
<span class="line-number">505</span>            &quot;uint64_t&quot;,
<span class="line-number">506</span>            &quot;intptr_t&quot;,
<span class="line-number">507</span>            &quot;uintptr_t&quot;,
<span class="line-number">508</span>            &quot;bool&quot;,
<span class="line-number">509</span>            &quot;true&quot;,
<span class="line-number">510</span>            &quot;false&quot;,
<span class="line-number">511</span>            &quot;NULL&quot;,
<span class="line-number">512</span>            &quot;nullptr&quot;,
<span class="line-number">513</span>        }
<span class="line-number">514</span>
<span class="line-number">515</span>        # Remove common C keywords and operators
<span class="line-number">516</span>        import re
<span class="line-number">517</span>
<span class="line-number">518</span>        # Split by common delimiters and operators
<span class="line-number">519</span>        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)
<span class="line-number">520</span>
<span class="line-number">521</span>        # Extract potential type names that exist in available_types
<span class="line-number">522</span>        types = []
<span class="line-number">523</span>        for part in parts:
<span class="line-number">524</span>            part = part.strip()
<span class="line-number">525</span>            if part and len(part) &gt; 1 and part not in primitive_types:
<span class="line-number">526</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">527</span>                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):
<span class="line-number">528</span>                    # Only include if it exists in available_types
<span class="line-number">529</span>                    if part in available_types:
<span class="line-number">530</span>                        types.append(part)
<span class="line-number">531</span>
<span class="line-number">532</span>        return list(set(types))  # Remove duplicates
</pre>
<h4>Function: save (lines 376-392)</h4>
<pre>
<span class="line-number">376</span>    def save(self, file_path: str) -&gt; None:
<span class="line-number">377</span>        &quot;&quot;&quot;Save model to JSON file&quot;&quot;&quot;
<span class="line-number">378</span>        data = {
<span class="line-number">379</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">380</span>            &quot;project_root&quot;: self.project_root,
<span class="line-number">381</span>            &quot;files&quot;: {
<span class="line-number">382</span>                path: file_model.to_dict()
<span class="line-number">383</span>                for path, file_model in sorted(self.files.items())
<span class="line-number">384</span>            },
<span class="line-number">385</span>        }
<span class="line-number">386</span>
<span class="line-number">387</span>        try:
<span class="line-number">388</span>            with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">389</span>                json.dump(data, f, indent=2, ensure_ascii=False, sort_keys=True)
<span class="line-number">390</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">391</span><span class="uncovered">            raise ValueError(f&quot;Failed to save model to {file_path}: {e}&quot;) from e</span>
<span class="line-number">392</span>
</pre>
<h4>Function: load (lines 408-532)</h4>
<pre>
<span class="line-number">408</span>    def load(cls, file_path: str) -&gt; &quot;ProjectModel&quot;:
<span class="line-number">409</span>        &quot;&quot;&quot;Load model from JSON file&quot;&quot;&quot;
<span class="line-number">410</span>        try:
<span class="line-number">411</span>            with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
<span class="line-number">412</span>                data = json.load(f)
<span class="line-number">413</span>            return cls.from_dict(data)
<span class="line-number">414</span><span class="uncovered">        except Exception as e:</span>
<span class="line-number">415</span><span class="uncovered">            raise ValueError(f&quot;Failed to load model from {file_path}: {e}&quot;) from e</span>
<span class="line-number">416</span>
<span class="line-number">417</span>    def get_summary(self) -&gt; dict:
<span class="line-number">418</span>        &quot;&quot;&quot;Get a summary of the project&quot;&quot;&quot;
<span class="line-number">419</span><span class="uncovered">        total_structs = sum(len(f.structs) for f in self.files.values())</span>
<span class="line-number">420</span><span class="uncovered">        total_enums = sum(len(f.enums) for f in self.files.values())</span>
<span class="line-number">421</span><span class="uncovered">        total_functions = sum(len(f.functions) for f in self.files.values())</span>
<span class="line-number">422</span><span class="uncovered">        total_globals = sum(len(f.globals) for f in self.files.values())</span>
<span class="line-number">423</span>
<span class="line-number">424</span><span class="uncovered">        return {</span>
<span class="line-number">425</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">426</span>            &quot;project_root&quot;: self.project_root,
<span class="line-number">427</span>            &quot;files_count&quot;: len(self.files),
<span class="line-number">428</span>            &quot;total_structs&quot;: total_structs,
<span class="line-number">429</span>            &quot;total_enums&quot;: total_enums,
<span class="line-number">430</span>            &quot;total_functions&quot;: total_functions,
<span class="line-number">431</span>            &quot;total_globals&quot;: total_globals,
<span class="line-number">432</span>        }
<span class="line-number">433</span>
<span class="line-number">434</span>    def update_uses_fields(self):
<span class="line-number">435</span>        &quot;&quot;&quot;Update all uses fields across the entire project model&quot;&quot;&quot;
<span class="line-number">436</span>        # Collect all available type names from the entire project
<span class="line-number">437</span>        available_types = set()
<span class="line-number">438</span>        for file_model in self.files.values():
<span class="line-number">439</span>            available_types.update(file_model.structs.keys())
<span class="line-number">440</span>            available_types.update(file_model.enums.keys())
<span class="line-number">441</span>            available_types.update(file_model.unions.keys())
<span class="line-number">442</span>            available_types.update(file_model.aliases.keys())
<span class="line-number">443</span>
<span class="line-number">444</span>        # Update uses fields for all structures in all files
<span class="line-number">445</span>        for file_model in self.files.values():
<span class="line-number">446</span>            # Update struct uses
<span class="line-number">447</span>            for struct in file_model.structs.values():
<span class="line-number">448</span>                filtered_uses = []
<span class="line-number">449</span>                for struct_field in struct.fields:
<span class="line-number">450</span>                    field_uses = self._extract_non_primitive_types(
<span class="line-number">451</span>                        struct_field.type, available_types
<span class="line-number">452</span>                    )
<span class="line-number">453</span>                    filtered_uses.extend(field_uses)
<span class="line-number">454</span>                struct.uses = list(set(filtered_uses))
<span class="line-number">455</span>
<span class="line-number">456</span>            # Update union uses
<span class="line-number">457</span>            for union in file_model.unions.values():
<span class="line-number">458</span>                filtered_uses = []
<span class="line-number">459</span>                for union_field in union.fields:
<span class="line-number">460</span>                    field_uses = self._extract_non_primitive_types(
<span class="line-number">461</span>                        union_field.type, available_types
<span class="line-number">462</span>                    )
<span class="line-number">463</span>                    filtered_uses.extend(field_uses)
<span class="line-number">464</span>                union.uses = list(set(filtered_uses))
<span class="line-number">465</span>
<span class="line-number">466</span>            # Update alias uses
<span class="line-number">467</span>            for alias in file_model.aliases.values():
<span class="line-number">468</span>                alias.uses = self._extract_non_primitive_types(
<span class="line-number">469</span>                    alias.original_type, available_types
<span class="line-number">470</span>                )
<span class="line-number">471</span>                # Remove the alias name from its own uses list
<span class="line-number">472</span>                if alias.name in alias.uses:
<span class="line-number">473</span>                    alias.uses.remove(alias.name)
<span class="line-number">474</span>
<span class="line-number">475</span>    def _extract_non_primitive_types(self, type_str: str, available_types: set) -&gt; list:
<span class="line-number">476</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">477</span>        # Define primitive types
<span class="line-number">478</span>        primitive_types = {
<span class="line-number">479</span>            &quot;void&quot;,
<span class="line-number">480</span>            &quot;char&quot;,
<span class="line-number">481</span>            &quot;short&quot;,
<span class="line-number">482</span>            &quot;int&quot;,
<span class="line-number">483</span>            &quot;long&quot;,
<span class="line-number">484</span>            &quot;float&quot;,
<span class="line-number">485</span>            &quot;double&quot;,
<span class="line-number">486</span>            &quot;signed&quot;,
<span class="line-number">487</span>            &quot;unsigned&quot;,
<span class="line-number">488</span>            &quot;const&quot;,
<span class="line-number">489</span>            &quot;volatile&quot;,
<span class="line-number">490</span>            &quot;static&quot;,
<span class="line-number">491</span>            &quot;extern&quot;,
<span class="line-number">492</span>            &quot;auto&quot;,
<span class="line-number">493</span>            &quot;register&quot;,
<span class="line-number">494</span>            &quot;inline&quot;,
<span class="line-number">495</span>            &quot;restrict&quot;,
<span class="line-number">496</span>            &quot;size_t&quot;,
<span class="line-number">497</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">498</span>            &quot;int8_t&quot;,
<span class="line-number">499</span>            &quot;int16_t&quot;,
<span class="line-number">500</span>            &quot;int32_t&quot;,
<span class="line-number">501</span>            &quot;int64_t&quot;,
<span class="line-number">502</span>            &quot;uint8_t&quot;,
<span class="line-number">503</span>            &quot;uint16_t&quot;,
<span class="line-number">504</span>            &quot;uint32_t&quot;,
<span class="line-number">505</span>            &quot;uint64_t&quot;,
<span class="line-number">506</span>            &quot;intptr_t&quot;,
<span class="line-number">507</span>            &quot;uintptr_t&quot;,
<span class="line-number">508</span>            &quot;bool&quot;,
<span class="line-number">509</span>            &quot;true&quot;,
<span class="line-number">510</span>            &quot;false&quot;,
<span class="line-number">511</span>            &quot;NULL&quot;,
<span class="line-number">512</span>            &quot;nullptr&quot;,
<span class="line-number">513</span>        }
<span class="line-number">514</span>
<span class="line-number">515</span>        # Remove common C keywords and operators
<span class="line-number">516</span>        import re
<span class="line-number">517</span>
<span class="line-number">518</span>        # Split by common delimiters and operators
<span class="line-number">519</span>        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)
<span class="line-number">520</span>
<span class="line-number">521</span>        # Extract potential type names that exist in available_types
<span class="line-number">522</span>        types = []
<span class="line-number">523</span>        for part in parts:
<span class="line-number">524</span>            part = part.strip()
<span class="line-number">525</span>            if part and len(part) &gt; 1 and part not in primitive_types:
<span class="line-number">526</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">527</span>                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):
<span class="line-number">528</span>                    # Only include if it exists in available_types
<span class="line-number">529</span>                    if part in available_types:
<span class="line-number">530</span>                        types.append(part)
<span class="line-number">531</span>
<span class="line-number">532</span>        return list(set(types))  # Remove duplicates
</pre>
<h4>Function: get_summary (lines 417-532)</h4>
<pre>
<span class="line-number">417</span>    def get_summary(self) -&gt; dict:
<span class="line-number">418</span>        &quot;&quot;&quot;Get a summary of the project&quot;&quot;&quot;
<span class="line-number">419</span><span class="uncovered">        total_structs = sum(len(f.structs) for f in self.files.values())</span>
<span class="line-number">420</span><span class="uncovered">        total_enums = sum(len(f.enums) for f in self.files.values())</span>
<span class="line-number">421</span><span class="uncovered">        total_functions = sum(len(f.functions) for f in self.files.values())</span>
<span class="line-number">422</span><span class="uncovered">        total_globals = sum(len(f.globals) for f in self.files.values())</span>
<span class="line-number">423</span>
<span class="line-number">424</span><span class="uncovered">        return {</span>
<span class="line-number">425</span>            &quot;project_name&quot;: self.project_name,
<span class="line-number">426</span>            &quot;project_root&quot;: self.project_root,
<span class="line-number">427</span>            &quot;files_count&quot;: len(self.files),
<span class="line-number">428</span>            &quot;total_structs&quot;: total_structs,
<span class="line-number">429</span>            &quot;total_enums&quot;: total_enums,
<span class="line-number">430</span>            &quot;total_functions&quot;: total_functions,
<span class="line-number">431</span>            &quot;total_globals&quot;: total_globals,
<span class="line-number">432</span>        }
<span class="line-number">433</span>
<span class="line-number">434</span>    def update_uses_fields(self):
<span class="line-number">435</span>        &quot;&quot;&quot;Update all uses fields across the entire project model&quot;&quot;&quot;
<span class="line-number">436</span>        # Collect all available type names from the entire project
<span class="line-number">437</span>        available_types = set()
<span class="line-number">438</span>        for file_model in self.files.values():
<span class="line-number">439</span>            available_types.update(file_model.structs.keys())
<span class="line-number">440</span>            available_types.update(file_model.enums.keys())
<span class="line-number">441</span>            available_types.update(file_model.unions.keys())
<span class="line-number">442</span>            available_types.update(file_model.aliases.keys())
<span class="line-number">443</span>
<span class="line-number">444</span>        # Update uses fields for all structures in all files
<span class="line-number">445</span>        for file_model in self.files.values():
<span class="line-number">446</span>            # Update struct uses
<span class="line-number">447</span>            for struct in file_model.structs.values():
<span class="line-number">448</span>                filtered_uses = []
<span class="line-number">449</span>                for struct_field in struct.fields:
<span class="line-number">450</span>                    field_uses = self._extract_non_primitive_types(
<span class="line-number">451</span>                        struct_field.type, available_types
<span class="line-number">452</span>                    )
<span class="line-number">453</span>                    filtered_uses.extend(field_uses)
<span class="line-number">454</span>                struct.uses = list(set(filtered_uses))
<span class="line-number">455</span>
<span class="line-number">456</span>            # Update union uses
<span class="line-number">457</span>            for union in file_model.unions.values():
<span class="line-number">458</span>                filtered_uses = []
<span class="line-number">459</span>                for union_field in union.fields:
<span class="line-number">460</span>                    field_uses = self._extract_non_primitive_types(
<span class="line-number">461</span>                        union_field.type, available_types
<span class="line-number">462</span>                    )
<span class="line-number">463</span>                    filtered_uses.extend(field_uses)
<span class="line-number">464</span>                union.uses = list(set(filtered_uses))
<span class="line-number">465</span>
<span class="line-number">466</span>            # Update alias uses
<span class="line-number">467</span>            for alias in file_model.aliases.values():
<span class="line-number">468</span>                alias.uses = self._extract_non_primitive_types(
<span class="line-number">469</span>                    alias.original_type, available_types
<span class="line-number">470</span>                )
<span class="line-number">471</span>                # Remove the alias name from its own uses list
<span class="line-number">472</span>                if alias.name in alias.uses:
<span class="line-number">473</span>                    alias.uses.remove(alias.name)
<span class="line-number">474</span>
<span class="line-number">475</span>    def _extract_non_primitive_types(self, type_str: str, available_types: set) -&gt; list:
<span class="line-number">476</span>        &quot;&quot;&quot;Extract non-primitive type names from a type string that exist in available_types&quot;&quot;&quot;
<span class="line-number">477</span>        # Define primitive types
<span class="line-number">478</span>        primitive_types = {
<span class="line-number">479</span>            &quot;void&quot;,
<span class="line-number">480</span>            &quot;char&quot;,
<span class="line-number">481</span>            &quot;short&quot;,
<span class="line-number">482</span>            &quot;int&quot;,
<span class="line-number">483</span>            &quot;long&quot;,
<span class="line-number">484</span>            &quot;float&quot;,
<span class="line-number">485</span>            &quot;double&quot;,
<span class="line-number">486</span>            &quot;signed&quot;,
<span class="line-number">487</span>            &quot;unsigned&quot;,
<span class="line-number">488</span>            &quot;const&quot;,
<span class="line-number">489</span>            &quot;volatile&quot;,
<span class="line-number">490</span>            &quot;static&quot;,
<span class="line-number">491</span>            &quot;extern&quot;,
<span class="line-number">492</span>            &quot;auto&quot;,
<span class="line-number">493</span>            &quot;register&quot;,
<span class="line-number">494</span>            &quot;inline&quot;,
<span class="line-number">495</span>            &quot;restrict&quot;,
<span class="line-number">496</span>            &quot;size_t&quot;,
<span class="line-number">497</span>            &quot;ptrdiff_t&quot;,
<span class="line-number">498</span>            &quot;int8_t&quot;,
<span class="line-number">499</span>            &quot;int16_t&quot;,
<span class="line-number">500</span>            &quot;int32_t&quot;,
<span class="line-number">501</span>            &quot;int64_t&quot;,
<span class="line-number">502</span>            &quot;uint8_t&quot;,
<span class="line-number">503</span>            &quot;uint16_t&quot;,
<span class="line-number">504</span>            &quot;uint32_t&quot;,
<span class="line-number">505</span>            &quot;uint64_t&quot;,
<span class="line-number">506</span>            &quot;intptr_t&quot;,
<span class="line-number">507</span>            &quot;uintptr_t&quot;,
<span class="line-number">508</span>            &quot;bool&quot;,
<span class="line-number">509</span>            &quot;true&quot;,
<span class="line-number">510</span>            &quot;false&quot;,
<span class="line-number">511</span>            &quot;NULL&quot;,
<span class="line-number">512</span>            &quot;nullptr&quot;,
<span class="line-number">513</span>        }
<span class="line-number">514</span>
<span class="line-number">515</span>        # Remove common C keywords and operators
<span class="line-number">516</span>        import re
<span class="line-number">517</span>
<span class="line-number">518</span>        # Split by common delimiters and operators
<span class="line-number">519</span>        parts = re.split(r&quot;[\[\]\(\)\{\}\s\*&amp;,;]&quot;, type_str)
<span class="line-number">520</span>
<span class="line-number">521</span>        # Extract potential type names that exist in available_types
<span class="line-number">522</span>        types = []
<span class="line-number">523</span>        for part in parts:
<span class="line-number">524</span>            part = part.strip()
<span class="line-number">525</span>            if part and len(part) &gt; 1 and part not in primitive_types:
<span class="line-number">526</span>                # Check if it looks like a type name (starts with letter, contains letters/numbers/underscores)
<span class="line-number">527</span>                if re.match(r&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;, part):
<span class="line-number">528</span>                    # Only include if it exists in available_types
<span class="line-number">529</span>                    if part in available_types:
<span class="line-number">530</span>                        types.append(part)
<span class="line-number">531</span>
<span class="line-number">532</span>        return list(set(types))  # Remove duplicates
</pre>
</div>
<div class="file-section">
<div class="file-header">
/home/runner/work/generator_project/generator_project/c_to_plantuml/preprocessor.py - 65.65% coverage (193/294 lines)
</div>
<h4>Function: __init__ (lines 45-491)</h4>
<pre>
<span class="line-number"> 45</span>    def __init__(self):
<span class="line-number"> 46</span>        self.logger = logging.getLogger(__name__)
<span class="line-number"> 47</span>        self.defined_macros: Set[str] = set()
<span class="line-number"> 48</span>        self.macro_values: Dict[str, str] = {}
<span class="line-number"> 49</span>        self.blocks: List[PreprocessorBlock] = []
<span class="line-number"> 50</span>        self.current_block_stack: List[PreprocessorBlock] = []
<span class="line-number"> 51</span>
<span class="line-number"> 52</span>    def add_define(self, name: str, value: str = &quot;&quot;):
<span class="line-number"> 53</span>        &quot;&quot;&quot;Add a defined macro.&quot;&quot;&quot;
<span class="line-number"> 54</span><span class="uncovered">        self.defined_macros.add(name)</span>
<span class="line-number"> 55</span><span class="uncovered">        if value:</span>
<span class="line-number"> 56</span><span class="uncovered">            self.macro_values[name] = value</span>
<span class="line-number"> 57</span>
<span class="line-number"> 58</span>    def add_undef(self, name: str):
<span class="line-number"> 59</span>        &quot;&quot;&quot;Remove a defined macro.&quot;&quot;&quot;
<span class="line-number"> 60</span><span class="uncovered">        self.defined_macros.discard(name)</span>
<span class="line-number"> 61</span><span class="uncovered">        self.macro_values.pop(name, None)</span>
<span class="line-number"> 62</span>
<span class="line-number"> 63</span>    def is_defined(self, name: str) -&gt; bool:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Check if a macro is defined.&quot;&quot;&quot;
<span class="line-number"> 65</span>        return name in self.defined_macros
<span class="line-number"> 66</span>
<span class="line-number"> 67</span>    def get_macro_value(self, name: str) -&gt; str:
<span class="line-number"> 68</span>        &quot;&quot;&quot;Get the value of a defined macro.&quot;&quot;&quot;
<span class="line-number"> 69</span><span class="uncovered">        return self.macro_values.get(name, &quot;&quot;)</span>
<span class="line-number"> 70</span>
<span class="line-number"> 71</span>    def evaluate_condition(self, condition: str) -&gt; bool:
<span class="line-number"> 72</span>        &quot;&quot;&quot;Evaluate a preprocessor condition.&quot;&quot;&quot;
<span class="line-number"> 73</span>        if not condition.strip():
<span class="line-number"> 74</span>            return True
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Handle defined() operator
<span class="line-number"> 77</span>        condition = self._expand_defined_operator(condition)
<span class="line-number"> 78</span>
<span class="line-number"> 79</span>        # Handle macro expansions
<span class="line-number"> 80</span>        condition = self._expand_macros(condition)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>        # Simple evaluation for common patterns
<span class="line-number"> 83</span>        return self._evaluate_simple_expression(condition)
<span class="line-number"> 84</span>
<span class="line-number"> 85</span>    def _expand_defined_operator(self, condition: str) -&gt; str:
<span class="line-number"> 86</span>        &quot;&quot;&quot;Expand defined() operators in the condition.&quot;&quot;&quot;
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        def replace_defined(match):
<span class="line-number"> 89</span>            macro_name = match.group(1)
<span class="line-number"> 90</span>            return &quot;1&quot; if self.is_defined(macro_name) else &quot;0&quot;
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Replace defined(macro) with 1 or 0
<span class="line-number"> 93</span>        condition = re.sub(
<span class="line-number"> 94</span>            r&quot;defined\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\)&quot;, replace_defined, condition
<span class="line-number"> 95</span>        )
<span class="line-number"> 96</span>        return condition
<span class="line-number"> 97</span>
<span class="line-number"> 98</span>    def _expand_macros(self, condition: str) -&gt; str:
<span class="line-number"> 99</span>        &quot;&quot;&quot;Expand macros in the condition.&quot;&quot;&quot;
<span class="line-number">100</span>        # Simple macro expansion for common cases
<span class="line-number">101</span>        for macro_name, macro_value in self.macro_values.items():
<span class="line-number">102</span>            # Replace macro name with its value
<span class="line-number">103</span><span class="uncovered">            pattern = r&quot;\b&quot; + re.escape(macro_name) + r&quot;\b&quot;</span>
<span class="line-number">104</span><span class="uncovered">            condition = re.sub(pattern, macro_value, condition)</span>
<span class="line-number">105</span>        return condition
<span class="line-number">106</span>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
<span class="line-number">121</span>                left, right = condition.split(&quot;==&quot;, 1)
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: add_define (lines 52-491)</h4>
<pre>
<span class="line-number"> 52</span>    def add_define(self, name: str, value: str = &quot;&quot;):
<span class="line-number"> 53</span>        &quot;&quot;&quot;Add a defined macro.&quot;&quot;&quot;
<span class="line-number"> 54</span><span class="uncovered">        self.defined_macros.add(name)</span>
<span class="line-number"> 55</span><span class="uncovered">        if value:</span>
<span class="line-number"> 56</span><span class="uncovered">            self.macro_values[name] = value</span>
<span class="line-number"> 57</span>
<span class="line-number"> 58</span>    def add_undef(self, name: str):
<span class="line-number"> 59</span>        &quot;&quot;&quot;Remove a defined macro.&quot;&quot;&quot;
<span class="line-number"> 60</span><span class="uncovered">        self.defined_macros.discard(name)</span>
<span class="line-number"> 61</span><span class="uncovered">        self.macro_values.pop(name, None)</span>
<span class="line-number"> 62</span>
<span class="line-number"> 63</span>    def is_defined(self, name: str) -&gt; bool:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Check if a macro is defined.&quot;&quot;&quot;
<span class="line-number"> 65</span>        return name in self.defined_macros
<span class="line-number"> 66</span>
<span class="line-number"> 67</span>    def get_macro_value(self, name: str) -&gt; str:
<span class="line-number"> 68</span>        &quot;&quot;&quot;Get the value of a defined macro.&quot;&quot;&quot;
<span class="line-number"> 69</span><span class="uncovered">        return self.macro_values.get(name, &quot;&quot;)</span>
<span class="line-number"> 70</span>
<span class="line-number"> 71</span>    def evaluate_condition(self, condition: str) -&gt; bool:
<span class="line-number"> 72</span>        &quot;&quot;&quot;Evaluate a preprocessor condition.&quot;&quot;&quot;
<span class="line-number"> 73</span>        if not condition.strip():
<span class="line-number"> 74</span>            return True
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Handle defined() operator
<span class="line-number"> 77</span>        condition = self._expand_defined_operator(condition)
<span class="line-number"> 78</span>
<span class="line-number"> 79</span>        # Handle macro expansions
<span class="line-number"> 80</span>        condition = self._expand_macros(condition)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>        # Simple evaluation for common patterns
<span class="line-number"> 83</span>        return self._evaluate_simple_expression(condition)
<span class="line-number"> 84</span>
<span class="line-number"> 85</span>    def _expand_defined_operator(self, condition: str) -&gt; str:
<span class="line-number"> 86</span>        &quot;&quot;&quot;Expand defined() operators in the condition.&quot;&quot;&quot;
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        def replace_defined(match):
<span class="line-number"> 89</span>            macro_name = match.group(1)
<span class="line-number"> 90</span>            return &quot;1&quot; if self.is_defined(macro_name) else &quot;0&quot;
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Replace defined(macro) with 1 or 0
<span class="line-number"> 93</span>        condition = re.sub(
<span class="line-number"> 94</span>            r&quot;defined\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\)&quot;, replace_defined, condition
<span class="line-number"> 95</span>        )
<span class="line-number"> 96</span>        return condition
<span class="line-number"> 97</span>
<span class="line-number"> 98</span>    def _expand_macros(self, condition: str) -&gt; str:
<span class="line-number"> 99</span>        &quot;&quot;&quot;Expand macros in the condition.&quot;&quot;&quot;
<span class="line-number">100</span>        # Simple macro expansion for common cases
<span class="line-number">101</span>        for macro_name, macro_value in self.macro_values.items():
<span class="line-number">102</span>            # Replace macro name with its value
<span class="line-number">103</span><span class="uncovered">            pattern = r&quot;\b&quot; + re.escape(macro_name) + r&quot;\b&quot;</span>
<span class="line-number">104</span><span class="uncovered">            condition = re.sub(pattern, macro_value, condition)</span>
<span class="line-number">105</span>        return condition
<span class="line-number">106</span>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
<span class="line-number">121</span>                left, right = condition.split(&quot;==&quot;, 1)
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: add_undef (lines 58-491)</h4>
<pre>
<span class="line-number"> 58</span>    def add_undef(self, name: str):
<span class="line-number"> 59</span>        &quot;&quot;&quot;Remove a defined macro.&quot;&quot;&quot;
<span class="line-number"> 60</span><span class="uncovered">        self.defined_macros.discard(name)</span>
<span class="line-number"> 61</span><span class="uncovered">        self.macro_values.pop(name, None)</span>
<span class="line-number"> 62</span>
<span class="line-number"> 63</span>    def is_defined(self, name: str) -&gt; bool:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Check if a macro is defined.&quot;&quot;&quot;
<span class="line-number"> 65</span>        return name in self.defined_macros
<span class="line-number"> 66</span>
<span class="line-number"> 67</span>    def get_macro_value(self, name: str) -&gt; str:
<span class="line-number"> 68</span>        &quot;&quot;&quot;Get the value of a defined macro.&quot;&quot;&quot;
<span class="line-number"> 69</span><span class="uncovered">        return self.macro_values.get(name, &quot;&quot;)</span>
<span class="line-number"> 70</span>
<span class="line-number"> 71</span>    def evaluate_condition(self, condition: str) -&gt; bool:
<span class="line-number"> 72</span>        &quot;&quot;&quot;Evaluate a preprocessor condition.&quot;&quot;&quot;
<span class="line-number"> 73</span>        if not condition.strip():
<span class="line-number"> 74</span>            return True
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Handle defined() operator
<span class="line-number"> 77</span>        condition = self._expand_defined_operator(condition)
<span class="line-number"> 78</span>
<span class="line-number"> 79</span>        # Handle macro expansions
<span class="line-number"> 80</span>        condition = self._expand_macros(condition)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>        # Simple evaluation for common patterns
<span class="line-number"> 83</span>        return self._evaluate_simple_expression(condition)
<span class="line-number"> 84</span>
<span class="line-number"> 85</span>    def _expand_defined_operator(self, condition: str) -&gt; str:
<span class="line-number"> 86</span>        &quot;&quot;&quot;Expand defined() operators in the condition.&quot;&quot;&quot;
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        def replace_defined(match):
<span class="line-number"> 89</span>            macro_name = match.group(1)
<span class="line-number"> 90</span>            return &quot;1&quot; if self.is_defined(macro_name) else &quot;0&quot;
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Replace defined(macro) with 1 or 0
<span class="line-number"> 93</span>        condition = re.sub(
<span class="line-number"> 94</span>            r&quot;defined\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\)&quot;, replace_defined, condition
<span class="line-number"> 95</span>        )
<span class="line-number"> 96</span>        return condition
<span class="line-number"> 97</span>
<span class="line-number"> 98</span>    def _expand_macros(self, condition: str) -&gt; str:
<span class="line-number"> 99</span>        &quot;&quot;&quot;Expand macros in the condition.&quot;&quot;&quot;
<span class="line-number">100</span>        # Simple macro expansion for common cases
<span class="line-number">101</span>        for macro_name, macro_value in self.macro_values.items():
<span class="line-number">102</span>            # Replace macro name with its value
<span class="line-number">103</span><span class="uncovered">            pattern = r&quot;\b&quot; + re.escape(macro_name) + r&quot;\b&quot;</span>
<span class="line-number">104</span><span class="uncovered">            condition = re.sub(pattern, macro_value, condition)</span>
<span class="line-number">105</span>        return condition
<span class="line-number">106</span>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
<span class="line-number">121</span>                left, right = condition.split(&quot;==&quot;, 1)
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: is_defined (lines 63-491)</h4>
<pre>
<span class="line-number"> 63</span>    def is_defined(self, name: str) -&gt; bool:
<span class="line-number"> 64</span>        &quot;&quot;&quot;Check if a macro is defined.&quot;&quot;&quot;
<span class="line-number"> 65</span>        return name in self.defined_macros
<span class="line-number"> 66</span>
<span class="line-number"> 67</span>    def get_macro_value(self, name: str) -&gt; str:
<span class="line-number"> 68</span>        &quot;&quot;&quot;Get the value of a defined macro.&quot;&quot;&quot;
<span class="line-number"> 69</span><span class="uncovered">        return self.macro_values.get(name, &quot;&quot;)</span>
<span class="line-number"> 70</span>
<span class="line-number"> 71</span>    def evaluate_condition(self, condition: str) -&gt; bool:
<span class="line-number"> 72</span>        &quot;&quot;&quot;Evaluate a preprocessor condition.&quot;&quot;&quot;
<span class="line-number"> 73</span>        if not condition.strip():
<span class="line-number"> 74</span>            return True
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Handle defined() operator
<span class="line-number"> 77</span>        condition = self._expand_defined_operator(condition)
<span class="line-number"> 78</span>
<span class="line-number"> 79</span>        # Handle macro expansions
<span class="line-number"> 80</span>        condition = self._expand_macros(condition)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>        # Simple evaluation for common patterns
<span class="line-number"> 83</span>        return self._evaluate_simple_expression(condition)
<span class="line-number"> 84</span>
<span class="line-number"> 85</span>    def _expand_defined_operator(self, condition: str) -&gt; str:
<span class="line-number"> 86</span>        &quot;&quot;&quot;Expand defined() operators in the condition.&quot;&quot;&quot;
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        def replace_defined(match):
<span class="line-number"> 89</span>            macro_name = match.group(1)
<span class="line-number"> 90</span>            return &quot;1&quot; if self.is_defined(macro_name) else &quot;0&quot;
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Replace defined(macro) with 1 or 0
<span class="line-number"> 93</span>        condition = re.sub(
<span class="line-number"> 94</span>            r&quot;defined\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\)&quot;, replace_defined, condition
<span class="line-number"> 95</span>        )
<span class="line-number"> 96</span>        return condition
<span class="line-number"> 97</span>
<span class="line-number"> 98</span>    def _expand_macros(self, condition: str) -&gt; str:
<span class="line-number"> 99</span>        &quot;&quot;&quot;Expand macros in the condition.&quot;&quot;&quot;
<span class="line-number">100</span>        # Simple macro expansion for common cases
<span class="line-number">101</span>        for macro_name, macro_value in self.macro_values.items():
<span class="line-number">102</span>            # Replace macro name with its value
<span class="line-number">103</span><span class="uncovered">            pattern = r&quot;\b&quot; + re.escape(macro_name) + r&quot;\b&quot;</span>
<span class="line-number">104</span><span class="uncovered">            condition = re.sub(pattern, macro_value, condition)</span>
<span class="line-number">105</span>        return condition
<span class="line-number">106</span>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
<span class="line-number">121</span>                left, right = condition.split(&quot;==&quot;, 1)
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: get_macro_value (lines 67-491)</h4>
<pre>
<span class="line-number"> 67</span>    def get_macro_value(self, name: str) -&gt; str:
<span class="line-number"> 68</span>        &quot;&quot;&quot;Get the value of a defined macro.&quot;&quot;&quot;
<span class="line-number"> 69</span><span class="uncovered">        return self.macro_values.get(name, &quot;&quot;)</span>
<span class="line-number"> 70</span>
<span class="line-number"> 71</span>    def evaluate_condition(self, condition: str) -&gt; bool:
<span class="line-number"> 72</span>        &quot;&quot;&quot;Evaluate a preprocessor condition.&quot;&quot;&quot;
<span class="line-number"> 73</span>        if not condition.strip():
<span class="line-number"> 74</span>            return True
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Handle defined() operator
<span class="line-number"> 77</span>        condition = self._expand_defined_operator(condition)
<span class="line-number"> 78</span>
<span class="line-number"> 79</span>        # Handle macro expansions
<span class="line-number"> 80</span>        condition = self._expand_macros(condition)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>        # Simple evaluation for common patterns
<span class="line-number"> 83</span>        return self._evaluate_simple_expression(condition)
<span class="line-number"> 84</span>
<span class="line-number"> 85</span>    def _expand_defined_operator(self, condition: str) -&gt; str:
<span class="line-number"> 86</span>        &quot;&quot;&quot;Expand defined() operators in the condition.&quot;&quot;&quot;
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        def replace_defined(match):
<span class="line-number"> 89</span>            macro_name = match.group(1)
<span class="line-number"> 90</span>            return &quot;1&quot; if self.is_defined(macro_name) else &quot;0&quot;
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Replace defined(macro) with 1 or 0
<span class="line-number"> 93</span>        condition = re.sub(
<span class="line-number"> 94</span>            r&quot;defined\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\)&quot;, replace_defined, condition
<span class="line-number"> 95</span>        )
<span class="line-number"> 96</span>        return condition
<span class="line-number"> 97</span>
<span class="line-number"> 98</span>    def _expand_macros(self, condition: str) -&gt; str:
<span class="line-number"> 99</span>        &quot;&quot;&quot;Expand macros in the condition.&quot;&quot;&quot;
<span class="line-number">100</span>        # Simple macro expansion for common cases
<span class="line-number">101</span>        for macro_name, macro_value in self.macro_values.items():
<span class="line-number">102</span>            # Replace macro name with its value
<span class="line-number">103</span><span class="uncovered">            pattern = r&quot;\b&quot; + re.escape(macro_name) + r&quot;\b&quot;</span>
<span class="line-number">104</span><span class="uncovered">            condition = re.sub(pattern, macro_value, condition)</span>
<span class="line-number">105</span>        return condition
<span class="line-number">106</span>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
<span class="line-number">121</span>                left, right = condition.split(&quot;==&quot;, 1)
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: evaluate_condition (lines 71-491)</h4>
<pre>
<span class="line-number"> 71</span>    def evaluate_condition(self, condition: str) -&gt; bool:
<span class="line-number"> 72</span>        &quot;&quot;&quot;Evaluate a preprocessor condition.&quot;&quot;&quot;
<span class="line-number"> 73</span>        if not condition.strip():
<span class="line-number"> 74</span>            return True
<span class="line-number"> 75</span>
<span class="line-number"> 76</span>        # Handle defined() operator
<span class="line-number"> 77</span>        condition = self._expand_defined_operator(condition)
<span class="line-number"> 78</span>
<span class="line-number"> 79</span>        # Handle macro expansions
<span class="line-number"> 80</span>        condition = self._expand_macros(condition)
<span class="line-number"> 81</span>
<span class="line-number"> 82</span>        # Simple evaluation for common patterns
<span class="line-number"> 83</span>        return self._evaluate_simple_expression(condition)
<span class="line-number"> 84</span>
<span class="line-number"> 85</span>    def _expand_defined_operator(self, condition: str) -&gt; str:
<span class="line-number"> 86</span>        &quot;&quot;&quot;Expand defined() operators in the condition.&quot;&quot;&quot;
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        def replace_defined(match):
<span class="line-number"> 89</span>            macro_name = match.group(1)
<span class="line-number"> 90</span>            return &quot;1&quot; if self.is_defined(macro_name) else &quot;0&quot;
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Replace defined(macro) with 1 or 0
<span class="line-number"> 93</span>        condition = re.sub(
<span class="line-number"> 94</span>            r&quot;defined\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\)&quot;, replace_defined, condition
<span class="line-number"> 95</span>        )
<span class="line-number"> 96</span>        return condition
<span class="line-number"> 97</span>
<span class="line-number"> 98</span>    def _expand_macros(self, condition: str) -&gt; str:
<span class="line-number"> 99</span>        &quot;&quot;&quot;Expand macros in the condition.&quot;&quot;&quot;
<span class="line-number">100</span>        # Simple macro expansion for common cases
<span class="line-number">101</span>        for macro_name, macro_value in self.macro_values.items():
<span class="line-number">102</span>            # Replace macro name with its value
<span class="line-number">103</span><span class="uncovered">            pattern = r&quot;\b&quot; + re.escape(macro_name) + r&quot;\b&quot;</span>
<span class="line-number">104</span><span class="uncovered">            condition = re.sub(pattern, macro_value, condition)</span>
<span class="line-number">105</span>        return condition
<span class="line-number">106</span>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
<span class="line-number">121</span>                left, right = condition.split(&quot;==&quot;, 1)
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: _expand_defined_operator (lines 85-491)</h4>
<pre>
<span class="line-number"> 85</span>    def _expand_defined_operator(self, condition: str) -&gt; str:
<span class="line-number"> 86</span>        &quot;&quot;&quot;Expand defined() operators in the condition.&quot;&quot;&quot;
<span class="line-number"> 87</span>
<span class="line-number"> 88</span>        def replace_defined(match):
<span class="line-number"> 89</span>            macro_name = match.group(1)
<span class="line-number"> 90</span>            return &quot;1&quot; if self.is_defined(macro_name) else &quot;0&quot;
<span class="line-number"> 91</span>
<span class="line-number"> 92</span>        # Replace defined(macro) with 1 or 0
<span class="line-number"> 93</span>        condition = re.sub(
<span class="line-number"> 94</span>            r&quot;defined\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\)&quot;, replace_defined, condition
<span class="line-number"> 95</span>        )
<span class="line-number"> 96</span>        return condition
<span class="line-number"> 97</span>
<span class="line-number"> 98</span>    def _expand_macros(self, condition: str) -&gt; str:
<span class="line-number"> 99</span>        &quot;&quot;&quot;Expand macros in the condition.&quot;&quot;&quot;
<span class="line-number">100</span>        # Simple macro expansion for common cases
<span class="line-number">101</span>        for macro_name, macro_value in self.macro_values.items():
<span class="line-number">102</span>            # Replace macro name with its value
<span class="line-number">103</span><span class="uncovered">            pattern = r&quot;\b&quot; + re.escape(macro_name) + r&quot;\b&quot;</span>
<span class="line-number">104</span><span class="uncovered">            condition = re.sub(pattern, macro_value, condition)</span>
<span class="line-number">105</span>        return condition
<span class="line-number">106</span>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
<span class="line-number">121</span>                left, right = condition.split(&quot;==&quot;, 1)
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: _expand_macros (lines 98-491)</h4>
<pre>
<span class="line-number"> 98</span>    def _expand_macros(self, condition: str) -&gt; str:
<span class="line-number"> 99</span>        &quot;&quot;&quot;Expand macros in the condition.&quot;&quot;&quot;
<span class="line-number">100</span>        # Simple macro expansion for common cases
<span class="line-number">101</span>        for macro_name, macro_value in self.macro_values.items():
<span class="line-number">102</span>            # Replace macro name with its value
<span class="line-number">103</span><span class="uncovered">            pattern = r&quot;\b&quot; + re.escape(macro_name) + r&quot;\b&quot;</span>
<span class="line-number">104</span><span class="uncovered">            condition = re.sub(pattern, macro_value, condition)</span>
<span class="line-number">105</span>        return condition
<span class="line-number">106</span>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
<span class="line-number">121</span>                left, right = condition.split(&quot;==&quot;, 1)
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: _evaluate_simple_expression (lines 107-491)</h4>
<pre>
<span class="line-number">107</span>    def _evaluate_simple_expression(self, condition: str) -&gt; bool:
<span class="line-number">108</span>        &quot;&quot;&quot;Evaluate simple expressions like comparisons and logical operators.&quot;&quot;&quot;
<span class="line-number">109</span>        try:
<span class="line-number">110</span>            # Handle common comparison operators
<span class="line-number">111</span>            condition = condition.strip()
<span class="line-number">112</span>
<span class="line-number">113</span>            # Handle simple boolean values
<span class="line-number">114</span>            if condition.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;]:
<span class="line-number">115</span><span class="uncovered">                return True</span>
<span class="line-number">116</span>            if condition.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;]:
<span class="line-number">117</span>                return False
<span class="line-number">118</span>
<span class="line-number">119</span>            # Handle simple comparisons
<span class="line-number">120</span>            if &quot;==&quot; in condition:
<span class="line-number">121</span>                left, right = condition.split(&quot;==&quot;, 1)
<span class="line-number">122</span>                left_val = left.strip()
<span class="line-number">123</span>                right_val = right.strip()
<span class="line-number">124</span>
<span class="line-number">125</span>                # If both sides are known macros, compare their values
<span class="line-number">126</span>                if left_val in self.defined_macros and right_val in self.defined_macros:
<span class="line-number">127</span><span class="uncovered">                    return self.get_macro_value(left_val) == self.get_macro_value(</span>
<span class="line-number">128</span>                        right_val
<span class="line-number">129</span>                    )
<span class="line-number">130</span>                # If one side is a known macro, compare with the other side
<span class="line-number">131</span>                elif left_val in self.defined_macros:
<span class="line-number">132</span><span class="uncovered">                    return self.get_macro_value(left_val) == right_val</span>
<span class="line-number">133</span>                elif right_val in self.defined_macros:
<span class="line-number">134</span><span class="uncovered">                    return left_val == self.get_macro_value(right_val)</span>
<span class="line-number">135</span>                # If neither side is a known macro, both are undefined, so they&#x27;re equal
<span class="line-number">136</span>                else:
<span class="line-number">137</span>                    return True  # Both undefined macros are considered equal
<span class="line-number">138</span>
<span class="line-number">139</span>            if &quot;!=&quot; in condition:
<span class="line-number">140</span><span class="uncovered">                left, right = condition.split(&quot;!=&quot;, 1)</span>
<span class="line-number">141</span><span class="uncovered">                left_val = left.strip()</span>
<span class="line-number">142</span><span class="uncovered">                right_val = right.strip()</span>
<span class="line-number">143</span>
<span class="line-number">144</span>                # If both sides are known macros, compare their values
<span class="line-number">145</span><span class="uncovered">                if left_val in self.defined_macros and right_val in self.defined_macros:</span>
<span class="line-number">146</span><span class="uncovered">                    return self.get_macro_value(left_val) != self.get_macro_value(</span>
<span class="line-number">147</span>                        right_val
<span class="line-number">148</span>                    )
<span class="line-number">149</span>                # If one side is a known macro, compare with the other side
<span class="line-number">150</span><span class="uncovered">                elif left_val in self.defined_macros:</span>
<span class="line-number">151</span><span class="uncovered">                    return self.get_macro_value(left_val) != right_val</span>
<span class="line-number">152</span><span class="uncovered">                elif right_val in self.defined_macros:</span>
<span class="line-number">153</span><span class="uncovered">                    return left_val != self.get_macro_value(right_val)</span>
<span class="line-number">154</span>                # If neither side is a known macro, do string comparison
<span class="line-number">155</span>                else:
<span class="line-number">156</span><span class="uncovered">                    return left_val != right_val</span>
<span class="line-number">157</span>
<span class="line-number">158</span>            if &quot;&gt;&quot; in condition:
<span class="line-number">159</span>                left, right = condition.split(&quot;&gt;&quot;, 1)
<span class="line-number">160</span>                try:
<span class="line-number">161</span>                    left_val = self._evaluate_operand(left.strip())
<span class="line-number">162</span>                    right_val = self._evaluate_operand(right.strip())
<span class="line-number">163</span>                    return float(left_val) &gt; float(right_val)
<span class="line-number">164</span>                except ValueError:
<span class="line-number">165</span>                    return False
<span class="line-number">166</span><span class="uncovered">            if &quot;&lt;&quot; in condition:</span>
<span class="line-number">167</span><span class="uncovered">                left, right = condition.split(&quot;&lt;&quot;, 1)</span>
<span class="line-number">168</span><span class="uncovered">                try:</span>
<span class="line-number">169</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">170</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">171</span><span class="uncovered">                    return float(left_val) &lt; float(right_val)</span>
<span class="line-number">172</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">173</span><span class="uncovered">                    return False</span>
<span class="line-number">174</span><span class="uncovered">            if &quot;&gt;=&quot; in condition:</span>
<span class="line-number">175</span><span class="uncovered">                left, right = condition.split(&quot;&gt;=&quot;, 1)</span>
<span class="line-number">176</span><span class="uncovered">                try:</span>
<span class="line-number">177</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">178</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">179</span><span class="uncovered">                    return float(left_val) &gt;= float(right_val)</span>
<span class="line-number">180</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">181</span><span class="uncovered">                    return False</span>
<span class="line-number">182</span><span class="uncovered">            if &quot;&lt;=&quot; in condition:</span>
<span class="line-number">183</span><span class="uncovered">                left, right = condition.split(&quot;&lt;=&quot;, 1)</span>
<span class="line-number">184</span><span class="uncovered">                try:</span>
<span class="line-number">185</span><span class="uncovered">                    left_val = self._evaluate_operand(left.strip())</span>
<span class="line-number">186</span><span class="uncovered">                    right_val = self._evaluate_operand(right.strip())</span>
<span class="line-number">187</span><span class="uncovered">                    return float(left_val) &lt;= float(right_val)</span>
<span class="line-number">188</span><span class="uncovered">                except ValueError:</span>
<span class="line-number">189</span><span class="uncovered">                    return False</span>
<span class="line-number">190</span>
<span class="line-number">191</span>            # Handle logical operators
<span class="line-number">192</span><span class="uncovered">            if &quot;&amp;&amp;&quot; in condition:</span>
<span class="line-number">193</span><span class="uncovered">                parts = condition.split(&quot;&amp;&amp;&quot;)</span>
<span class="line-number">194</span><span class="uncovered">                return all(</span>
<span class="line-number">195</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">196</span>                )
<span class="line-number">197</span><span class="uncovered">            if &quot;||&quot; in condition:</span>
<span class="line-number">198</span><span class="uncovered">                parts = condition.split(&quot;||&quot;)</span>
<span class="line-number">199</span><span class="uncovered">                return any(</span>
<span class="line-number">200</span>                    self._evaluate_simple_expression(part.strip()) for part in parts
<span class="line-number">201</span>                )
<span class="line-number">202</span><span class="uncovered">            if &quot;!&quot; in condition:</span>
<span class="line-number">203</span>                # Simple negation
<span class="line-number">204</span><span class="uncovered">                negated = condition.replace(&quot;!&quot;, &quot;&quot;).strip()</span>
<span class="line-number">205</span><span class="uncovered">                return not self._evaluate_simple_expression(negated)</span>
<span class="line-number">206</span>
<span class="line-number">207</span>            # If it&#x27;s just a macro name, check if it&#x27;s defined
<span class="line-number">208</span><span class="uncovered">            if condition in self.defined_macros:</span>
<span class="line-number">209</span><span class="uncovered">                return True</span>
<span class="line-number">210</span>
<span class="line-number">211</span>            # Try to evaluate as a number
<span class="line-number">212</span><span class="uncovered">            try:</span>
<span class="line-number">213</span><span class="uncovered">                return bool(int(condition))</span>
<span class="line-number">214</span><span class="uncovered">            except ValueError:</span>
<span class="line-number">215</span><span class="uncovered">                pass</span>
<span class="line-number">216</span>
<span class="line-number">217</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">218</span>            # This ensures existing tests continue to work
<span class="line-number">219</span><span class="uncovered">            return True</span>
<span class="line-number">220</span>
<span class="line-number">221</span><span class="uncovered">        except ValueError as e:</span>
<span class="line-number">222</span><span class="uncovered">            self.logger.warning(</span>
<span class="line-number">223</span>                &quot;Error evaluating preprocessor condition &#x27;%s&#x27;: %s&quot;, condition, e
<span class="line-number">224</span>            )
<span class="line-number">225</span>            # Default to True for unknown conditions (backward compatibility)
<span class="line-number">226</span><span class="uncovered">            return True</span>
<span class="line-number">227</span>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: _evaluate_operand (lines 228-491)</h4>
<pre>
<span class="line-number">228</span>    def _evaluate_operand(self, operand: str) -&gt; str:
<span class="line-number">229</span>        &quot;&quot;&quot;Evaluate an operand, expanding macros if they are defined.&quot;&quot;&quot;
<span class="line-number">230</span>        operand = operand.strip()
<span class="line-number">231</span>
<span class="line-number">232</span>        # If it&#x27;s a defined macro, return its value
<span class="line-number">233</span>        if operand in self.defined_macros:
<span class="line-number">234</span><span class="uncovered">            return self.get_macro_value(operand)</span>
<span class="line-number">235</span>
<span class="line-number">236</span>        # Otherwise, return the operand as-is
<span class="line-number">237</span>        return operand
<span class="line-number">238</span>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: parse_preprocessor_blocks (lines 239-491)</h4>
<pre>
<span class="line-number">239</span>    def parse_preprocessor_blocks(self, tokens: List[Token]) -&gt; List[PreprocessorBlock]:
<span class="line-number">240</span>        &quot;&quot;&quot;Parse preprocessor blocks from tokens.&quot;&quot;&quot;
<span class="line-number">241</span>        blocks = []
<span class="line-number">242</span>        stack = []
<span class="line-number">243</span>
<span class="line-number">244</span>        i = 0
<span class="line-number">245</span>        while i &lt; len(tokens):
<span class="line-number">246</span>            token = tokens[i]
<span class="line-number">247</span>
<span class="line-number">248</span>            if token.type == TokenType.PREPROCESSOR:
<span class="line-number">249</span>                directive = self._parse_directive(token.value)
<span class="line-number">250</span>
<span class="line-number">251</span>                if (
<span class="line-number">252</span>                    directive == PreprocessorDirective.IF
<span class="line-number">253</span>                    or directive == PreprocessorDirective.IFDEF
<span class="line-number">254</span>                    or directive == PreprocessorDirective.IFNDEF
<span class="line-number">255</span>                ):
<span class="line-number">256</span>                    # Start new block
<span class="line-number">257</span>                    condition = self._extract_condition(token.value, directive)
<span class="line-number">258</span>                    block = PreprocessorBlock(
<span class="line-number">259</span>                        directive=directive,
<span class="line-number">260</span>                        condition=condition,
<span class="line-number">261</span>                        start_token=i,
<span class="line-number">262</span>                        end_token=-1,  # Will be set when we find #endif
<span class="line-number">263</span>                        is_active=self._should_activate_block(
<span class="line-number">264</span>                            directive, condition, stack
<span class="line-number">265</span>                        ),
<span class="line-number">266</span>                        children=[],
<span class="line-number">267</span>                        parent=stack[-1] if stack else None,
<span class="line-number">268</span>                    )
<span class="line-number">269</span>
<span class="line-number">270</span>                    if stack:
<span class="line-number">271</span>                        stack[-1].children.append(block)
<span class="line-number">272</span>                    else:
<span class="line-number">273</span>                        blocks.append(block)
<span class="line-number">274</span>
<span class="line-number">275</span>                    stack.append(block)
<span class="line-number">276</span>
<span class="line-number">277</span>                elif directive == PreprocessorDirective.ELIF:
<span class="line-number">278</span>                    if stack:
<span class="line-number">279</span>                        # Update current block
<span class="line-number">280</span>                        current_block = stack[-1]
<span class="line-number">281</span>                        condition = self._extract_condition(token.value, directive)
<span class="line-number">282</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">283</span>                            directive, condition, stack
<span class="line-number">284</span>                        )
<span class="line-number">285</span>
<span class="line-number">286</span>                elif directive == PreprocessorDirective.ELSE:
<span class="line-number">287</span>                    if stack:
<span class="line-number">288</span>                        # Update current block
<span class="line-number">289</span>                        current_block = stack[-1]
<span class="line-number">290</span>                        current_block.is_active = self._should_activate_block(
<span class="line-number">291</span>                            directive, &quot;&quot;, stack
<span class="line-number">292</span>                        )
<span class="line-number">293</span>
<span class="line-number">294</span>                elif directive == PreprocessorDirective.ENDIF:
<span class="line-number">295</span>                    if stack:
<span class="line-number">296</span>                        # End current block
<span class="line-number">297</span>                        current_block = stack.pop()
<span class="line-number">298</span>                        current_block.end_token = i
<span class="line-number">299</span>
<span class="line-number">300</span><span class="uncovered">                elif directive == PreprocessorDirective.DEFINE:</span>
<span class="line-number">301</span>                    # Handle #define
<span class="line-number">302</span><span class="uncovered">                    macro_name, macro_value = self._parse_define(token.value)</span>
<span class="line-number">303</span><span class="uncovered">                    self.add_define(macro_name, macro_value)</span>
<span class="line-number">304</span>
<span class="line-number">305</span><span class="uncovered">                elif directive == PreprocessorDirective.UNDEF:</span>
<span class="line-number">306</span>                    # Handle #undef
<span class="line-number">307</span><span class="uncovered">                    macro_name = self._parse_undef(token.value)</span>
<span class="line-number">308</span><span class="uncovered">                    self.add_undef(macro_name)</span>
<span class="line-number">309</span>
<span class="line-number">310</span>            i += 1
<span class="line-number">311</span>
<span class="line-number">312</span>        return blocks
<span class="line-number">313</span>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: _parse_directive (lines 314-491)</h4>
<pre>
<span class="line-number">314</span>    def _parse_directive(self, value: str) -&gt; PreprocessorDirective:
<span class="line-number">315</span>        &quot;&quot;&quot;Parse the directive type from a preprocessor token.&quot;&quot;&quot;
<span class="line-number">316</span>        value = value.strip()
<span class="line-number">317</span>        if value.startswith(&quot;#ifdef&quot;):
<span class="line-number">318</span>            return PreprocessorDirective.IFDEF
<span class="line-number">319</span>        elif value.startswith(&quot;#ifndef&quot;):
<span class="line-number">320</span>            return PreprocessorDirective.IFNDEF
<span class="line-number">321</span>        elif value.startswith(&quot;#if&quot;):
<span class="line-number">322</span>            return PreprocessorDirective.IF
<span class="line-number">323</span>        elif value.startswith(&quot;#elif&quot;):
<span class="line-number">324</span>            return PreprocessorDirective.ELIF
<span class="line-number">325</span>        elif value.startswith(&quot;#else&quot;):
<span class="line-number">326</span>            return PreprocessorDirective.ELSE
<span class="line-number">327</span>        elif value.startswith(&quot;#endif&quot;):
<span class="line-number">328</span>            return PreprocessorDirective.ENDIF
<span class="line-number">329</span><span class="uncovered">        elif value.startswith(&quot;#define&quot;):</span>
<span class="line-number">330</span><span class="uncovered">            return PreprocessorDirective.DEFINE</span>
<span class="line-number">331</span><span class="uncovered">        elif value.startswith(&quot;#undef&quot;):</span>
<span class="line-number">332</span><span class="uncovered">            return PreprocessorDirective.UNDEF</span>
<span class="line-number">333</span>        else:
<span class="line-number">334</span><span class="uncovered">            return PreprocessorDirective.IF  # Default</span>
<span class="line-number">335</span>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: _extract_condition (lines 336-491)</h4>
<pre>
<span class="line-number">336</span>    def _extract_condition(self, value: str, directive: PreprocessorDirective) -&gt; str:
<span class="line-number">337</span>        &quot;&quot;&quot;Extract the condition from a preprocessor directive.&quot;&quot;&quot;
<span class="line-number">338</span>        value = value.strip()
<span class="line-number">339</span>
<span class="line-number">340</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">341</span>            match = re.search(r&quot;#ifdef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">342</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">343</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">344</span>            match = re.search(r&quot;#ifndef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)
<span class="line-number">345</span>            return match.group(1) if match else &quot;&quot;
<span class="line-number">346</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">347</span>            match = re.search(r&quot;#if\s+(.+)&quot;, value)
<span class="line-number">348</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">349</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">350</span>            match = re.search(r&quot;#elif\s+(.+)&quot;, value)
<span class="line-number">351</span>            return match.group(1).strip() if match else &quot;&quot;
<span class="line-number">352</span>        else:
<span class="line-number">353</span><span class="uncovered">            return &quot;&quot;</span>
<span class="line-number">354</span>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: _parse_define (lines 355-491)</h4>
<pre>
<span class="line-number">355</span>    def _parse_define(self, value: str) -&gt; Tuple[str, str]:
<span class="line-number">356</span>        &quot;&quot;&quot;Parse #define directive.&quot;&quot;&quot;
<span class="line-number">357</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">358</span><span class="uncovered">        match = re.search(r&quot;#define\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(.+)&quot;, value)</span>
<span class="line-number">359</span><span class="uncovered">        if match:</span>
<span class="line-number">360</span><span class="uncovered">            name = match.group(1)</span>
<span class="line-number">361</span><span class="uncovered">            macro_value = match.group(2).strip()</span>
<span class="line-number">362</span><span class="uncovered">            return name, macro_value</span>
<span class="line-number">363</span><span class="uncovered">        return &quot;&quot;, &quot;&quot;</span>
<span class="line-number">364</span>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: _parse_undef (lines 365-491)</h4>
<pre>
<span class="line-number">365</span>    def _parse_undef(self, value: str) -&gt; str:
<span class="line-number">366</span>        &quot;&quot;&quot;Parse #undef directive.&quot;&quot;&quot;
<span class="line-number">367</span><span class="uncovered">        value = value.strip()</span>
<span class="line-number">368</span><span class="uncovered">        match = re.search(r&quot;#undef\s+([a-zA-Z_][a-zA-Z0-9_]*)&quot;, value)</span>
<span class="line-number">369</span><span class="uncovered">        return match.group(1) if match else &quot;&quot;</span>
<span class="line-number">370</span>
<span class="line-number">371</span>    def _should_activate_block(
<span class="line-number">372</span>        self,
<span class="line-number">373</span>        directive: PreprocessorDirective,
<span class="line-number">374</span>        condition: str,
<span class="line-number">375</span>        stack: List[PreprocessorBlock],
<span class="line-number">376</span>    ) -&gt; bool:
<span class="line-number">377</span>        &quot;&quot;&quot;Determine if a block should be active based on its directive and condition.&quot;&quot;&quot;
<span class="line-number">378</span>        # Check if parent blocks are active
<span class="line-number">379</span>        if stack and not stack[-1].is_active:
<span class="line-number">380</span>            return False
<span class="line-number">381</span>
<span class="line-number">382</span>        if directive == PreprocessorDirective.IFDEF:
<span class="line-number">383</span>            return self.is_defined(condition)
<span class="line-number">384</span>        elif directive == PreprocessorDirective.IFNDEF:
<span class="line-number">385</span>            return not self.is_defined(condition)
<span class="line-number">386</span>        elif directive == PreprocessorDirective.IF:
<span class="line-number">387</span>            return self.evaluate_condition(condition)
<span class="line-number">388</span>        elif directive == PreprocessorDirective.ELIF:
<span class="line-number">389</span>            # For #elif, we need to check if no previous branch was taken
<span class="line-number">390</span>            if stack:
<span class="line-number">391</span>                parent = stack[-1]
<span class="line-number">392</span>                # Check if any previous child was active
<span class="line-number">393</span>                for child in parent.children:
<span class="line-number">394</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">395</span><span class="uncovered">                        return False</span>
<span class="line-number">396</span>                return self.evaluate_condition(condition)
<span class="line-number">397</span><span class="uncovered">            return False</span>
<span class="line-number">398</span>        elif directive == PreprocessorDirective.ELSE:
<span class="line-number">399</span>            # For #else, we need to check if no previous branch was taken
<span class="line-number">400</span>            if stack:
<span class="line-number">401</span>                parent = stack[-1]
<span class="line-number">402</span>                # Check if any previous child was active
<span class="line-number">403</span>                for child in parent.children:
<span class="line-number">404</span><span class="uncovered">                    if child.is_active:</span>
<span class="line-number">405</span><span class="uncovered">                        return False</span>
<span class="line-number">406</span>                return True
<span class="line-number">407</span><span class="uncovered">            return False</span>
<span class="line-number">408</span>        else:
<span class="line-number">409</span><span class="uncovered">            return False</span>
<span class="line-number">410</span>
<span class="line-number">411</span>    def filter_tokens(self, tokens: List[Token]) -&gt; List[Token]:
<span class="line-number">412</span>        &quot;&quot;&quot;Filter tokens based on preprocessor blocks, keeping only active content.&quot;&quot;&quot;
<span class="line-number">413</span>        blocks = self.parse_preprocessor_blocks(tokens)
<span class="line-number">414</span>        filtered_tokens = []
<span class="line-number">415</span>
<span class="line-number">416</span>        i = 0
<span class="line-number">417</span>        while i &lt; len(tokens):
<span class="line-number">418</span>            token = tokens[i]
<span class="line-number">419</span>
<span class="line-number">420</span>            # Check if this token is inside a preprocessor block
<span class="line-number">421</span>            in_active_block = self._is_token_in_active_block(i, blocks)
<span class="line-number">422</span>
<span class="line-number">423</span>            if in_active_block:
<span class="line-number">424</span>                # Include the token if it&#x27;s not a preprocessor directive
<span class="line-number">425</span>                if token.type != TokenType.PREPROCESSOR:
<span class="line-number">426</span>                    filtered_tokens.append(token)
<span class="line-number">427</span>            else:
<span class="line-number">428</span>                # Skip tokens that are not in active blocks
<span class="line-number">429</span>                pass
<span class="line-number">430</span>
<span class="line-number">431</span>            i += 1
<span class="line-number">432</span>
<span class="line-number">433</span>        return filtered_tokens
<span class="line-number">434</span>
<span class="line-number">435</span>    def _is_token_in_active_block(
<span class="line-number">436</span>        self, token_index: int, blocks: List[PreprocessorBlock]
<span class="line-number">437</span>    ) -&gt; bool:
<span class="line-number">438</span>        &quot;&quot;&quot;Check if a token is inside an active preprocessor block.&quot;&quot;&quot;
<span class="line-number">439</span>        # Check all blocks recursively
<span class="line-number">440</span>        for block in blocks:
<span class="line-number">441</span>            if self._is_token_in_block(token_index, block):
<span class="line-number">442</span>                # If token is in this block, return whether the block is active
<span class="line-number">443</span>                return block.is_active
<span class="line-number">444</span>        return True  # Default to True if not in any block
<span class="line-number">445</span>
<span class="line-number">446</span>    def _is_token_in_block(self, token_index: int, block: PreprocessorBlock) -&gt; bool:
<span class="line-number">447</span>        &quot;&quot;&quot;Check if a token is inside a specific block.&quot;&quot;&quot;
<span class="line-number">448</span>        if block.start_token &lt;= token_index &lt;= block.end_token:
<span class="line-number">449</span>            # Check if any child block contains this token
<span class="line-number">450</span>            for child in block.children:
<span class="line-number">451</span>                if self._is_token_in_block(token_index, child):
<span class="line-number">452</span>                    # If token is in a child block, return whether the child is active
<span class="line-number">453</span>                    return child.is_active
<span class="line-number">454</span>            # Token is in this block but not in any child block
<span class="line-number">455</span>            return True
<span class="line-number">456</span>        return False
<span class="line-number">457</span>
<span class="line-number">458</span>
<span class="line-number">459</span>class PreprocessorManager:
<span class="line-number">460</span>    &quot;&quot;&quot;High-level interface for preprocessor management.&quot;&quot;&quot;
<span class="line-number">461</span>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: __init__ (lines 462-491)</h4>
<pre>
<span class="line-number">462</span>    def __init__(self):
<span class="line-number">463</span>        self.evaluator = PreprocessorEvaluator()
<span class="line-number">464</span>        self.logger = logging.getLogger(__name__)
<span class="line-number">465</span>
<span class="line-number">466</span>    def process_file(
<span class="line-number">467</span>        self, tokens: List[Token], defines: Optional[Dict[str, str]] = None
<span class="line-number">468</span>    ) -&gt; List[Token]:
<span class="line-number">469</span>        &quot;&quot;&quot;Process a file&#x27;s tokens through the preprocessor.&quot;&quot;&quot;
<span class="line-number">470</span>        if defines:
<span class="line-number">471</span><span class="uncovered">            for name, value in defines.items():</span>
<span class="line-number">472</span><span class="uncovered">                self.evaluator.add_define(name, value)</span>
<span class="line-number">473</span>
<span class="line-number">474</span>        # Filter tokens based on preprocessor directives
<span class="line-number">475</span>        filtered_tokens = self.evaluator.filter_tokens(tokens)
<span class="line-number">476</span>
<span class="line-number">477</span>        self.logger.debug(
<span class="line-number">478</span>            f&quot;Preprocessor: {len(tokens)} tokens -&gt; {len(filtered_tokens)} tokens&quot;
<span class="line-number">479</span>        )
<span class="line-number">480</span>        return filtered_tokens
<span class="line-number">481</span>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
<h4>Function: add_defines_from_content (lines 482-491)</h4>
<pre>
<span class="line-number">482</span>    def add_defines_from_content(self, tokens: List[Token]):
<span class="line-number">483</span>        &quot;&quot;&quot;Extract #define directives from tokens and add them to the evaluator.&quot;&quot;&quot;
<span class="line-number">484</span>        for token in tokens:
<span class="line-number">485</span>            if token.type == TokenType.PREPROCESSOR and token.value.startswith(
<span class="line-number">486</span>                &quot;#define&quot;
<span class="line-number">487</span>            ):
<span class="line-number">488</span><span class="uncovered">                name, value = self.evaluator._parse_define(token.value)</span>
<span class="line-number">489</span><span class="uncovered">                if name:</span>
<span class="line-number">490</span><span class="uncovered">                    self.evaluator.add_define(name, value)</span>
<span class="line-number">491</span><span class="uncovered">                    self.logger.debug(&quot;Preprocessor: Added define %s = %s&quot;, name, value)</span>
</pre>
</div>

    <div class="footer">
        <p>Generated by Test Report System</p>
    </div>
</body>
</html>