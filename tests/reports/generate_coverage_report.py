#!/usr/bin/env python3
"""
Generate detailed coverage report in HTML format with code context.
This script creates an HTML file showing uncovered code lines with context and background coloring.
"""

import coverage
import os
import sys
from pathlib import Path
from datetime import datetime
import html
import re


def generate_html_header():
    """Generate HTML header with simple CSS styling."""
    return """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Code Coverage Report</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #f9f9f9;
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
            line-height: 1.6;
            color: #333;
        }
        pre {
            background-color: #fff;
            color: #111;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-family: Consolas, Monaco, 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
            margin: 1rem 0;
            border: 1px solid #eee;
        }
        code {
            white-space: pre;
        }
        .line-number {
            color: #858585;
            margin-right: 1rem;
            user-select: none;
        }
        .covered {
            color: #111;
        }
        .uncovered {
            color: #f44336;
        }
        .context {
            background-color: #ffeaea;
        }
        .legend {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0.5rem 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 0.5rem;
            border-radius: 3px;
        }
        .footer {
            text-align: center;
            margin-top: 2rem;
            padding: 1rem;
            color: #7f8c8d;
            border-top: 1px solid #ecf0f1;
        }
    </style>
</head>
<body>
    <h1>Code Coverage Report</h1>
    <p>Generated on """ + datetime.now().strftime("%Y-%m-%d %H:%M:%S") + """</p>"""


def apply_syntax_highlighting(line_content):
    """Apply basic syntax highlighting to code lines."""
    
    # Only apply highlighting if line contains code (not just whitespace)
    if not line_content.strip():
        return line_content
    
    # Keywords (most common ones first for efficiency)
    keywords = ['def', 'class', 'import', 'from', 'if', 'else', 'elif', 'for', 'while', 'try', 'except', 'finally', 'with', 'as', 'return', 'yield', 'break', 'continue', 'pass', 'raise', 'assert', 'del', 'global', 'nonlocal', 'lambda', 'True', 'False', 'None', 'and', 'or', 'not', 'in', 'is']
    for keyword in keywords:
        if keyword in line_content:
            line_content = re.sub(r'\b' + re.escape(keyword) + r'\b', f'<span class="keyword">{keyword}</span>', line_content)
    
    # Comments (check first to avoid highlighting keywords in comments)
    if '#' in line_content:
        line_content = re.sub(r'#.*$', lambda m: f'<span class="comment">{m.group(0)}</span>', line_content)
    
    # Strings (only if not already in a comment)
    if '"' in line_content and 'comment' not in line_content:
        line_content = re.sub(r'"[^"]*"', lambda m: f'<span class="string">{m.group(0)}</span>', line_content)
    if "'" in line_content and 'comment' not in line_content:
        line_content = re.sub(r"'[^']*'", lambda m: f'<span class="string">{m.group(0)}</span>', line_content)
    
    # Numbers (only if not in strings or comments)
    if any(c.isdigit() for c in line_content) and 'string' not in line_content and 'comment' not in line_content:
        line_content = re.sub(r'\b\d+\b', lambda m: f'<span class="number">{m.group(0)}</span>', line_content)
    
    # Function calls (only if not in strings or comments)
    if '(' in line_content and 'string' not in line_content and 'comment' not in line_content:
        line_content = re.sub(r'\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', r'<span class="function">\1</span>(', line_content)
    
    return line_content


def generate_html_footer():
    """Generate HTML footer."""
    return """
    <div class="footer">
        <p>Generated by Test Report System</p>
    </div>
</body>
</html>"""


def get_function_name_at_line(source_lines, line_number):
    """Get the function name that contains the given line number."""
    # Look backwards from the line to find the function definition
    for i in range(line_number - 1, -1, -1):
        line = source_lines[i].strip()
        # Match function definitions (def function_name)
        match = re.match(r'^def\s+(\w+)\s*\(', line)
        if match:
            return match.group(1)
        # Match class definitions (class ClassName)
        match = re.match(r'^class\s+(\w+)', line)
        if match:
            return f"class {match.group(1)}"
    return "unknown function"


def find_functions(source_lines):
    """Return a list of (func_name, start_line, end_line) for all functions in the file."""
    functions = []
    func_stack = []
    for i, line in enumerate(source_lines):
        # Detect function definition
        match = re.match(r'^(\s*)def\s+(\w+)\s*\(', line)
        if match:
            indent = len(match.group(1))
            func_name = match.group(2)
            func_stack.append((func_name, i, indent))
        # Detect end of function by dedent
        if func_stack:
            curr_func = func_stack[-1]
            curr_indent = curr_func[2]
            if (line.strip() == '' or line.lstrip().startswith('#')):
                continue
            line_indent = len(line) - len(line.lstrip())
            if line_indent <= curr_indent and i > curr_func[1]:
                # Function ends before this line
                func_name, start, _ = func_stack.pop()
                functions.append((func_name, start, i-1))
    # Handle function that goes to EOF
    while func_stack:
        func_name, start, _ = func_stack.pop()
        functions.append((func_name, start, len(source_lines)-1))
    return sorted(functions, key=lambda x: x[1])


def generate_detailed_coverage_report():
    """Generate a detailed coverage report with code context in HTML format."""
    
    # Initialize coverage
    cov = coverage.Coverage()
    
    try:
        cov.load()
    except coverage.misc.CoverageException:
        print("No coverage data found. Run tests with coverage first.")
        return False
    
    # Get coverage data
    analysis = {}
    for filename in cov.get_data().measured_files():
        try:
            result = cov.analysis2(filename)
            # analysis2 returns (filename, statements, excluded, missing, missing_branches)
            analysis[filename] = result
        except Exception as e:
            print(f"Warning: Could not analyze {filename}: {e}")
            continue
    
    # Start building HTML
    html_content = [generate_html_header()]
    
    # Title
    html_content.append('<h1>ðŸ“Š Detailed Coverage Report</h1>')
    html_content.append('<p>This report shows all uncovered code lines with context, highlighting which lines are covered and which are not.</p>')
    
    # Overall stats
    total_statements = sum(len(stmts) for _, stmts, _, missing, _ in analysis.values())
    total_missing = sum(len(missing) for _, _, _, missing, _ in analysis.values())
    total_coverage = ((total_statements - total_missing) / total_statements * 100) if total_statements > 0 else 0
    files_with_issues = len([f for f, (_, _, _, missing, _) in analysis.items() if missing])
    
    html_content.append('<div class="stats">')
    html_content.append(f'''
    <div class="stat">
        <div class="stat-number">{total_coverage:.2f}%</div>
        <div class="stat-label">Total Coverage</div>
    </div>''')
    html_content.append(f'''
    <div class="stat">
        <div class="stat-number">{total_statements:,}</div>
        <div class="stat-label">Total Statements</div>
    </div>''')
    html_content.append(f'''
    <div class="stat">
        <div class="stat-number">{total_missing:,}</div>
        <div class="stat-label">Missing Statements</div>
    </div>''')
    html_content.append(f'''
    <div class="stat">
        <div class="stat-number">{files_with_issues}</div>
        <div class="stat-label">Files with Issues</div>
    </div>''')
    html_content.append('</div>')
    
    # Legend
    html_content.append('<div class="legend">')
    html_content.append('<h3>Legend</h3>')
    html_content.append('<div class="legend-item">')
    html_content.append('<div class="legend-color" style="background-color: #4caf50;"></div>')
    html_content.append('<span>Covered lines: Code that was executed during testing</span>')
    html_content.append('</div>')
    html_content.append('<div class="legend-item">')
    html_content.append('<div class="legend-color" style="background-color: #f44336;"></div>')
    html_content.append('<span>Uncovered lines: Code that was not executed during testing</span>')
    html_content.append('</div>')
    html_content.append('<div class="legend-item">')
    html_content.append('<div class="legend-color" style="background-color: #858585;"></div>')
    html_content.append('<span>Context lines: Code before and after uncovered lines</span>')
    html_content.append('</div>')
    html_content.append('</div>')
    
    # Process each file
    for filename, (_, statements, excluded, missing, missing_branches) in analysis.items():
        if not missing:  # Skip files with 100% coverage
            continue
            
        # Skip files with very high coverage (>95%) to make report more compact
        coverage_pct = ((len(statements) - len(missing)) / len(statements) * 100) if statements else 0
        if coverage_pct > 95:
            continue
            
        # Calculate file coverage
        file_coverage = ((len(statements) - len(missing)) / len(statements) * 100) if statements else 0
        covered_count = len(statements) - len(missing)
        
        html_content.append('<div class="file-section">')
        html_content.append(f'<div class="file-header">')
        html_content.append(f'{filename} - {file_coverage:.2f}% coverage ({covered_count}/{len(statements)} lines)')
        html_content.append('</div>')
        
        # Read the source file
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                source_lines = f.readlines()
        except Exception as e:
            html_content.append(f'<p><em>Unable to read source file: {filename} - {e}</em></p>')
            html_content.append('</div>')
            continue
        
        # Group missing lines by function
        functions = find_functions(source_lines)
        for func_name, func_start, func_end in functions:
            func_lines = set(range(func_start+1, func_end+2))  # 1-based
            missed_in_func = sorted(set(missing) & func_lines)
            if not missed_in_func:
                continue
            html_content.append(f'<h4>Function: {func_name} (lines {func_start+1}-{func_end+1})</h4>')
            html_content.append('<pre>')
            for i in range(func_start+1, func_end+2):
                line_content = source_lines[i-1].rstrip()
                escaped_content = html.escape(line_content)
                if i in missed_in_func:
                    html_content.append(f'<span class="line-number">{i:3d}</span><span class="uncovered">{escaped_content}</span>')
                else:
                    html_content.append(f'<span class="line-number">{i:3d}</span>{escaped_content}')
            html_content.append('</pre>')
        
        html_content.append('</div>')
    

    
    # Footer
    html_content.append(generate_html_footer())
    
    # Write the report
    output_file = 'tests/reports/coverage.html'
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(html_content))
    
    print(f'âœ… Detailed coverage report generated: {output_file}')
    return True


if __name__ == '__main__':
    success = generate_detailed_coverage_report()
    sys.exit(0 if success else 1)