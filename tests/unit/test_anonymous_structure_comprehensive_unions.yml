test:
  name: "Anonymous Unions in Structs"
  id: "0104"
  description: "Validate that anonymous unions within structs are correctly processed with proper field flattening and relationships"

---
source_files:
  anon_unions.c: |
    typedef struct {
        int type_id;
        union {
            int int_value;
            float float_value;
            char string_value[64];
            struct {
                int x, y, z;
            } point_value;
        } data_union;
        int checksum;
    } struct_with_union_t;
    
    void set_union_data(struct_with_union_t* s, int type) {
        s->type_id = type;
        if (type == 1) {
            s->data_union.int_value = 42;
        } else if (type == 2) {
            s->data_union.point_value.x = 10;
        }
        s->checksum = 0xFF;
    }
    
    struct_with_union_t global_struct;

---
config.json: |
  {
    "project_name": "anonymous_unions_in_structs",
    "source_folders": ["."],
    "output_dir": "./output",
    "recursive_search": true
  }

---
cli_execution:
  steps:
    - parse_only

---
assertions:
  execution:
    should_succeed: true
    
  model:
    structs_exist: ["struct_with_union_t", "__anonymous_struct__", "data_union_point_value"]
    unions_exist: ["data_union", "struct_with_union_t_data_union"]
    functions_exist: ["set_union_data"]
    globals_exist: ["global_struct"]
    
    # Anonymous relationships are tracked in the model
    # The actual validation is done by checking that multiple structs/unions are created for anonymous structures
    
    # Validate main struct field parsing
    struct_fields:
      struct_with_union_t:
        - name: "type_id"
          type: "int"
        - name: "data_union"
          type: "data_union"
        - name: "checksum"
          type: "int"
    
    # Validate union field parsing
    union_fields:
      data_union:
        - name: "int_value"
          type: "int"
        - name: "float_value"
          type: "float"
        - name: "string_value"
          type: "char[64]"
        - name: "point_value"
          type: "data_union_point_value"
    
    # Validate point value struct
    struct_fields:
      data_union_point_value:
        - name: "x"
          type: "int"
        - name: "y"
          type: "int"
        - name: "z"
          type: "int"
    
    # Validate second union (duplicate parsing artifact)
    union_fields:
      struct_with_union_t_data_union:
        - name: "x"
          type: "int"
        - name: "y"
          type: "int"
        - name: "z"
          type: "int"
    
    element_counts:
      structs: 3  # struct_with_union_t + __anonymous_struct__ + data_union_point_value
      unions: 2   # data_union + struct_with_union_t_data_union (duplicate)
      functions: 1
      globals: 1
      aliases: 0
      
  puml:
    contains_elements: ["struct_with_union_t", "set_union_data", "global_struct"]
    contains_lines:
      - "void set_union_data(struct_with_union_t * s, int type)"
      - "+ int type_id"
      - "+ data_union data_union"
      - "+ int checksum"
      - "+ int int_value"
      - "+ float float_value"
      - "+ char[64] string_value"
      - "+ data_union_point_value point_value"
      - "+ int x"
      - "+ int y"
      - "+ int z"
      - "struct_with_union_t global_struct"
    
    class_count: 6  # source + 3 structs + 2 unions
    relationship_count: 6  # 3 declares + 1 uses + 2 composition relationships